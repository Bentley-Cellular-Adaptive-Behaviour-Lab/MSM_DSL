package org.iets3.core.expr.base.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.lang.editor.menus.substitute.DefaultSubstituteMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.editor.menus.substitute.ReferenceScopeSubstituteMenuItem;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.editor.menus.substitute.SubstituteMenuItemWrapper;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import com.mbeddr.mpsutil.grammarcells.runtime.Parser;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextActionItem;
import jetbrains.mps.smodel.presentation.NodePresentationUtil;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import com.mbeddr.mpsutil.grammarcells.runtime.SavedCaretPosition;
import com.mbeddr.mpsutil.grammarcells.runtime.StringOrSequenceQuery;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSideTransformTransformationMenuItem;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.editor.runtime.cells.CellIdManager;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import com.mbeddr.mpsutil.grammarcells.runtime.EditorHierachyCache;
import com.mbeddr.mpsutil.grammarcells.runtime.IFlagModelAccess;
import com.mbeddr.mpsutil.grammarcells.runtime.DefaultFlagModelAccess;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.ISymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.ChildSymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.SyntaxMatcher;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextSubsituteAction;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import com.mbeddr.mpsutil.grammarcells.runtime.AbstractRule;
import com.mbeddr.mpsutil.grammarcells.runtime.ConstantSymbol;
import org.iets3.core.expr.base.behavior.BinaryExpression__BehaviorDescriptor;
import org.iets3.core.expr.base.behavior.UnaryExpression__BehaviorDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.base.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5115872837156576352")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryExpression$j$)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, _context.getModel(), BinaryExpression_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.left$zxUa).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.left$zxUa, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5115872837156576423")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BinaryExpression$j$)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, _context.getModel(), BinaryExpression_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.right$zBjx).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.right$zBjx, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "LogicalNotExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "6856661361479368901")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.LogicalNotExpression$QD)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.LogicalNotExpression$QD, _context.getModel(), LogicalNotExpression_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$Hji0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "UnaryMinusExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5285810042892718134")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.UnaryMinusExpression$Gz)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.UnaryMinusExpression$Gz, _context.getModel(), UnaryMinusExpression_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$Hji0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "DotExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "9002563722476995254")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.DotExpression$jp)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.DotExpression$jp, _context.getModel(), DotExpression_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$Hji0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ErrorLiteral", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "1919538606561059618")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ErrorLiteral$cb)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ErrorLiteral$cb, _context.getModel(), ErrorLiteral_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.ErrorLiteral$cb;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "PlainConstraint", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "867786408882279867")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.PlainConstraint$Xf)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.PlainConstraint$Xf, _context.getModel(), PlainConstraint_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$Wyjb).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$Wyjb, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "TupleAccessExpr", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "2527679671886484103")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.TupleAccessExpr$UY)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.TupleAccessExpr$UY, _context.getModel(), TupleAccessExpr_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.tuple$Aujp).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.tuple$Aujp, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AltOption", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "7971844778466907184")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.AltOption$OS)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.AltOption$OS, _context.getModel(), AltOption_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.when$ywD6).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.when$ywD6, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), wrappedNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ColonCast", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5955298286257997880")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ColonCast$8S)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ColonCast$8S, _context.getModel(), ColonCast_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$A2T_).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$A2T_, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BangOp", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "2390066428848653432")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.BangOp$rF)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BangOp$rF, _context.getModel(), BangOp_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.expr$Hji0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ConvenientBoolean", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "8435714728544598601")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ConvenientBoolean$jZ)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.ConvenientBooleanValue$ku;
              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ConvenientBoolean$jZ, _context.getModel(), ConvenientBoolean_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.value$4I7H).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new IWhereFilter<SubstituteMenuItem>() {
                      public boolean accept(SubstituteMenuItem it) {
                        boolean isApplicable = true;
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).select(new ISelector<SubstituteMenuItem, SubstituteMenuItem>() {
                      public SubstituteMenuItem select(SubstituteMenuItem it) {
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil_copy.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                          private SNode wrappedNode;
                          @Override
                          public SNode createNode(@NotNull String pattern) {
                            SNode nodeToWrap = super.createNode(pattern);
                            wrappedNode = nodeToWrap;
                            // use setupNode after setting wrapped element to allow access to the wrapped element in node factories 
                            SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                            SLinkOperations.setTarget(wrapper, LINKS.value$4I7H, SNodeOperations.cast(nodeToWrap, CONCEPTS.ConvenientBooleanValue$ku));
                            NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                            return wrapper;
                          }
                          @Override
                          public SAbstractConcept getOutputConcept() {
                            return outputConcept;
                          }

                          @Override
                          public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                            GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                          }
                        };
                        return wrapper;
                      }
                    }).toListSequence();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
            public boolean accept(SubstituteMenuItem it) {
              return it != null;
            }
          }).toListSequence();
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where(new IWhereFilter<SubstituteMenuItem>() {
      public boolean accept(SubstituteMenuItem it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.base.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5115872837156576352")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, _context.getModel(), BinaryExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryExpression$j$);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.left$zxUa, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BinaryExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5115872837156576423")));
              try {
                if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, _context.getModel(), BinaryExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BinaryExpression$j$);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.right$zBjx, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "LogicalNotExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "6856661361479368901")));
              try {
                if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.LogicalNotExpression$QD, _context.getModel(), LogicalNotExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = new Object() {
                          public Iterable<String> query(SNode wrappedNode) {
                            return new StringOrSequenceQuery() {
                              public Object queryStringOrSequence() {
                                return "!";
                              }
                            }.query();
                          }
                        }.query(sourceNode);
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.LogicalNotExpression$QD);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.LogicalNotExpression$QD, _context.getModel(), LogicalNotExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = new Object() {
                          public Iterable<String> query(SNode wrappedNode) {
                            return new StringOrSequenceQuery() {
                              public Object queryStringOrSequence() {
                                return null;
                              }
                            }.query();
                          }
                        }.query(sourceNode);
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.LogicalNotExpression$QD);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "UnaryMinusExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5285810042892718134")));
              try {
                if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.UnaryMinusExpression$Gz, _context.getModel(), UnaryMinusExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.UnaryMinusExpression$Gz);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.brackets in " + "ParensExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "4065005624680652477")));
              try {
                List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
                {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);
                  if (sourceNode != null) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSideTransformTransformationMenuItem(_context) {
                      public String getDescriptionText(String string) {
                        return "ParensExpression";
                      }
                      public String getMatchingText(String pattern) {
                        return (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? "(" : ")");
                      }
                      @Override
                      public void execute(@NotNull String pattern) {
                        doSubstitute(_context.getEditorContext(), pattern);
                      }
                      protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                        SNode annotation = SNodeFactoryOperations.addNewAttribute(sourceNode, new IAttributeDescriptor.NodeAttribute(CONCEPTS.ArbitraryTextAnnotation$hv), CONCEPTS.ArbitraryTextAnnotation$hv);
                        SPropertyOperations.assign(annotation, PROPS.text$Fl1W, getMatchingText(pattern));
                        SPropertyOperations.assign(annotation, PROPS.left$Cu1K, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
                        SelectionUtil.selectLabelCellAnSetCaret(editorContext, annotation, "*" + CellIdManager.createPropertyId("text"), -1);

                        SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                        caretPosition.save();
                        Parser parser = new Parser(SNodeOperations.getModel(sourceNode));
                        SNode newTree = parser.processAfterTextInsert(parser.findRootExpression(sourceNode));
                        if (newTree != null) {
                          editorContext.flushEvents();
                          caretPosition.restore();
                        }

                        return null;
                      }
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.ParensExpression$Tv;
                      }
                    });
                  }
                }
                return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                  public boolean accept(TransformationMenuItem it) {
                    return it != null;
                  }
                }).toListSequence();
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "DotExpression", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "9002563722476995254")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.DotExpression$jp, _context.getModel(), DotExpression_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return ".";
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return !(SNodeOperations.isInstanceOf(wrappedNode, CONCEPTS.INeverAllowDot$J1));
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.DotExpression$jp);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ErrorLiteral", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "1919538606561059618")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "PlainConstraint", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "867786408882279867")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.PlainConstraint$Xf, _context.getModel(), PlainConstraint_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton(":");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.PlainConstraint$Xf);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Wyjb, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "TupleAccessExpr", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "2527679671886484103")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.TupleAccessExpr$UY, _context.getModel(), TupleAccessExpr_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("[");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return SNodeOperations.isInstanceOf(TypecheckingFacade.getFromContext().getTypeOf(wrappedNode), CONCEPTS.TupleType$8E);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.TupleAccessExpr$UY);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.tuple$Aujp, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AltOption", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "7971844778466907184")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.AltOption$OS, _context.getModel(), AltOption_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("=>");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.AltOption$OS);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.when$ywD6, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ColonCast", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "5955298286257997880")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ColonCast$8S, _context.getModel(), ColonCast_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
                          public String query(SAbstractConcept subconcept) {
                            return SConceptOperations.conceptAlias(subconcept);
                          }
                        }.query(subconcept))).where(new IWhereFilter<String>() {
                          public boolean accept(String it) {
                            return (it != null && it.length() > 0);
                          }
                        });
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.ColonCast$8S);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$A2T_, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "BangOp", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "2390066428848653432")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BangOp$rF, _context.getModel(), BangOp_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("!");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ModelConstraints.canBeParent(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= ModelConstraints.canBeChild(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink(), null);
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return SNodeOperations.isInstanceOf(TypecheckingFacade.getFromContext().getTypeOf(wrappedNode), CONCEPTS.OptionType$eU);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              public String getDescriptionText(String string) {
                                return NodePresentationUtil.descriptionText(subconcept);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.BangOp$rF);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.expr$Hji0, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst(new IWhereFilter<SNode>() {
                                  public boolean accept(SNode it) {
                                    return it != sourceNode;
                                  }
                                });
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ConvenientBoolean", new SNodePointer("r:8405f486-53b5-4fe6-af3e-7f68358bd631(org.iets3.core.expr.base.editor)", "8435714728544598601")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
                public boolean accept(TransformationMenuItem it) {
                  return it != null;
                }
              }).toListSequence();
            }
          }.query(_context)));
        }
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to thenPart 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IfExpression$6$, LINKS.thenPart$bVSc);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.IfExpression$6$) && Objects.equals(sourceNode.getContainmentLink(), LINKS.thenPart$bVSc) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IfExpression$6$) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to condition 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IfExpression$6$, LINKS.condition$bVqa);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.IfExpression$6$) && Objects.equals(sourceNode.getContainmentLink(), LINKS.condition$bVqa) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IfExpression$6$) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to elseSection 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IfExpression$6$, LINKS.elseSection$kbJ$);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.IfElseSection$B4) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.IfExpression$6$) && Objects.equals(sourceNode.getContainmentLink(), LINKS.elseSection$kbJ$) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.elseSection$kbJ$)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.IfExpression$6$)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return new Object() {
                    public Iterable<String> query(SNode node) {
                      return new StringOrSequenceQuery() {
                        public Object queryStringOrSequence() {
                          return "else";
                        }
                      }.query();
                    }

                  }.query(sourceNode);
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.IfExpression$6$), LINKS.elseSection$kbJ$) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.IfExpression$6$), LINKS.elseSection$kbJ$, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.IfExpression$6$;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(IfExpression_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IsSomeExpression$Ae) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IsSomeExpression$Ae, LINKS.expr$abfa);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.IsSomeExpression$Ae) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$abfa) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IsSomeExpression$Ae) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IsSomeExpression$Ae) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.IsSomeExpression$Ae) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to optionalName 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IsSomeExpression$Ae, LINKS.optionalName$AhFr);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.OptionalNameSpecifier$3X) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.IsSomeExpression$Ae) && Objects.equals(sourceNode.getContainmentLink(), LINKS.optionalName$AhFr) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.IsSomeExpression$Ae)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("as");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.IsSomeExpression$Ae), LINKS.optionalName$AhFr) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.IsSomeExpression$Ae), LINKS.optionalName$AhFr, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.IsSomeExpression$Ae;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(IsSomeExpression_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.NoneLiteral$$J) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.NoneLiteral$$J) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalBaseType$UUMR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to optionalBaseType 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.NoneLiteral$$J, LINKS.optionalBaseType$UUMR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.NoneLiteral$$J) && Objects.equals(sourceNode.getContainmentLink(), LINKS.optionalBaseType$UUMR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalBaseType$UUMR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.NoneLiteral$$J) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalBaseType$UUMR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.NoneLiteral$$J)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("<");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.NoneLiteral$$J), LINKS.optionalBaseType$UUMR) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.NoneLiteral$$J), LINKS.optionalBaseType$UUMR, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.NoneLiteral$$J;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(NoneLiteral_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to successType 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.AttemptType$h8, LINKS.successType$Xfwb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.AttemptType$h8) && Objects.equals(sourceNode.getContainmentLink(), LINKS.successType$Xfwb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiterals$XkTy)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to errorLiterals 
            final SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorLiterals$XkTy, CONCEPTS.AttemptType$h8, CONCEPTS.ErrorLiteral$cb, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
            if (listElement != null && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              List<SNode> allChildren = SLinkOperations.getChildren(SNodeOperations.cast(SNodeOperations.getParent(listElement), CONCEPTS.AttemptType$h8), LINKS.errorLiterals$XkTy);
              SNode allowedChild = null;
              allowedChild = ListSequence.fromList(allChildren).first();
              if (listElement == allowedChild) {
                TransformationMenuContext parentContext = _context.withNode(SNodeOperations.getParent(listElement));
                return parentContext;
              }
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiterals$XkTy)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.AttemptType$h8)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("|");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(_context.getNode(), CONCEPTS.AttemptType$h8), LINKS.errorLiterals$XkTy)).isNotEmpty();
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode result = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(_context.getNode(), CONCEPTS.AttemptType$h8), LINKS.errorLiterals$XkTy)).insertElement(0, SNodeFactoryOperations.createNewNode(CONCEPTS.ErrorLiteral$cb, null));

                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.AttemptType$h8;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(AttemptType_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to errorLiterals 
            final SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorLiterals$XkTy, CONCEPTS.AttemptType$h8, CONCEPTS.ErrorLiteral$cb, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
            if (listElement != null && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              List<SNode> allChildren = SLinkOperations.getChildren(SNodeOperations.cast(SNodeOperations.getParent(listElement), CONCEPTS.AttemptType$h8), LINKS.errorLiterals$XkTy);
              SNode allowedChild = null;
              allowedChild = ListSequence.fromList(allChildren).last();
              if (listElement == allowedChild) {
                TransformationMenuContext parentContext = _context.withNode(SNodeOperations.getParent(listElement));
                return parentContext;
              }
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiterals$XkTy)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiterals$XkTy)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to successType 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.AttemptType$h8, LINKS.successType$Xfwb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.AttemptType$h8) && Objects.equals(sourceNode.getContainmentLink(), LINKS.successType$Xfwb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.AttemptType$h8) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.AttemptType$h8)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("|");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return true;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode result = SNodeFactoryOperations.addNewChild(SNodeOperations.cast(_context.getNode(), CONCEPTS.AttemptType$h8), LINKS.errorLiterals$XkTy, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.AttemptType$h8;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(AttemptType_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.ErrorExpression$aj) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.ErrorExpression$aj) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.error$dXhE)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to error 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.ErrorExpression$aj, LINKS.error$dXhE);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.ErrorLiteral$cb) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.ErrorExpression$aj) && Objects.equals(sourceNode.getContainmentLink(), LINKS.error$dXhE) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.error$dXhE)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.ErrorExpression$aj) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.error$dXhE)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.ErrorExpression$aj)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("(");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.ErrorExpression$aj), LINKS.error$dXhE) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.ErrorExpression$aj), LINKS.error$dXhE, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.ErrorExpression$aj;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(ErrorExpression_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.complete$PYwr);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.expr$TQmf);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$TQmf) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to optionalName 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.optionalName$AhFr);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.OptionalNameSpecifier$3X) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.optionalName$AhFr) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to successClause 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.successClause$ZBbX);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.TrySuccessClause$Yi) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.successClause$ZBbX) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(null);
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to errorClauses 
            final SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorClauses$g1xK, CONCEPTS.TryExpression$s4, CONCEPTS.TryErrorClause$MY, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
            if (listElement != null && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              List<SNode> allChildren = SLinkOperations.getChildren(SNodeOperations.cast(SNodeOperations.getParent(listElement), CONCEPTS.TryExpression$s4), LINKS.errorClauses$g1xK);
              SNode allowedChild = null;
              allowedChild = ListSequence.fromList(allChildren).first();
              if (listElement == allowedChild) {
                TransformationMenuContext parentContext = _context.withNode(SNodeOperations.getParent(listElement));
                return parentContext;
              }
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.errorClauses$g1xK)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.TryExpression$s4)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "complete";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.complete$PYwr);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.TryExpression$s4);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.complete$PYwr);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_complete", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.TryExpression$s4;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(TryExpression_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.expr$TQmf);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$TQmf) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.complete$PYwr);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryExpression$s4) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to optionalName 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.optionalName$AhFr);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.OptionalNameSpecifier$3X) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.optionalName$AhFr) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.optionalName$AhFr)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to successClause 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryExpression$s4, LINKS.successClause$ZBbX);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.TrySuccessClause$Yi) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryExpression$s4) && Objects.equals(sourceNode.getContainmentLink(), LINKS.successClause$ZBbX) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(null);
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to errorClauses 
            final SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorClauses$g1xK, CONCEPTS.TryExpression$s4, CONCEPTS.TryErrorClause$MY, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
            if (listElement != null && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              List<SNode> allChildren = SLinkOperations.getChildren(SNodeOperations.cast(SNodeOperations.getParent(listElement), CONCEPTS.TryExpression$s4), LINKS.errorClauses$g1xK);
              SNode allowedChild = null;
              allowedChild = ListSequence.fromList(allChildren).first();
              if (listElement == allowedChild) {
                TransformationMenuContext parentContext = _context.withNode(SNodeOperations.getParent(listElement));
                return parentContext;
              }
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.errorClauses$g1xK)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.TryExpression$s4)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("as");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.TryExpression$s4), LINKS.optionalName$AhFr) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.TryExpression$s4), LINKS.optionalName$AhFr, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.TryExpression$s4;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(TryExpression_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryErrorClause$MY) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryErrorClause$MY) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiteral$QRaD)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to errorLiteral 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryErrorClause$MY, LINKS.errorLiteral$QRaD);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.ErrorLiteral$cb) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryErrorClause$MY) && Objects.equals(sourceNode.getContainmentLink(), LINKS.errorLiteral$QRaD) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiteral$QRaD)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryErrorClause$MY) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.errorLiteral$QRaD)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.TryErrorClause$MY) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.TryErrorClause$MY, LINKS.expr$SCnF);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.TryErrorClause$MY) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$SCnF) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.TryErrorClause$MY)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("<");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.TryErrorClause$MY), LINKS.errorLiteral$QRaD) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.TryErrorClause$MY), LINKS.errorLiteral$QRaD, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.TryErrorClause$MY;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(TryErrorClause_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Invariant$I1, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Invariant$I1) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Invariant$I1, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Invariant$I1) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Invariant$I1)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "warning";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.Invariant$I1);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_warning", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Invariant$I1;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Invariant_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Invariant$I1, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Invariant$I1) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Invariant$I1) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Invariant$I1, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Invariant$I1) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Invariant$I1)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton(":");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.Invariant$I1), LINKS.err$phDR) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.Invariant$I1), LINKS.err$phDR, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Invariant$I1;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Invariant_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Postcondition$Hy, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Postcondition$Hy) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Postcondition$Hy, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Postcondition$Hy) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Postcondition$Hy)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "warning";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.Postcondition$Hy);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_warning", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Postcondition$Hy;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Postcondition_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Postcondition$Hy, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Postcondition$Hy) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Postcondition$Hy) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Postcondition$Hy, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Postcondition$Hy) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Postcondition$Hy)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton(":");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.Postcondition$Hy), LINKS.err$phDR) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.Postcondition$Hy), LINKS.err$phDR, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Postcondition$Hy;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Postcondition_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Precondition$kn, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Precondition$kn) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Precondition$kn, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Precondition$kn) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Precondition$kn)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "warning";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.Precondition$kn);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_warning", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Precondition$kn;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Precondition_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Precondition$kn, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Precondition$kn) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.Precondition$kn) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Precondition$kn, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.Precondition$kn) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Precondition$kn)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton(":");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.Precondition$kn), LINKS.err$phDR) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.Precondition$kn), LINKS.err$phDR, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.Precondition$kn;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(Precondition_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.PlainConstraint$Xf, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.PlainConstraint$Xf) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.PlainConstraint$Xf, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.PlainConstraint$Xf) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.PlainConstraint$Xf)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "warning";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.PlainConstraint$Xf);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_warning", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.PlainConstraint$Xf;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(PlainConstraint_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.PlainConstraint$Xf, LINKS.expr$Wyjb);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.PlainConstraint$Xf) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$Wyjb) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.warning$kIYM);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.PlainConstraint$Xf) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to err 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.PlainConstraint$Xf, LINKS.err$phDR);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.PlainConstraint$Xf) && Objects.equals(sourceNode.getContainmentLink(), LINKS.err$phDR) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.err$phDR)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.PlainConstraint$Xf)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton(":");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.PlainConstraint$Xf), LINKS.err$phDR) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.PlainConstraint$Xf), LINKS.err$phDR, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.PlainConstraint$Xf;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(PlainConstraint_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.failIfInvalid$GYZJ);
                if (!(access.read(node))) {
                  return false;
                }


                return true;
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to tp 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.CheckTypeConstraintsExpr$w9, LINKS.tp$hCEG);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.CheckTypeConstraintsExpr$w9) && Objects.equals(sourceNode.getContainmentLink(), LINKS.tp$hCEG) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to expr 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.CheckTypeConstraintsExpr$w9, LINKS.expr$hCcE);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.CheckTypeConstraintsExpr$w9) && Objects.equals(sourceNode.getContainmentLink(), LINKS.expr$hCcE) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.CheckTypeConstraintsExpr$w9) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.CheckTypeConstraintsExpr$w9)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "/fail";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  final SNode node = _context.getNode();
                  IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.failIfInvalid$GYZJ);
                  boolean applicable = !(access.read(node));
                  applicable &= !(GrammarCellsUtil.isProperty(_context.getEditorContext().getSelectedCell())) || _context.getMenuLocation() != MenuLocations.RIGHT_SIDE_TRANSFORM;
                  return applicable;
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = SNodeOperations.cast(_context.getNode(), CONCEPTS.CheckTypeConstraintsExpr$w9);
                    IFlagModelAccess access = new DefaultFlagModelAccess(PROPS.failIfInvalid$GYZJ);
                    access.write(node, true);
                    SelectionUtil.selectLabelCellAnSetCaret(editorContext, node, "flag_failIfInvalid", -1);
                    return null;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.CheckTypeConstraintsExpr$w9;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(CheckTypeConstraintsExpr_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to type 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.type$AJf9);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.type$AJf9) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to message 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.message$kl8H);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.message$kl8H) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.contextExpression$k8BH)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to contextExpression 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.contextExpression$k8BH);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.contextExpression$k8BH) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.contextExpression$k8BH)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.FailExpr$SB)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton("<");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.FailExpr$SB), LINKS.type$AJf9) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.FailExpr$SB), LINKS.type$AJf9, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.FailExpr$SB;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(FailExpr_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to message 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.message$kl8H);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.message$kl8H) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to type 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.type$AJf9);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Type$WK) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.type$AJf9) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == true) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.type$AJf9)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.contextExpression$k8BH)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from(new Object() {
          public TransformationMenuContext redirect() {
            // redirect to contextExpression 
            final SNode sourceNode = _context.getNode();

            // Use the grammar rules for a deep search 
            SNode parentNode = new Parser(_context.getModel()).isEndOf(sourceNode, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.FailExpr$SB, LINKS.contextExpression$k8BH);
            if (parentNode != null) {
              return _context.withNode(parentNode);
            }

            // There might be no grammar for some concepts. Try a single level check. 
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.Expression$D_) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(sourceNode), CONCEPTS.FailExpr$SB) && Objects.equals(sourceNode.getContainmentLink(), LINKS.contextExpression$k8BH) && (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) == false) {
              TransformationMenuContext parentContext = _context.withNode(_context.getNode().getParent());
              return parentContext;
            }

            return null;
          }
        }.redirect(), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return new Object() {
              public boolean renderingCondition(SNode node) {
                return Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(node, LINKS.contextExpression$k8BH)).isNotEmpty();
              }
            }.renderingCondition(sourceNode);
          }
        }));
        ListSequence.fromList(redirectedAfter).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.FailExpr$SB) ? _context : null), new _FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>() {
          public Boolean invoke(TransformationMenuContext parentContext) {
            final SNode sourceNode = parentContext.getNode();
            return true;
          }
        }));
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.FailExpr$SB)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return Sequence.<String>singleton(",");
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return (SLinkOperations.getTarget(SNodeOperations.cast(_context.getNode(), CONCEPTS.FailExpr$SB), LINKS.contextExpression$k8BH) == null);
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    final SNode sourceNode = _context.getNode();
                    SNode result = SNodeFactoryOperations.setNewChild(SNodeOperations.cast(sourceNode, CONCEPTS.FailExpr$SB), LINKS.contextExpression$k8BH, null);
                    return result;
                  }
                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.FailExpr$SB;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where(new IWhereFilter<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>() {
              public boolean accept(Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>> it) {
                return it != null;
              }
            }).toListSequence();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(FailExpr_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        final SNode sourceNode = _context.getNode();
        final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
          protected Object queryStringOrSequence() {
            return Sequence.<String>singleton("|");
          }
        }.query();
        final boolean isApplicable = new Object() {
          public boolean query() {
            SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorLiterals$XkTy, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
            if (listElement == null) {
              return false;
            }
            return (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? (SNodeOperations.getPrevSibling(listElement) != null) : (SNodeOperations.getNextSibling(listElement) != null));
          }
        }.query();

        if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
          ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
            @Override
            public void execute(@NotNull String pattern) {
              doSubstitute(pattern);
            }
            public SNode doSubstitute(String pattern) {
              SNode listElement = GrammarCellsUtil.getListElementForSideTransformation(_context.getNode(), LINKS.errorLiterals$XkTy, _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM);
              SNode newNode = SNodeFactoryOperations.createNewNode(CONCEPTS.ErrorLiteral$cb, null);
              if (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM) {
                SNodeOperations.insertPrevSiblingChild(listElement, newNode);
              } else {
                SNodeOperations.insertNextSiblingChild(listElement, newNode);
              }
              return newNode;
            }
            public SAbstractConcept getOutputConcept() {
              return CONCEPTS.AttemptType$h8;
            }
          });
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where(new IWhereFilter<TransformationMenuItem>() {
      public boolean accept(TransformationMenuItem it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());

    // BinaryExpression_Editor 
    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, _context.getModel(), BinaryExpression_Editor.class)) {

      final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
        public String query(SAbstractConcept subconcept) {
          return SConceptOperations.conceptAlias(subconcept);
        }
      }.query(subconcept))).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return (it != null && it.length() > 0);
        }
      });
      boolean conceptAllowed = SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(_context.getChildConcept()));
      SNode sourceNode = _context.getCurrentTargetNode();
      boolean transformationEnabled = ModelConstraints.canBeParent(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      transformationEnabled &= ModelConstraints.canBeAncestor(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      if (Sequence.fromIterable(matchingText).isNotEmpty() && conceptAllowed && transformationEnabled) {

        final List<ISymbol> beforeMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        final List<ISymbol> afterMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        ListSequence.fromList(beforeMatchers).addElement(new ChildSymbol(LINKS.left$zxUa));
        ListSequence.fromList(afterMatchers).addElement(new ChildSymbol(LINKS.right$zBjx));
        final SyntaxMatcher matcher = new SyntaxMatcher();
        if (matcher.matches(elementsBefore, beforeMatchers, false, null) && matcher.matches(elementsAfter, afterMatchers, false, null)) {

          ListSequence.fromList(result).addElement(new MultiTextSubsituteAction(_context.getParentNode(), matchingText) {
            public String getDescriptionText(String pattern) {
              String shortDescription = subconcept.getShortDescription();
              return (shortDescription != null ? shortDescription : subconcept.getName());
            }
            @Override
            protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
              SNode newNode = SNodeFactoryOperations.createNewNode(subconcept, null);

              matcher.matches(elementsBefore, beforeMatchers, true, newNode);
              matcher.matches(elementsAfter, afterMatchers, true, newNode);

              _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), newNode, editorContext);

              GrammarCellsUtil.selectCellWithText(editorContext, newNode, getMatchingText(pattern));

              SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
              caretPosition.save();
              Parser parser = new Parser(editorContext.getModel());
              SNode expressionRoot = parser.findRootExpression(newNode);
              parser.rebalanceIfRequired(expressionRoot);
              caretPosition.restore();

              return null;
            }
            @Override
            public SNode getOutputConcept() {
              return SNodeOperations.asNode(subconcept);
            }
          });
        }
      }
    }



    // UnaryMinusExpression_Editor 
    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.UnaryMinusExpression$Gz, _context.getModel(), UnaryMinusExpression_Editor.class)) {

      final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
        public String query(SAbstractConcept subconcept) {
          return SConceptOperations.conceptAlias(subconcept);
        }
      }.query(subconcept))).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return (it != null && it.length() > 0);
        }
      });
      boolean conceptAllowed = SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(_context.getChildConcept()));
      SNode sourceNode = _context.getCurrentTargetNode();
      boolean transformationEnabled = ModelConstraints.canBeParent(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      transformationEnabled &= ModelConstraints.canBeAncestor(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      if (Sequence.fromIterable(matchingText).isNotEmpty() && conceptAllowed && transformationEnabled) {

        final List<ISymbol> beforeMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        final List<ISymbol> afterMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        ListSequence.fromList(afterMatchers).addElement(new ChildSymbol(LINKS.expr$Hji0));
        final SyntaxMatcher matcher = new SyntaxMatcher();
        if (matcher.matches(elementsBefore, beforeMatchers, false, null) && matcher.matches(elementsAfter, afterMatchers, false, null)) {

          ListSequence.fromList(result).addElement(new MultiTextSubsituteAction(_context.getParentNode(), matchingText) {
            public String getDescriptionText(String pattern) {
              String shortDescription = subconcept.getShortDescription();
              return (shortDescription != null ? shortDescription : subconcept.getName());
            }
            @Override
            protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
              SNode newNode = SNodeFactoryOperations.createNewNode(subconcept, null);

              matcher.matches(elementsBefore, beforeMatchers, true, newNode);
              matcher.matches(elementsAfter, afterMatchers, true, newNode);

              _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), newNode, editorContext);

              GrammarCellsUtil.selectCellWithText(editorContext, newNode, getMatchingText(pattern));

              SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
              caretPosition.save();
              Parser parser = new Parser(editorContext.getModel());
              SNode expressionRoot = parser.findRootExpression(newNode);
              parser.rebalanceIfRequired(expressionRoot);
              caretPosition.restore();

              return null;
            }
            @Override
            public SNode getOutputConcept() {
              return SNodeOperations.asNode(subconcept);
            }
          });
        }
      }
    }



    // ColonCast_Editor 
    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ColonCast$8S, _context.getModel(), ColonCast_Editor.class)) {

      final Iterable<String> matchingText = Sequence.fromIterable(Sequence.<String>singleton(new Object() {
        public String query(SAbstractConcept subconcept) {
          return SConceptOperations.conceptAlias(subconcept);
        }
      }.query(subconcept))).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return (it != null && it.length() > 0);
        }
      });
      boolean conceptAllowed = SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(_context.getChildConcept()));
      SNode sourceNode = _context.getCurrentTargetNode();
      boolean transformationEnabled = ModelConstraints.canBeParent(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      transformationEnabled &= ModelConstraints.canBeAncestor(_context.getParentNode(), subconcept, sourceNode.getContainmentLink(), null);
      if (Sequence.fromIterable(matchingText).isNotEmpty() && conceptAllowed && transformationEnabled) {

        final List<ISymbol> beforeMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        final List<ISymbol> afterMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        ListSequence.fromList(beforeMatchers).addElement(new ChildSymbol(LINKS.expr$A2T_));
        ListSequence.fromList(afterMatchers).addElement(new ChildSymbol(LINKS.type$A3AC));
        final SyntaxMatcher matcher = new SyntaxMatcher();
        if (matcher.matches(elementsBefore, beforeMatchers, false, null) && matcher.matches(elementsAfter, afterMatchers, false, null)) {

          ListSequence.fromList(result).addElement(new MultiTextSubsituteAction(_context.getParentNode(), matchingText) {
            public String getDescriptionText(String pattern) {
              String shortDescription = subconcept.getShortDescription();
              return (shortDescription != null ? shortDescription : subconcept.getName());
            }
            @Override
            protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
              SNode newNode = SNodeFactoryOperations.createNewNode(subconcept, null);

              matcher.matches(elementsBefore, beforeMatchers, true, newNode);
              matcher.matches(elementsAfter, afterMatchers, true, newNode);

              _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), newNode, editorContext);

              GrammarCellsUtil.selectCellWithText(editorContext, newNode, getMatchingText(pattern));

              SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
              caretPosition.save();
              Parser parser = new Parser(editorContext.getModel());
              SNode expressionRoot = parser.findRootExpression(newNode);
              parser.rebalanceIfRequired(expressionRoot);
              caretPosition.restore();

              return null;
            }
            @Override
            public SNode getOutputConcept() {
              return SNodeOperations.asNode(subconcept);
            }
          });
        }
      }
    }




    return ListSequence.fromList(result).where(new IWhereFilter<SubstituteAction>() {
      public boolean accept(SubstituteAction it) {
        return it != null;
      }
    }).toListSequence();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);

    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BinaryExpression$j$, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.left$zxUa));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return SConceptOperations.conceptAlias(subconcept);
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.right$zBjx));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.BinaryExpression$j$;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public boolean isLeftAssociative() {
            return (boolean) BinaryExpression__BehaviorDescriptor.isLeftAssociative_id4rZeNQ6MpZM.invoke(SNodeOperations.asSConcept(subconcept));
          }
          @Override
          public int getPriority() {
            return (int) BinaryExpression__BehaviorDescriptor.priority_id4rZeNQ6MpZB.invoke(SNodeOperations.asSConcept(subconcept));
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.LogicalNotExpression$QD, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("!"));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$Hji0));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.LogicalNotExpression$QD;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public int getPriority() {
            return (int) UnaryExpression__BehaviorDescriptor.priority_id4rZeNQ6Nh_5.invoke(SNodeOperations.asSConcept(subconcept));
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.UnaryMinusExpression$Gz, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return SConceptOperations.conceptAlias(subconcept);
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$Hji0));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.UnaryMinusExpression$Gz;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public boolean isLeftAssociative() {
            return (boolean) UnaryExpression__BehaviorDescriptor.isLeftAssociative_id4rZeNQ6Nh_9.invoke(SNodeOperations.asSConcept(subconcept));
          }
          @Override
          public int getPriority() {
            return (int) UnaryExpression__BehaviorDescriptor.priority_id4rZeNQ6Nh_5.invoke(SNodeOperations.asSConcept(subconcept));
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ParensExpression$Tv, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("("));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$m8gJ));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(")"));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.ParensExpression$Tv;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.DotExpression$jp, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$Hji0));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return ".";
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.target$u23F));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.DotExpression$jp;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public int getPriority() {
            return (int) UnaryExpression__BehaviorDescriptor.priority_id4rZeNQ6Nh_5.invoke(SNodeOperations.asSConcept(subconcept));
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ColonCast$8S, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$A2T_));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol(new Object() {
              public String query(SAbstractConcept subconcept) {
                return SConceptOperations.conceptAlias(subconcept);
              }
            }.query(subconcept)));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.type$A3AC));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.ColonCast$8S;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public boolean isLeftAssociative() {
            return true;
          }
          @Override
          public int getPriority() {
            return 5000;
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.BangOp$rF, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.expr$Hji0));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("!"));
            symbols = ListSequence.fromList(symbols).where(new IWhereFilter<ISymbol>() {
              public boolean accept(ISymbol it) {
                return it != null;
              }
            }).toListSequence();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.BangOp$rF;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public int getPriority() {
            return (int) UnaryExpression__BehaviorDescriptor.priority_id4rZeNQ6Nh_5.invoke(SNodeOperations.asSConcept(subconcept));
          }
        });
      }
    }

    return rules;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
    /*package*/ static final SConcept BinaryExpression$j$ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, "org.iets3.core.expr.base.structure.BinaryExpression");
    /*package*/ static final SConcept LogicalNotExpression$QD = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cd0f6aL, "org.iets3.core.expr.base.structure.LogicalNotExpression");
    /*package*/ static final SConcept UnaryMinusExpression$Gz = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cdddbbL, "org.iets3.core.expr.base.structure.UnaryMinusExpression");
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
    /*package*/ static final SConcept ErrorLiteral$cb = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x1aa3923148a7eed6L, "org.iets3.core.expr.base.structure.ErrorLiteral");
    /*package*/ static final SConcept PlainConstraint$Xf = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff2422571594L, "org.iets3.core.expr.base.structure.PlainConstraint");
    /*package*/ static final SConcept TupleAccessExpr$UY = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x23141f44f4c5014aL, "org.iets3.core.expr.base.structure.TupleAccessExpr");
    /*package*/ static final SConcept AltOption$OS = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6ea1ae96e110d65bL, "org.iets3.core.expr.base.structure.AltOption");
    /*package*/ static final SConcept ColonCast$8S = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x52a5783d23e687ffL, "org.iets3.core.expr.base.structure.ColonCast");
    /*package*/ static final SConcept BangOp$rF = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x212b38c1011c3e9cL, "org.iets3.core.expr.base.structure.BangOp");
    /*package*/ static final SConcept ConvenientBooleanValue$ku = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7511add9ed5f6d3dL, "org.iets3.core.expr.base.structure.ConvenientBooleanValue");
    /*package*/ static final SConcept ConvenientBoolean$jZ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7511add9ed5f6d3cL, "org.iets3.core.expr.base.structure.ConvenientBoolean");
    /*package*/ static final SConcept ArbitraryTextAnnotation$hv = MetaAdapterFactory.getConcept(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, "com.mbeddr.mpsutil.grammarcells.runtimelang.structure.ArbitraryTextAnnotation");
    /*package*/ static final SConcept ParensExpression$Tv = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86d2f11fL, "org.iets3.core.expr.base.structure.ParensExpression");
    /*package*/ static final SInterfaceConcept INeverAllowDot$J1 = MetaAdapterFactory.getInterfaceConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x72b77efdaa227a88L, "org.iets3.core.expr.base.structure.INeverAllowDot");
    /*package*/ static final SConcept TupleType$8E = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xe247742183174baL, "org.iets3.core.expr.base.structure.TupleType");
    /*package*/ static final SConcept OptionType$eU = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x26f4f2a81ca93310L, "org.iets3.core.expr.base.structure.OptionType");
    /*package*/ static final SConcept IfExpression$6$ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6cef3d81a56f626aL, "org.iets3.core.expr.base.structure.IfExpression");
    /*package*/ static final SConcept IfElseSection$B4 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x86c00f011503ffdL, "org.iets3.core.expr.base.structure.IfElseSection");
    /*package*/ static final SConcept IsSomeExpression$Ae = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x26f4f2a81cac5800L, "org.iets3.core.expr.base.structure.IsSomeExpression");
    /*package*/ static final SConcept OptionalNameSpecifier$3X = MetaAdapterFactory.getConcept(0x7b68d745a7b848b9L, 0xbd9c05c0f8725a35L, 0x32f64a31a10020aL, "org.iets3.core.base.structure.OptionalNameSpecifier");
    /*package*/ static final SConcept NoneLiteral$$J = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x26f4f2a81cae2cf5L, "org.iets3.core.expr.base.structure.NoneLiteral");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept AttemptType$h8 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e777a2efL, "org.iets3.core.expr.base.structure.AttemptType");
    /*package*/ static final SConcept ErrorExpression$aj = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x1aa3923148b5e1f0L, "org.iets3.core.expr.base.structure.ErrorExpression");
    /*package*/ static final SConcept TryExpression$s4 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e77fb428L, "org.iets3.core.expr.base.structure.TryExpression");
    /*package*/ static final SConcept TrySuccessClause$Yi = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e78581bfL, "org.iets3.core.expr.base.structure.TrySuccessClause");
    /*package*/ static final SConcept TryErrorClause$MY = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x62632b96c1ec83cbL, "org.iets3.core.expr.base.structure.TryErrorClause");
    /*package*/ static final SConcept Invariant$I1 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e5edL, "org.iets3.core.expr.base.structure.Invariant");
    /*package*/ static final SConcept Postcondition$Hy = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e5ecL, "org.iets3.core.expr.base.structure.Postcondition");
    /*package*/ static final SConcept Precondition$kn = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e55dL, "org.iets3.core.expr.base.structure.Precondition");
    /*package*/ static final SConcept CheckTypeConstraintsExpr$w9 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7211e500635b4b0bL, "org.iets3.core.expr.base.structure.CheckTypeConstraintsExpr");
    /*package*/ static final SConcept FailExpr$SB = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x5b6b0ca1fd5e3baL, "org.iets3.core.expr.base.structure.FailExpr");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink left$zxUa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c16L, "left");
    /*package*/ static final SContainmentLink right$zBjx = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c18L, "right");
    /*package*/ static final SContainmentLink expr$Hji0 = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cd0f69L, 0x46ff3b3d86cd0f6bL, "expr");
    /*package*/ static final SContainmentLink expr$Wyjb = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e55cL, 0xc0aff242212e55eL, "expr");
    /*package*/ static final SContainmentLink tuple$Aujp = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x23141f44f4c5014aL, 0x23141f44f4c50165L, "tuple");
    /*package*/ static final SContainmentLink when$ywD6 = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6ea1ae96e110d65bL, 0x6ea1ae96e110d66eL, "when");
    /*package*/ static final SContainmentLink expr$A2T_ = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x52a5783d23e687ffL, 0x52a5783d23e68806L, "expr");
    /*package*/ static final SContainmentLink value$4I7H = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7511add9ed5f6d3cL, 0x7511add9ed6e7a2cL, "value");
    /*package*/ static final SContainmentLink thenPart$bVSc = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6cef3d81a56f626aL, 0x6cef3d81a56f626dL, "thenPart");
    /*package*/ static final SContainmentLink condition$bVqa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6cef3d81a56f626aL, 0x6cef3d81a56f626bL, "condition");
    /*package*/ static final SContainmentLink elseSection$kbJ$ = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x6cef3d81a56f626aL, 0x86c00f011503ff8L, "elseSection");
    /*package*/ static final SContainmentLink expr$abfa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x26f4f2a81cac5800L, 0x26f4f2a81cac5801L, "expr");
    /*package*/ static final SContainmentLink optionalName$AhFr = MetaAdapterFactory.getContainmentLink(0x7b68d745a7b848b9L, 0xbd9c05c0f8725a35L, 0x32f64a31a100207L, 0x32f64a31a1004e8L, "optionalName");
    /*package*/ static final SContainmentLink optionalBaseType$UUMR = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x26f4f2a81cae2cf5L, 0x73f429a451eead54L, "optionalBaseType");
    /*package*/ static final SContainmentLink successType$Xfwb = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e777a2efL, 0x10bcdcc088f63193L, "successType");
    /*package*/ static final SContainmentLink errorLiterals$XkTy = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e777a2efL, 0x10bcdcc088f63195L, "errorLiterals");
    /*package*/ static final SContainmentLink error$dXhE = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x1aa3923148b5e1f0L, 0x1aa3923148b5e1f1L, "error");
    /*package*/ static final SContainmentLink expr$TQmf = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e77fb428L, 0x59f3fec4e77fb444L, "expr");
    /*package*/ static final SContainmentLink successClause$ZBbX = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e77fb428L, 0x59f3fec4e785820eL, "successClause");
    /*package*/ static final SContainmentLink errorClauses$g1xK = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e77fb428L, 0x62632b96c1ec86c3L, "errorClauses");
    /*package*/ static final SContainmentLink errorLiteral$QRaD = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x62632b96c1ec83cbL, 0x62632b96c1fc6083L, "errorLiteral");
    /*package*/ static final SContainmentLink expr$SCnF = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x62632b96c1ec83cbL, 0x62632b96c1ec83eeL, "expr");
    /*package*/ static final SContainmentLink err$phDR = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e55cL, 0x5ac87922c845c4eaL, "err");
    /*package*/ static final SContainmentLink tp$hCEG = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7211e500635b4b0bL, 0x7211e500635b4b0eL, "tp");
    /*package*/ static final SContainmentLink expr$hCcE = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7211e500635b4b0bL, 0x7211e500635b4b0cL, "expr");
    /*package*/ static final SContainmentLink type$AJf9 = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x5b6b0ca1fd5e3baL, 0x64f912ca604267f5L, "type");
    /*package*/ static final SContainmentLink message$kl8H = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x5b6b0ca1fd5e3baL, 0x5b6b0ca1fd5e3beL, "message");
    /*package*/ static final SContainmentLink contextExpression$k8BH = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x5b6b0ca1fd5e3baL, 0x4a147296d583d621L, "contextExpression");
    /*package*/ static final SContainmentLink type$A3AC = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x52a5783d23e687ffL, 0x52a5783d23e68809L, "type");
    /*package*/ static final SContainmentLink expr$m8gJ = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86d2f11fL, 0x46ff3b3d86d2f172L, "expr");
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty text$Fl1W = MetaAdapterFactory.getProperty(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, 0x468dcccb641e99b6L, "text");
    /*package*/ static final SProperty left$Cu1K = MetaAdapterFactory.getProperty(0xb4f35ed845af4efaL, 0xabe400ac26956e69L, 0x468dcccb641e8fb9L, 0x468dcccb641e9989L, "left");
    /*package*/ static final SProperty complete$PYwr = MetaAdapterFactory.getProperty(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x59f3fec4e77fb428L, 0x52ad51a0a003e90eL, "complete");
    /*package*/ static final SProperty warning$kIYM = MetaAdapterFactory.getProperty(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0xc0aff242212e55cL, 0x385d460090bdc1c4L, "warning");
    /*package*/ static final SProperty failIfInvalid$GYZJ = MetaAdapterFactory.getProperty(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7211e500635b4b0bL, 0x5d23e1084df12bb4L, "failIfInvalid");
  }
}
