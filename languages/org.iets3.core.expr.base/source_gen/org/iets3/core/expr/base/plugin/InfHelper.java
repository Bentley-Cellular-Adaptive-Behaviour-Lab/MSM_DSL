package org.iets3.core.expr.base.plugin;

/*Generated by MPS */

import java.math.RoundingMode;
import java.math.BigDecimal;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.util.Objects;

public class InfHelper {
  public static final String NEGINF = "-∞";
  public static final String POSINF = "∞";

  /**
   * Default infinite precision corresponds to the decimal digits number of the double-precision
   */
  public static final int INF_PREC = 16;
  /**
   * Default rounding mode applied when converting decimals with infinite/undefined precision to decimals with INF_PREC
   */
  public static final RoundingMode DEFAULT_ROUNDING = RoundingMode.HALF_UP;


  public static String negate(String value) {
    if (value.equals(NEGINF)) {
      return POSINF;
    }
    if (value.equals(POSINF)) {
      return NEGINF;
    }
    if (value.startsWith("-")) {
      return value.substring(1);
    } else {
      return "-" + value;
    }
  }

  public static String add(String v1, String v2, boolean skewLow) {
    if (v1.equals(POSINF) || v2.equals(POSINF)) {
      return POSINF;
    }
    if (v1.equals(NEGINF) || v2.equals(NEGINF)) {
      return NEGINF;
    }
    return new BigDecimal(v1).add(new BigDecimal(v2)).toPlainString();
  }

  public static String sub(String v1, String v2, boolean skewLow) {
    if (v1.equals(POSINF) || v2.equals(NEGINF)) {
      return POSINF;
    }
    if (v1.equals(NEGINF) || v2.equals(POSINF)) {
      return NEGINF;
    }
    return new BigDecimal(v1).subtract(new BigDecimal(v2)).toPlainString();
  }

  public static String mul(String v1, String v2, boolean skewLow) {
    if (v1.equals(POSINF)) {
      if (signum(v2) >= 0) {
        return POSINF;
      } else {
        return NEGINF;
      }
    }
    if (v1.equals(NEGINF)) {
      if (signum(v2) >= 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    if (v2.equals(POSINF)) {
      if (signum(v1) >= 0) {
        return POSINF;
      } else {
        return NEGINF;
      }
    }
    if (v2.equals(NEGINF)) {
      if (signum(v1) >= 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    return new BigDecimal(v1).multiply(new BigDecimal(v2)).toPlainString();
  }


  public static int signum(String v) {
    if (v.equals(POSINF)) {
      return 1;
    }
    if (v.equals(NEGINF)) {
      return -1;
    }
    BigDecimal bd = new BigDecimal(v);
    return bd.signum();
  }

  public static String div(String v1, String v2, boolean skewLow, RoundingMode roundingMode) {
    if (v1.equals(POSINF) || v2.equals(POSINF)) {
      return POSINF;
    }
    if (v1.equals(NEGINF) || v2.equals(NEGINF)) {
      return NEGINF;
    }
    BigDecimal v2dec = new BigDecimal(v2);
    if (v2dec.compareTo(BigDecimal.ZERO) == 0) {
      if (signum(v1) + signum(v2) < 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    return new BigDecimal(v1).divide(v2dec, INF_PREC, roundingMode).toPlainString();
  }



  public static boolean less(String l, String r) {
    if (l == null) {
      return true;
    }
    if (l.equals(NEGINF) && r.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF) && r.equals(POSINF)) {
      return true;
    }
    if (l.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF)) {
      return false;
    }
    if (r.equals(POSINF)) {
      return true;
    }
    if (r.equals(NEGINF)) {
      return false;
    }
    try {
      return new BigDecimal(l).compareTo(new BigDecimal(r)) < 0;
    } catch (NumberFormatException ex) {
      return false;
    }
  }

  public static boolean lessOrEq(String l, String r) {
    if (l == null) {
      return true;
    }
    if (r == null) {
      return false;
    }
    if (l.equals(NEGINF) && r.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF) && r.equals(POSINF)) {
      return true;
    }
    if (l.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF)) {
      return false;
    }
    if (r.equals(POSINF)) {
      return true;
    }
    if (r.equals(NEGINF)) {
      return false;
    }
    try {
      return new BigDecimal(l).compareTo(new BigDecimal(r)) <= 0;
    } catch (NumberFormatException ex) {
      return false;
    }
  }

  public static boolean greater(String l, String r) {
    if (r == null) {
      return true;
    }
    if (l.equals(NEGINF) && r.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF) && r.equals(POSINF)) {
      return true;
    }
    if (r.equals(POSINF)) {
      return false;
    }
    if (l.equals(NEGINF)) {
      return false;
    }
    if (l.equals(POSINF)) {
      return true;
    }
    if (r.equals(NEGINF)) {
      return true;
    }
    try {
      return new BigDecimal(l).compareTo(new BigDecimal(r)) > 0;
    } catch (NumberFormatException ex) {
      return false;
    }
  }

  public static boolean greaterOrEqual(String l, String r) {
    if (r == null) {
      return true;
    }
    if (l.equals(NEGINF) && r.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF) && r.equals(POSINF)) {
      return true;
    }
    if (r.equals(POSINF)) {
      return false;
    }
    if (l.equals(NEGINF)) {
      return false;
    }
    if (l.equals(POSINF)) {
      return true;
    }
    if (r.equals(NEGINF)) {
      return true;
    }
    try {
      return new BigDecimal(l).compareTo(new BigDecimal(r)) >= 0;
    } catch (NumberFormatException ex) {
      return false;
    }
  }

  public static boolean equals(String l, String r) {
    if (r == null) {
      return false;
    }
    if (l == null) {
      return false;
    }
    if (l.equals(NEGINF) && r.equals(NEGINF)) {
      return true;
    }
    if (l.equals(POSINF) && r.equals(POSINF)) {
      return true;
    }
    return l.equals(r);
  }

  public static String min(String l, String r) {
    if (l.equals(NEGINF) || r.equals(NEGINF)) {
      return NEGINF;
    }
    if (l.equals(POSINF)) {
      return r;
    }
    if (r.equals(POSINF)) {
      return l;
    }
    try {
      return new BigDecimal(l).min(new BigDecimal(r)).toPlainString();
    } catch (NumberFormatException ignore) {
      ignore.printStackTrace();
      return null;
    }
  }

  public static String min(Iterable<String> values) {
    return Sequence.fromIterable(values).foldLeft(POSINF, new ILeftCombinator<String, String>() {
      public String combine(String min, String next) {
        return (less(next, min) ? next : min);
      }
    });
  }

  public static String max(Iterable<String> values) {
    return Sequence.fromIterable(values).foldLeft(NEGINF, new ILeftCombinator<String, String>() {
      public String combine(String min, String next) {
        return (greater(next, min) ? next : min);
      }
    });
  }

  public static int maxInt(Iterable<Integer> values) {
    return Sequence.fromIterable(values).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
      public Integer combine(Integer max, Integer next) {
        return (next > max ? next : max);
      }
    });
  }

  public static String max(String l, String r) {
    if (l.equals(POSINF) || r.equals(POSINF)) {
      return POSINF;
    }
    try {
      return new BigDecimal(l).max(new BigDecimal(r)).toPlainString();
    } catch (NumberFormatException ignore) {
      ignore.printStackTrace();
      return null;
    }
  }

  public static boolean isZero(String s) {
    return s.equals("0");
  }

  public static int asInt_OrZero(String s) {
    try {
      return Integer.valueOf(s).intValue();
    } catch (NumberFormatException nfe) {
      return 0;
    }
  }

  public static boolean isPosInf(String s) {
    return Objects.equals(s, POSINF);
  }

  public static boolean isNegInf(String s) {
    return Objects.equals(s, NEGINF);
  }

}
