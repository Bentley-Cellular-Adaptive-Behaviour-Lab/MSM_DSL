package org.iets3.core.expr.base.editor;

/*Generated by MPS */

import java.awt.Color;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.core.expr.base.behavior.DefaultCoverageAnalyzer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.interpreter.behavior.ICanHaveTestCoverage__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class CoverageEditorUtils {

  public static Color NOT_COVERED_BG_COLOR = new Color(255, 220, 220);
  public static Color COVERED_AND_NOT_INCLUDED_BG_COLOR = new Color(220, 220, 255);

  public static boolean isCoveredAndNotIncluded(SNode node) {
    if (DefaultCoverageAnalyzer.isNodeCovered(node)) {
      SNode coverageWithScopeAncestor = SNodeOperations.getNodeAncestor(node, CONCEPTS.ICanHaveTestCoverage$33, false, false);
      if ((coverageWithScopeAncestor != null)) {
        int indexOfCoverageWithScopeAncestor = ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).indexOf(coverageWithScopeAncestor);
        final Iterable<SNode> includedForCoverage = ICanHaveTestCoverage__BehaviorDescriptor.getChildrenForCoverage_id5IKJrJHNCE8.invoke(coverageWithScopeAncestor);
        // at least one ancestor is not included to the explicit coverage scope 
        boolean isNotIncludedInCoverage = ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).headListSequence(indexOfCoverageWithScopeAncestor).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(Sequence.fromIterable(includedForCoverage).contains(it));
          }
        });
        if (isNotIncludedInCoverage) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean isNotCoveredAndHasNotCoveredAncestors(SNode node) {
    return DefaultCoverageAnalyzer.isNodeNotCovered(node) && ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return DefaultCoverageAnalyzer.isNodeNotCovered(it);
      }
    });
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHaveTestCoverage$33 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbedce7ccbL, "com.mbeddr.mpsutil.interpreter.structure.ICanHaveTestCoverage");
  }
}
