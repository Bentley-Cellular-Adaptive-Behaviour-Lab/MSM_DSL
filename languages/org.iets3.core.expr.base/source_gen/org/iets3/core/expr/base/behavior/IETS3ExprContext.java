package org.iets3.core.expr.base.behavior;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.ContextImpl;
import com.mbeddr.mpsutil.interpreter.rt.LanguageConfig;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mbeddr.mpsutil.traceExplorer.plugin.ITraceRecord;

public class IETS3ExprContext extends ContextImpl {

  private LanguageConfig cfg = new LanguageConfig(false);
  private boolean enableCaching = true;

  public static class CacheEntry {
    private SNodeReference nodeID;
    private List<Object> myArgs;
    public CacheEntry(SNode node, List<Object> args) {
      nodeID = SNodeOperations.getPointer(node);
      myArgs = args;
    }
    @Override
    public int hashCode() {
      if (myArgs != null) {
        return Objects.hash(this.nodeID, myArgs);
      }
      return this.nodeID.hashCode();
    }
    @Override
    public boolean equals(Object object) {
      if (object == null) {
        return false;
      }
      if (!(object instanceof CacheEntry)) {
        return false;
      }
      CacheEntry otherCe = ((CacheEntry) object);
      if (!(Objects.equals(this.nodeID, otherCe.nodeID))) {
        return false;
      }
      if (this.myArgs == null) {
        return otherCe.myArgs == null;
      }
      if (ListSequence.fromList(this.myArgs).count() != ListSequence.fromList(otherCe.myArgs).count()) {
        return false;
      }
      for (int i = 0; i < ListSequence.fromList(this.myArgs).count(); i++) {
        if (!(ListSequence.fromList(this.myArgs).getElement(i).equals(ListSequence.fromList(otherCe.myArgs).getElement(i)))) {
          return false;
        }
      }
      return true;
    }
  }

  private Map<CacheEntry, Object> cache = MapSequence.fromMap(new HashMap<CacheEntry, Object>());
  private Map<CacheEntry, ITraceRecord> traceCache = MapSequence.fromMap(new HashMap<CacheEntry, ITraceRecord>());

  public Object getCachedValue(CacheEntry ce) {
    return MapSequence.fromMap(cache).get(ce);
  }

  public ITraceRecord getCachedTrace(CacheEntry ce) {
    return MapSequence.fromMap(traceCache).get(ce);
  }

  public void addToCache(CacheEntry ce, Object value) {
    MapSequence.fromMap(cache).put(ce, value);
  }

  public void addToCache(CacheEntry ce, Object value, ITraceRecord trace) {
    MapSequence.fromMap(cache).put(ce, value);
    MapSequence.fromMap(traceCache).put(ce, trace);
  }

  public boolean isCachingEnabled() {
    return this.enableCaching;
  }

  public void disableCaching() {
    this.enableCaching = false;
    MapSequence.fromMap(this.cache).clear();
  }



  public void setConfiguration(LanguageConfig config) {
    cfg = config;
  }

  @Override
  public LanguageConfig getConfiguration() {
    return cfg;
  }

}
