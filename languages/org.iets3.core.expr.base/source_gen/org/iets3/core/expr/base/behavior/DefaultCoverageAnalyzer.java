package org.iets3.core.expr.base.behavior;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import java.awt.Color;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.interpreter.behavior.ICanHaveTestCoverage__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import com.mbeddr.mpsutil.interpreter.rt.IEvaluator;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class DefaultCoverageAnalyzer implements ICoverageAnalyzer {

  public static final String COVERED = "Covered.";
  public static final String MISSING = "Missing.";
  public static final String PARTIAL = "Partial.";
  public static final String IGNORED = "Ignored.";

  public static final Color COVERED_COLOR = new Color(23, 191, 0);
  public static final Color MISSING_COLOR = Color.red;
  public static final Color PARTIAL_COLOR = new Color(237, 134, 0);
  public static final Color IGNORED_COLOR = new Color(237, 134, 0);

  public static final Color CODE_COVERED_COLOR = Color.decode("#C4FFE2");
  public static final Color CODE_MISSING_COLOR = Color.decode("#FFE3E7");
  public static final Color CODE_PARTIAL_COLOR = Color.decode("#FEFFD4");
  public static final Color CODE_IGNORE = Color.decode("#E4FFDB");

  public static class ConceptData {

    private Set<String> branches;
    private Set<String> visitedBranches;
    private boolean visitedAtAll = false;
    private SAbstractConcept concept;

    public ConceptData(SAbstractConcept ccc) {
      concept = ccc;
    }

    public void registerBranches(String[] branches) {
      if (this.branches == null) {
        this.branches = SetSequence.fromSet(new HashSet<String>());
        this.visitedBranches = SetSequence.fromSet(new HashSet<String>());
      }
      SetSequence.fromSet(this.branches).addSequence(Sequence.fromIterable(Sequence.fromArray(branches)));
    }

    public SAbstractConcept concept() {
      return this.concept;
    }

    public void visitBranch(String branchID) {
      SetSequence.fromSet(this.visitedBranches).addElement(branchID);
      this.visitedAtAll = true;
    }

    public boolean isComplete() {
      if (this.branches == null) {
        return visitedAtAll;
      }
      return SetSequence.fromSet(this.branches).all(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return SetSequence.fromSet(ConceptData.this.visitedBranches).contains(it);
        }
      });
    }

    public String status() {
      if (this.branches == null) {
        return (visitedAtAll ? COVERED : MISSING);
      }
      if (Sequence.fromIterable(unvisitedBranches()).isEmpty()) {
        return COVERED;
      }
      return PARTIAL + " Missing: " + unvisitedBranches();
    }

    public Color color() {
      if (this.branches == null) {
        return (visitedAtAll ? COVERED_COLOR : MISSING_COLOR);
      }
      return PARTIAL_COLOR;
    }

    public void visited() {
      visitedAtAll = true;
    }

    public Iterable<String> unvisitedBranches() {
      return SetSequence.fromSet(this.branches).where(new IWhereFilter<String>() {
        public boolean accept(String it) {
          return !(SetSequence.fromSet(ConceptData.this.visitedBranches).contains(it));
        }
      });
    }

    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer();
      sb.append(this.concept.getName());
      if (!(this.visitedAtAll)) {
        sb.append(" not visited.");
      } else if (!(this.isComplete())) {
        sb.append(" missing " + unvisitedBranches());
      }
      return sb.toString();
    }


  }

  public static class ValueCoverage {
    private String name;
    private Object value;
    private _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> decisionToStore;
    private _FunctionTypes._return_P1_E0<? extends Object, ? super Object> valueConverter;

    public ValueCoverage(String n, _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> predicate) {
      name = n;
      decisionToStore = predicate;
    }

    public ValueCoverage(String n, _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> pred, _FunctionTypes._return_P1_E0<? extends Object, ? super Object> vc) {
      name = n;
      decisionToStore = pred;
      valueConverter = vc;
    }

    public boolean storeValueInsteadOfOldOne(Object newValue, Object oldValue) {
      return decisionToStore.invoke(newValue, oldValue);
    }

    public Object valueToBeStored(Object newValue) {
      if (valueConverter != null) {
        return valueConverter.invoke(newValue);
      }
      return newValue;
    }

    public void registerValue(Object newValue) {
      if (value == null) {
        value = valueToBeStored(newValue);
      } else {
        if (storeValueInsteadOfOldOne(newValue, value)) {
          value = valueToBeStored(newValue);
        }
      }
    }

    public Tuples._2<String, Object> result() {
      return MultiTuple.<String,Object>from(this.name, this.value);
    }

    @Override
    public String toString() {
      Tuples._2<String, Object> r = result();
      return r._0() + ": " + r._1();
    }

  }

  public static class ValueStatistics {

    private Map<Object, ValueCoverage> values = MapSequence.fromMap(new HashMap<Object, ValueCoverage>());

    public void newValue(String key, Object newValue) {
      ValueCoverage s = MapSequence.fromMap(values).get(key);
      if (s != null) {
        s.registerValue(newValue);
      }
    }

    public void registerAnalyzer(ValueCoverage analyzer) {
      MapSequence.fromMap(values).put(analyzer.name, analyzer);
    }

    public Iterable<ValueCoverage> getData() {
      return MapSequence.fromMap(this.values).values();
    }

    public boolean isEmpty() {
      return MapSequence.fromMap(this.values).isEmpty();
    }

  }

  public static class NodeCoverage {

    private SNode node;
    private String status;

    public NodeCoverage(SNode node) {
      this.node = node;
    }

    public NodeCoverage(SNode node, String status) {
      this.node = node;
      this.status = status;
    }

    private int totalVisitable() {
      Iterable<SNode> childrenForCoverage = getChildrenForCoverage();
      return Sequence.fromIterable(childrenForCoverage).select(new ISelector<SNode, Integer>() {
        public Integer select(SNode it) {
          NodeCoverage childCoverage = DefaultCoverageAnalyzer.getNodeCoverage(it);
          return childCoverage.totalVisitable() + 1;
        }
      }).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
        public Integer combine(Integer total, Integer it) {
          return total + it;
        }
      });
    }

    public int getCoverageRatio() {
      if (isEmptyString(this.status) || this.status.startsWith(MISSING)) {
        return 0;
      } else if (this.status.startsWith(COVERED)) {
        return 100;
      } else {
        int total = totalVisitable();
        int visited = ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isNodeCovered(it) || isNodePartiallyCovered(it);
          }
        }).count();
        return (int) Math.floor((100.0 * visited) / total);
      }
    }

    private Iterable<SNode> getChildrenForCoverage() {
      Iterable<SNode> childrenForCoverage;
      if (SNodeOperations.isInstanceOf(node, CONCEPTS.ICanHaveTestCoverage$33)) {
        childrenForCoverage = ICanHaveTestCoverage__BehaviorDescriptor.getChildrenForCoverage_id5IKJrJHNCE8.invoke(SNodeOperations.cast(node, CONCEPTS.ICanHaveTestCoverage$33));
      } else {
        childrenForCoverage = SNodeOperations.getChildren(node);
      }
      return Sequence.fromIterable(childrenForCoverage).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SNodeOperations.isInstanceOf(it, CONCEPTS.IEmpty$6_)) && !(SNodeOperations.isInstanceOf(it, CONCEPTS.IExcludeFromCoverage$z4));
        }
      });
    }

    private void updateResultStatus() {
      this.status = COVERED;
      Sequence.fromIterable(getChildrenForCoverage()).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          NodeCoverage childCoverage = DefaultCoverageAnalyzer.getNodeCoverage(it);
          if (!(Objects.equals(childCoverage.getStatus(), COVERED))) {
            NodeCoverage.this.status = PARTIAL;
          }
        }
      });
    }

    public String getStatus() {
      return this.status;
    }

    public SNode getNode() {
      return this.node;
    }

    private static boolean isEmptyString(String str) {
      return str == null || str.isEmpty();
    }
  }


  private Set<String> visitedEvaluators = SetSequence.fromSet(new HashSet<String>());
  private Map<SAbstractConcept, ConceptData> visitedConcepts = MapSequence.fromMap(new HashMap<SAbstractConcept, ConceptData>());
  private Set<SLanguage> registeredLanguages = SetSequence.fromSet(new HashSet<SLanguage>());
  private Set<SAbstractConcept> ignoredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private Set<SAbstractConcept> measuredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private Map<SNode, NodeCoverage> visitedNodes = MapSequence.fromMap(new HashMap<SNode, NodeCoverage>());
  private ValueStatistics statistics = new ValueStatistics();
  private Map<SNode, List<Object>> values = MapSequence.fromMap(new HashMap<SNode, List<Object>>());

  @NotNull
  private static DefaultCoverageAnalyzer INSTANCE = new DefaultCoverageAnalyzer();


  public DefaultCoverageAnalyzer() {
  }

  @Override
  public void visitedConcept(SAbstractConcept ccc) {
    getConceptData(ccc).visited();
  }

  private ConceptData getConceptData(SAbstractConcept ccc) {
    ConceptData data = MapSequence.fromMap(visitedConcepts).get(ccc);
    if (data == null) {
      data = new ConceptData(ccc);
      MapSequence.fromMap(visitedConcepts).put(ccc, data);
    }
    return data;
  }

  @Override
  public void visitedConceptBranch(SAbstractConcept ccc, String branchID) {
    ConceptData data = getConceptData(ccc);
    data.visitBranch(branchID);
  }

  @Override
  public void visitedEvaluator(IEvaluator evaluator) {
    SetSequence.fromSet(visitedEvaluators).addElement(evaluator.getInfo().conceptName);
  }

  @Override
  public void registerBranches(SAbstractConcept ccc, String[] branchIDs) {
    getConceptData(ccc).registerBranches(branchIDs);
  }

  public static int ratio() {
    return 100 - ((int) (((float) Sequence.fromIterable(missingConceptsOrIncomplete()).count()) / ((float) Sequence.fromIterable(allConceptsStatus()).count()) * 100));
  }

  public static void reset() {
    INSTANCE = new DefaultCoverageAnalyzer();
    INSTANCE.setupValueStatistics();
  }

  @NotNull
  public static DefaultCoverageAnalyzer getInstance() {
    return INSTANCE;
  }

  private void setupValueStatistics() {
    statistics.registerAnalyzer(new ValueCoverage("integer.min", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object oldVal, Object newVal) {
        return ((BigInteger) oldVal).compareTo(((BigInteger) newVal)) < 0;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("integer.max", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigInteger) newVal).compareTo(((BigInteger) oldVal)) > 0;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("integer.zero", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigInteger) newVal).compareTo(BigInteger.ZERO) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("integer.one", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigInteger) newVal).compareTo(BigInteger.ONE) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("integer.minusOne", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigInteger) newVal).compareTo(new BigInteger("-1")) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));

    statistics.registerAnalyzer(new ValueCoverage("decimal.min", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigDecimal) newVal).compareTo(((BigDecimal) oldVal)) < 0;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("decimal.max", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigDecimal) newVal).compareTo(((BigDecimal) oldVal)) > 0;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("decimal.zero", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigDecimal) newVal).compareTo(BigDecimal.ZERO) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("decimal.one", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigDecimal) newVal).compareTo(BigDecimal.ONE) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));
    statistics.registerAnalyzer(new ValueCoverage("decimal.minusOne", new _FunctionTypes._return_P2_E0<Boolean, Object, Object>() {
      public Boolean invoke(Object newVal, Object oldVal) {
        return ((BigDecimal) newVal).compareTo(new BigDecimal("-1")) == 0;
      }
    }, new _FunctionTypes._return_P1_E0<Boolean, Object>() {
      public Boolean invoke(Object val) {
        return true;
      }
    }));
  }


  public static List<SAbstractConcept> allConcepts() {
    return getInstance().getAllConcepts();
  }
  public List<SAbstractConcept> getAllConcepts() {
    List<SAbstractConcept> res = ListSequence.fromList(new ArrayList<SAbstractConcept>());
    for (SLanguage l : SetSequence.fromSet(registeredLanguages)) {
      for (final SAbstractConcept c : Sequence.fromIterable(l.getConcepts())) {
        if (c.isAbstract()) {
          continue;
        }
        if (c instanceof SInterfaceConcept) {
          continue;
        }
        if (SetSequence.fromSet(ignoredConcepts).any(new IWhereFilter<SAbstractConcept>() {
          public boolean accept(SAbstractConcept it) {
            return c.isSubConceptOf(it);
          }
        })) {
          continue;
        }
        ListSequence.fromList(res).addElement(c);
      }
    }
    return res;
  }

  public static Iterable<ConceptData> missingConceptsOrIncomplete() {
    return Sequence.fromIterable(allConceptsStatus()).where(new IWhereFilter<ConceptData>() {
      public boolean accept(ConceptData it) {
        return !(it.isComplete());
      }
    });
  }
  public Iterable<ConceptData> getMissingConceptsOrIncomplete() {
    return Sequence.fromIterable(allConceptsStatus()).where(new IWhereFilter<ConceptData>() {
      public boolean accept(ConceptData it) {
        return !(it.isComplete());
      }
    });
  }

  public static Iterable<ConceptData> allConceptsStatus() {
    return getInstance().getAllConceptsStatus();
  }
  public Iterable<ConceptData> getAllConceptsStatus() {
    return ListSequence.fromList(allConcepts()).select(new ISelector<SAbstractConcept, ConceptData>() {
      public ConceptData select(SAbstractConcept it) {
        ConceptData ccc = MapSequence.fromMap(visitedConcepts).get(it);
        if (ccc == null) {
          return new ConceptData(it);
        }
        return ccc;
      }
    });
  }

  public static Set<SNode> allCoveredNodes() {
    return getInstance().getAllCoveredNodes();
  }

  public Set<SNode> getAllCoveredNodes() {
    return MapSequence.fromMap(visitedNodes).keySet();
  }

  public static boolean hasNodeCoverage(SNode node) {
    return getInstance().hasNodeCoverageEx(node);
  }
  public boolean hasNodeCoverageEx(SNode node) {
    return MapSequence.fromMap(visitedNodes).get(node) != null;
  }

  public static NodeCoverage getNodeCoverage(SNode node) {
    return getInstance().getNodeCoverageEx(node);
  }
  public NodeCoverage getNodeCoverageEx(SNode node) {
    NodeCoverage coverageData = MapSequence.fromMap(visitedNodes).get(node);
    if (coverageData == null) {
      // if any descendant has been visited, deep node coverage should be updated 
      if (ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, false, new SAbstractConcept[]{})).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return hasNodeCoverage(it);
        }
      })) {
        coverageData = new NodeCoverage(node);
        coverageData.updateResultStatus();
      } else {
        coverageData = new NodeCoverage(node, MISSING);
      }
      MapSequence.fromMap(visitedNodes).put(node, coverageData);
    }
    if (isEmptyString(coverageData.getStatus())) {
      coverageData.updateResultStatus();
    }
    return coverageData;
  }

  public static boolean isNodeCovered(SNode node) {
    return hasNodeCoverage(node) && getNodeCoverage(node).getStatus().startsWith(COVERED);
  }
  public boolean isNodeCoveredEx(SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(COVERED);
  }

  public static boolean isNodePartiallyCovered(SNode node) {
    return hasNodeCoverage(node) && getNodeCoverage(node).getStatus().startsWith(PARTIAL);
  }
  public boolean isNodePartiallyCoveredEx(SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(PARTIAL);
  }

  public static boolean isNodeNotCovered(SNode node) {
    return hasNodeCoverage(node) && getNodeCoverage(node).getStatus().startsWith(MISSING);
  }
  public boolean isNodeNotCoveredEx(SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(MISSING);
  }

  public static void visitNode(SNode node) {
    getInstance().visitNodeEx(node);
  }
  public void visitNodeEx(SNode node) {
    MapSequence.fromMap(visitedNodes).put(node, new NodeCoverage(node));
  }

  public static void registerLanguage(SLanguage l) {
    getInstance().registerLanguageEx(l);
  }
  public void registerLanguageEx(SLanguage l) {
    SetSequence.fromSet(registeredLanguages).addElement(l);
  }

  public static void registerIgnoredConcept(SAbstractConcept c) {
    getInstance().registerIgnoredConceptEx(c);
  }
  public void registerIgnoredConceptEx(SAbstractConcept c) {
    SetSequence.fromSet(ignoredConcepts).addElement(c);
  }

  public static void registerMeasuredConcept(SAbstractConcept c) {
    getInstance().registerMeasuredConceptEx(c);
  }
  public void registerMeasuredConceptEx(SAbstractConcept c) {
    SetSequence.fromSet(measuredConcepts).addElement(c);
  }

  public static boolean isInInterestingContext(SNode n) {
    return getInstance().isInInterestingContextEx(n);
  }
  public boolean isInInterestingContextEx(final SNode n) {
    if (getInstance().isInterestingConceptEx(n)) {
      return true;
    }
    return ListSequence.fromList(SNodeOperations.getNodeAncestors(n, null, false)).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return getInstance().isInterestingConceptEx(n);
      }
    });
  }

  public static boolean isInterestingConcept(SNode n) {
    return getInstance().isInterestingConceptEx(n);
  }
  public boolean isInterestingConceptEx(final SNode n) {
    SAbstractConcept c = SNodeOperations.getConcept(n);
    if (SetSequence.fromSet(measuredConcepts).contains(c)) {
      return true;
    }
    if (SetSequence.fromSet(measuredConcepts).any(new IWhereFilter<SAbstractConcept>() {
      public boolean accept(SAbstractConcept it) {
        return SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(n)), SNodeOperations.asSConcept(it));
      }
    })) {
      return true;
    }
    return false;
  }

  public static ValueStatistics getValueStatistics() {
    return getInstance().getValueStatisticsEx();
  }
  public ValueStatistics getValueStatisticsEx() {
    return statistics;
  }

  public static boolean isIgnored(SNode n) {
    return getInstance().isIgnoredEx(n);
  }
  public boolean isIgnoredEx(final SNode n) {
    return SetSequence.fromSet(ignoredConcepts).contains(SNodeOperations.getConcept(n)) || SetSequence.fromSet(ignoredConcepts).any(new IWhereFilter<SAbstractConcept>() {
      public boolean accept(SAbstractConcept it) {
        return SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(n)), SNodeOperations.asSConcept(it));
      }
    });
  }

  public static boolean hasData() {
    return getInstance().hasDataEx();
  }
  public boolean hasDataEx() {
    return statistics != null && !(statistics.isEmpty());
  }
  @Nullable
  public Object getValue(SNode n) {
    List<Object> nodeValues = MapSequence.fromMap(values).get(n);
    if (nodeValues != null && ListSequence.fromList(nodeValues).isNotEmpty()) {
      return ListSequence.fromList(nodeValues).last();
    }
    return null;
  }
  @Nullable
  public List<Object> getAllValues(@NotNull SNode n) {
    return MapSequence.fromMap(values).get(n);
  }


  @Override
  public void coverValue(SNode interpretedNode, Object evaluatedValue) {
    if (interpretedNode == null) {
      return;
    }
    if (evaluatedValue instanceof BigInteger) {
      statistics.newValue("integer.min", evaluatedValue);
      statistics.newValue("integer.minusOne", evaluatedValue);
      statistics.newValue("integer.zero", evaluatedValue);
      statistics.newValue("integer.one", evaluatedValue);
      statistics.newValue("integer.max", evaluatedValue);
    }
    if (evaluatedValue instanceof BigDecimal) {
      statistics.newValue("decimal.min", evaluatedValue);
      statistics.newValue("decimal.minusOne", evaluatedValue);
      statistics.newValue("decimal.zero", evaluatedValue);
      statistics.newValue("decimal.one", evaluatedValue);
      statistics.newValue("decimal.max", evaluatedValue);
    }

    List<Object> nodeValues = MapSequence.fromMap(values).get(interpretedNode);

    if (nodeValues == null) {
      nodeValues = ListSequence.fromList(new ArrayList<Object>());
      MapSequence.fromMap(values).put(interpretedNode, nodeValues);
    }

    ListSequence.fromList(nodeValues).addElement(evaluatedValue);

    visitNodeEx(interpretedNode);
    visitNode(interpretedNode);
    visitedConcept(SNodeOperations.getConcept(interpretedNode));
  }

  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHaveTestCoverage$33 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbedce7ccbL, "com.mbeddr.mpsutil.interpreter.structure.ICanHaveTestCoverage");
    /*package*/ static final SInterfaceConcept IExcludeFromCoverage$z4 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbee2b138eL, "com.mbeddr.mpsutil.interpreter.structure.IExcludeFromCoverage");
    /*package*/ static final SInterfaceConcept IEmpty$6_ = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0xe900768cf47dcc3L, "com.mbeddr.core.base.structure.IEmpty");
  }
}
