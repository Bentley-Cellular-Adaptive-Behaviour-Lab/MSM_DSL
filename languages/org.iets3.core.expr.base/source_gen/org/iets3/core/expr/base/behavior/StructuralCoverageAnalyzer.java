package org.iets3.core.expr.base.behavior;

/*Generated by MPS */

import java.awt.Color;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.language.SConcept;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.structure.behavior.LinkDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.PropertyDeclaration__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class StructuralCoverageAnalyzer {

  public static final String COVERED = "Covered.";
  public static final String MISSING = "Missing.";
  public static final String PARTIAL = "Partial.";

  public static final Color COVERED_COLOR = new Color(23, 191, 0);
  public static final Color MISSING_COLOR = Color.red;
  public static final Color PARTIAL_COLOR = new Color(237, 134, 0);


  public static class ExpressionStat {

    private SNode subject;

    public ExpressionStat(SNode subject) {
      this.subject = subject;
    }

    private SNode root() {
      return ListSequence.fromList(SNodeOperations.getNodeAncestors(subject, CONCEPTS.Expression$D_, true)).last();
    }

    public int size() {
      return ListSequence.fromList(SNodeOperations.getNodeDescendants(root(), null, true, new SAbstractConcept[]{})).count();
    }

    public int depth() {
      return ListSequence.fromList(SNodeOperations.getNodeAncestors(subject, CONCEPTS.Expression$D_, true)).count();
    }

    public int heterogeneity() {
      return ListSequence.fromList(SNodeOperations.getNodeDescendants(root(), null, true, new SAbstractConcept[]{})).select(new ISelector<SNode, SConcept>() {
        public SConcept select(SNode it) {
          return SNodeOperations.getConcept(it);
        }
      }).distinct().count();
    }

    public int metric() {
      return heterogeneity() * depth();
    }

    @Override
    public String toString() {
      return "metric: " + metric();
    }

  }

  public static class StructureData {

    private Set<SNode> visitedLinks = SetSequence.fromSet(new HashSet<SNode>());
    private Set<SNode> visitedProperties = SetSequence.fromSet(new HashSet<SNode>());
    private List<ExpressionStat> occurences = ListSequence.fromList(new ArrayList<ExpressionStat>());
    private SAbstractConcept concept;
    private List<SAbstractConcept> allRelevantConcepts;
    private boolean trackProperties;

    public StructureData(SAbstractConcept ccc, List<SAbstractConcept> allRelevantConcepts, boolean trackProperties) {
      concept = ccc;
      this.allRelevantConcepts = allRelevantConcepts;
      this.trackProperties = trackProperties;
    }

    public SAbstractConcept concept() {
      return this.concept;
    }

    public Iterable<SNode> allLinks() {
      return ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(SNodeOperations.asNode(this.concept))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return ListSequence.fromList(allRelevantConcepts).contains(SNodeOperations.asSConcept(LinkDeclaration__BehaviorDescriptor.getConceptDeclaration_id7jb4LXpbWaP.invoke(it)));
        }
      });
    }

    public Iterable<SNode> allProperties() {
      return ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getPropertyDeclarations_idhEwILLM.invoke(SNodeOperations.asNode(this.concept))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return ListSequence.fromList(allRelevantConcepts).contains(SNodeOperations.asSConcept(PropertyDeclaration__BehaviorDescriptor.getConceptDeclaration_id2OF3rgRewqT.invoke(it)));
        }
      });
    }

    public void foundLinkInstance(SNode link) {
      SetSequence.fromSet(this.visitedLinks).addElement(link);
    }

    public void foundPropertyInstance(SNode prop) {
      SetSequence.fromSet(this.visitedProperties).addElement(prop);
    }

    public boolean isComplete() {
      if (!(anInstanceHasBeenFound())) {
        return false;
      }
      if (Sequence.fromIterable(unvisitedLinks()).isNotEmpty()) {
        return false;
      }
      if (Sequence.fromIterable(unvisitedProperties()).isNotEmpty()) {
        return false;
      }

      return true;
    }

    private boolean anInstanceHasBeenFound() {
      return ListSequence.fromList(occurences).isNotEmpty();
    }

    public String status() {
      if (!(anInstanceHasBeenFound())) {
        return MISSING;
      }
      if (Sequence.fromIterable(unvisitedLinks()).isEmpty() && Sequence.fromIterable(unvisitedProperties()).isEmpty()) {
        return COVERED + " " + statsString();
      }
      return PARTIAL + " Missing: " + Sequence.fromIterable(unvisitedProperties()).concat(Sequence.fromIterable(unvisitedLinks()));
    }

    public String statsString() {
      return "N=" + testCount() + ", V=" + this.testVolume() + " H=" + this.minimumHeterogeneity() + ".." + this.maximumHeterogeneity();
    }

    public int testCount() {
      return ListSequence.fromList(this.occurences).count();
    }


    public Color color() {
      if (this.visitedLinks == null) {
        return (anInstanceHasBeenFound() ? COVERED_COLOR : MISSING_COLOR);
      }
      return PARTIAL_COLOR;
    }

    public void foundInstance(SNode instance) {
      ExpressionStat stat = new ExpressionStat(instance);
      ListSequence.fromList(this.occurences).addElement(stat);
    }

    public Iterable<SNode> unvisitedLinks() {
      return Sequence.fromIterable(allLinks()).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SetSequence.fromSet(StructureData.this.visitedLinks).contains(it));
        }
      });
    }

    public Iterable<SNode> unvisitedProperties() {
      if (!(trackProperties)) {
        return Sequence.fromIterable(Collections.<SNode>emptyList());
      }
      return Sequence.fromIterable(allProperties()).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SetSequence.fromSet(StructureData.this.visitedProperties).contains(it));
        }
      });
    }

    public int minimumHeterogeneity() {
      if (ListSequence.fromList(this.occurences).isEmpty()) {
        return -1;
      }
      return ListSequence.fromList(this.occurences).sort(new ISelector<ExpressionStat, Integer>() {
        public Integer select(ExpressionStat it) {
          return it.heterogeneity();
        }
      }, true).first().heterogeneity();
    }

    public int maximumHeterogeneity() {
      if (ListSequence.fromList(this.occurences).isEmpty()) {
        return -1;
      }
      return ListSequence.fromList(this.occurences).sort(new ISelector<ExpressionStat, Integer>() {
        public Integer select(ExpressionStat it) {
          return it.heterogeneity();
        }
      }, true).last().heterogeneity();
    }

    public int testVolume() {
      int vol = 0;
      for (ExpressionStat oc : ListSequence.fromList(this.occurences)) {
        vol += oc.metric();
      }
      return vol;
    }


    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer();
      sb.append(this.concept.getName());
      if (!(anInstanceHasBeenFound())) {
        sb.append(" not visited.");
      } else if (!(this.isComplete())) {
        sb.append(" missing " + Sequence.fromIterable(unvisitedProperties()).concat(Sequence.fromIterable(unvisitedLinks())));
      }
      return sb.toString();
    }


  }



  private Map<SAbstractConcept, StructureData> visitedConcepts = MapSequence.fromMap(new HashMap<SAbstractConcept, StructureData>());
  private Set<SLanguage> registeredLanguages = SetSequence.fromSet(new HashSet<SLanguage>());
  private Set<SAbstractConcept> ignoredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private boolean trackProperties;

  public void foundConceptInstance(SAbstractConcept ccc, SNode instance) {
    getData(ccc).foundInstance(instance);
  }

  private StructureData getData(SAbstractConcept ccc) {
    StructureData data = MapSequence.fromMap(visitedConcepts).get(ccc);
    if (data == null) {
      data = new StructureData(ccc, getAllRelevantConcepts(), trackProperties);
      MapSequence.fromMap(visitedConcepts).put(ccc, data);
    }
    return data;
  }

  public void foundLinkInstance(SAbstractConcept ccc, SNode link) {
    StructureData data = getData(ccc);
    data.foundLinkInstance(link);
  }

  public void foundPropertyInstance(SAbstractConcept ccc, SNode link) {
    StructureData data = getData(ccc);
    data.foundPropertyInstance(link);
  }


  public int ratio() {
    return 100 - ((int) (((float) Sequence.fromIterable(missingConceptsOrIncomplete()).count()) / ((float) Sequence.fromIterable(allConceptsStatus()).count()) * 100));
  }

  public List<SAbstractConcept> allResultsConcepts() {
    return ListSequence.fromList(getAllRelevantConcepts()).removeWhere(new IWhereFilter<SAbstractConcept>() {
      public boolean accept(SAbstractConcept it) {
        return it.isAbstract() || it instanceof SInterfaceConcept;
      }
    });
  }

  public List<SAbstractConcept> getAllRelevantConcepts() {
    return SetSequence.fromSet(registeredLanguages).translate(new ITranslator2<SLanguage, SAbstractConcept>() {
      public Iterable<SAbstractConcept> translate(SLanguage it) {
        return ((Iterable<SAbstractConcept>) it.getConcepts());
      }
    }).where(new IWhereFilter<SAbstractConcept>() {
      public boolean accept(final SAbstractConcept c) {
        return SetSequence.fromSet(ignoredConcepts).all(new IWhereFilter<SAbstractConcept>() {
          public boolean accept(SAbstractConcept it) {
            return !(c.isSubConceptOf(it));
          }
        });
      }
    }).toListSequence();
  }

  public Iterable<StructureData> missingConceptsOrIncomplete() {
    return Sequence.fromIterable(allConceptsStatus()).where(new IWhereFilter<StructureData>() {
      public boolean accept(StructureData it) {
        return !(it.isComplete());
      }
    });
  }

  public Iterable<StructureData> allConceptsStatus() {
    final List<SAbstractConcept> allRelevantConcepts = getAllRelevantConcepts();
    return ListSequence.fromList(allResultsConcepts()).select(new ISelector<SAbstractConcept, StructureData>() {
      public StructureData select(SAbstractConcept it) {
        StructureData ccc = MapSequence.fromMap(visitedConcepts).get(it);
        if (ccc == null) {
          MapSequence.fromMap(visitedConcepts).put(it, ccc = new StructureData(it, allRelevantConcepts, trackProperties));
        }
        return ccc;
      }
    });
  }


  public void registerLanguage(SLanguage l) {
    SetSequence.fromSet(registeredLanguages).addElement(l);
  }

  public void registerIgnoredConcept(SAbstractConcept c) {
    SetSequence.fromSet(ignoredConcepts).addElement(c);
  }

  public void setTrackProperties(boolean trackProperties) {
    this.trackProperties = trackProperties;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }
}
