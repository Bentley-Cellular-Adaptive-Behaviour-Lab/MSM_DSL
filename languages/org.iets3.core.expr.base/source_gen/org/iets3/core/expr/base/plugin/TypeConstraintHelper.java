package org.iets3.core.expr.base.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import org.iets3.core.expr.base.behavior.ConstraintAndError;
import org.iets3.core.expr.base.behavior.Type__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class TypeConstraintHelper {

  public static boolean isValidFatal(SNode expectedType, String errorLabel, Object causingValue, IContext ctx, String kind, ICoverageAnalyzer coverage, ComputationTrace trace) {
    if (expectedType == null) {
      return true;
    }
    Iterable<ConstraintAndError> constraints = Type__BehaviorDescriptor.applicableConstraints_id2S3ZC$oEyBR.invoke(expectedType);
    if (Sequence.fromIterable(constraints).isNotEmpty()) {
      ctx.getEnvironment().put(MarkerNodes.TYPECONSTRAINT, causingValue);
      for (ConstraintAndError conAndError : Sequence.fromIterable(constraints)) {
        coverage.coverValue(SNodeOperations.getParent(conAndError.expression), null);
        SNode expr = conAndError.expression;
        Object evalResult = ctx.getRootInterpreter().evaluate(expr, ctx, coverage, trace, false);
        boolean isOk = conAndError.isValueOk(evalResult);
        CVH.reportIfFalse(ctx, kind, causingValue, isOk, expr, conAndError.buildErrorMessage(causingValue, evalResult, ctx, coverage, trace), trace, conAndError.warning);
      }
    }
    return true;
  }

  public static ValidValue isValidInteractive(SNode expectedType, Object value, IContext ctx, ICoverageAnalyzer coverage, ComputationTrace trace) {
    if (expectedType == null) {
      return new ValidValue(false, new MessageValue("<no type given>"));
    }

    if (Sequence.fromIterable(Type__BehaviorDescriptor.applicableConstraints_id2S3ZC$oEyBR.invoke(expectedType)).isNotEmpty()) {
      ctx.getEnvironment().put(MarkerNodes.TYPECONSTRAINT, value);
      ComputationTrace ct = new ComputationTrace();
      if (trace != null) {
        ct = trace;
      }
      for (ConstraintAndError conAndError : Sequence.fromIterable(Type__BehaviorDescriptor.applicableConstraints_id2S3ZC$oEyBR.invoke(expectedType))) {
        // Skip warnings 
        if (conAndError.warning) {
          continue;
        }

        SNode expr = conAndError.expression;
        Object evalResult = ctx.getRootInterpreter().evaluate(expr, ctx, coverage, ct, false);
        boolean isOk = conAndError.isValueOk(evalResult);
        if (!(isOk)) {
          return new ValidValue(false, conAndError.buildErrorMessage(value, evalResult, ctx, coverage, ct));
        }
      }
    }
    return new ValidValue(true, null);
  }

}
