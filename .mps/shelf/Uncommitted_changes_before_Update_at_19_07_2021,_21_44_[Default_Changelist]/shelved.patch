Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CMakeRunConfigurationManager\" shouldGenerate=\"true\" shouldDeleteObsolete=\"true\">\n    <generated>\n      <config projectName=\"tests/automated/autoSpringAgent\" targetName=\"autoSpringAgent\" />\n      <config projectName=\"tests/automated/autoSpringAgent\" targetName=\"gtest_main\" />\n      <config projectName=\"tests/automated/autoSpringAgent\" targetName=\"gmock\" />\n      <config projectName=\"tests/automated/autoSpringAgent\" targetName=\"gmock_main\" />\n      <config projectName=\"tests/automated/autoSpringAgent\" targetName=\"gtest\" />\n    </generated>\n  </component>\n  <component name=\"CMakeSettings\" AUTO_RELOAD=\"true\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" CONFIG_NAME=\"Debug\" ENABLED=\"true\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"89557931-1118-44d0-b711-ffcba6aaad23\" name=\"Default Changelist\" comment=\"WORKING TESTS\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/tests/automated/helper_ODE.cpp\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/tests/automated/helper_ODE.cpp\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/tests/automated/helper_ODE.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/tests/automated/helper_ODE.h\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"UserTesting\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitSEFilterConfiguration\">\n    <file-type-list>\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\n      <filtered-out-file-type name=\"TAG\" />\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\n    </file-type-list>\n  </component>\n  <component name=\"ProjectId\" id=\"1pzAh6E6l5664C8Z231BnkCHNV5\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.cidr.known.project.marker\" value=\"true\" />\n    <property name=\"SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"cf.first.check.clang-format\" value=\"false\" />\n    <property name=\"cidr.known.project.marker\" value=\"true\" />\n    <property name=\"cmake.loaded.for.project\" value=\"true\" />\n    <property name=\"ctest.advertisement.all.test.configuration.is.created\" value=\"true\" />\n    <property name=\"last_opened_file_path\" value=\"$USER_HOME$/CLionProjects/adaptive-cell-effort-model\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"CPPToolchains\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"C:\\Users\\Tom\\MPSProjects\\MSM_DSL\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Google Test.autoSpringAgent\">\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"autoSpringAgent\" type=\"CMakeGoogleTestRunConfigurationType\" factoryName=\"Google Test\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"tests/automated/autoSpringAgent\" TARGET_NAME=\"autoSpringAgent\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"tests/automated/autoSpringAgent\" RUN_TARGET_NAME=\"autoSpringAgent\" TEST_MODE=\"SUITE_TEST\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n        <option name=\"BeforeTestRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"gmock\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"tests/automated/autoSpringAgent\" TARGET_NAME=\"gmock\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"gmock_main\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"tests/automated/autoSpringAgent\" TARGET_NAME=\"gmock_main\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"gtest\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"tests/automated/autoSpringAgent\" TARGET_NAME=\"gtest\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"gtest_main\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"tests/automated/autoSpringAgent\" TARGET_NAME=\"gtest_main\" CONFIG_NAME=\"Debug\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"All CTest\" type=\"CTestRunConfiguration\" factoryName=\"CTestRun\" PROGRAM_PARAMS=\"--extra-verbose\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" WORKING_DIR=\"file://$CMakeCurrentGenerationDir$\" PASS_PARENT_ENVS_2=\"true\" RUN_PATH=\"$CTestCurrentExecutableName$\" EXPLICIT_BUILD_TARGET_NAME=\"all\" TEST_MODE=\"SUITE_TEST\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n        <option name=\"BeforeTestRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"GradleAppRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"DebugMPS\" type=\"Remote\">\n      <option name=\"USE_SOCKET_TRANSPORT\" value=\"true\" />\n      <option name=\"SERVER_MODE\" value=\"false\" />\n      <option name=\"SHMEM_ADDRESS\" />\n      <option name=\"HOST\" value=\"localhost\" />\n      <option name=\"PORT\" value=\"5071\" />\n      <option name=\"AUTO_RESTART\" value=\"false\" />\n      <RunnerSettings RunnerId=\"Debug\">\n        <option name=\"DEBUG_PORT\" value=\"5071\" />\n        <option name=\"LOCAL\" value=\"false\" />\n      </RunnerSettings>\n      <method v=\"2\" />\n    </configuration>\n    <list>\n      <item itemvalue=\"CMake Application.gmock\" />\n      <item itemvalue=\"CMake Application.gmock_main\" />\n      <item itemvalue=\"CMake Application.gtest\" />\n      <item itemvalue=\"CMake Application.gtest_main\" />\n      <item itemvalue=\"Google Test.autoSpringAgent\" />\n      <item itemvalue=\"CTest Application.All CTest\" />\n    </list>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"89557931-1118-44d0-b711-ffcba6aaad23\" name=\"Default Changelist\" comment=\"\" />\n      <created>1616175660386</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1616175660386</updated>\n      <workItem from=\"1617032730574\" duration=\"672000\" />\n      <workItem from=\"1617185241646\" duration=\"35000\" />\n      <workItem from=\"1619694528463\" duration=\"495000\" />\n      <workItem from=\"1619702487143\" duration=\"132000\" />\n      <workItem from=\"1619773262647\" duration=\"671000\" />\n      <workItem from=\"1620738700291\" duration=\"602000\" />\n      <workItem from=\"1620739529831\" duration=\"30000\" />\n      <workItem from=\"1621606889220\" duration=\"7171000\" />\n      <workItem from=\"1621847319616\" duration=\"14000\" />\n      <workItem from=\"1621852338080\" duration=\"12020000\" />\n      <workItem from=\"1621867404708\" duration=\"250000\" />\n      <workItem from=\"1622025763428\" duration=\"10052000\" />\n      <workItem from=\"1623070886578\" duration=\"606000\" />\n      <workItem from=\"1623143459849\" duration=\"11078000\" />\n      <workItem from=\"1623160004100\" duration=\"6014000\" />\n      <workItem from=\"1623316399404\" duration=\"1384000\" />\n      <workItem from=\"1623319150508\" duration=\"1168000\" />\n      <workItem from=\"1623328785239\" duration=\"2801000\" />\n      <workItem from=\"1623337407227\" duration=\"6654000\" />\n      <workItem from=\"1623344322634\" duration=\"117000\" />\n      <workItem from=\"1623420416626\" duration=\"13635000\" />\n      <workItem from=\"1623675981294\" duration=\"4658000\" />\n      <workItem from=\"1623763394889\" duration=\"9616000\" />\n      <workItem from=\"1623859059708\" duration=\"5697000\" />\n      <workItem from=\"1623920674741\" duration=\"10414000\" />\n      <workItem from=\"1623936683285\" duration=\"9290000\" />\n      <workItem from=\"1623947084542\" duration=\"684000\" />\n      <workItem from=\"1624018071377\" duration=\"11232000\" />\n      <workItem from=\"1624276195459\" duration=\"4063000\" />\n      <workItem from=\"1624292568655\" duration=\"740000\" />\n      <workItem from=\"1624525435723\" duration=\"1002000\" />\n      <workItem from=\"1624526457169\" duration=\"2213000\" />\n      <workItem from=\"1624534719433\" duration=\"5521000\" />\n      <workItem from=\"1626345648715\" duration=\"9960000\" />\n      <workItem from=\"1626426112987\" duration=\"2038000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Removed old protein files.\">\n      <created>1621607035051</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621607035051</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Added new protein class to be used with ODE system implementation.\">\n      <created>1621607208831</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621607208831</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"Implemented basic protein class\">\n      <created>1621608453260</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621608453260</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"Declared function to add proteins to cell types\">\n      <created>1621608733574</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621608733574</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"Implemented function to add proteins to cell types\">\n      <created>1621608960068</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621608960068</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"Changed gradient class to proteins objects.\">\n      <created>1621609453985</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621609453985</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"Changed gradient class to proteins objects.\">\n      <created>1621609507700</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621609507700</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"Changed VEGF gradient functions to use starting value of protein. Removed m_starting amount from gradient class.\">\n      <created>1621609656942</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621609656942</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"Implemented function to add proteins to environment agents during gradient creation.\">\n      <created>1621611517436</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621611517436</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"Implemented function to add proteins to a memAgent during memAgent creation.\">\n      <created>1621614113643</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621614113643</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"Fixed issues with code insight not working properly.\">\n      <created>1621861425813</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621861425813</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"Added new functions for creating generic protein gradients, using protein objects.\">\n      <created>1621864979115</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621864979115</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"Fixed problem CMAKE file not finding sources.\">\n      <created>1621866846155</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1621866846155</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"Created new ODE class and associated files.\">\n      <created>1623146799133</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623146799133</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"Created functions for checking protein levels in the environment around memagents.\">\n      <created>1623154575039</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623154575039</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"Added functions for measuring the amount of protein in adjacent memagents\">\n      <created>1623165218262</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623165218262</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"Changed ODE_system to be a static function. Included additional rate function for example.\">\n      <created>1623168737127</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623168737127</updated>\n    </task>\n    <task id=\"LOCAL-00018\" summary=\"Updated dsl files for testing\">\n      <created>1623330827802</created>\n      <option name=\"number\" value=\"00018\" />\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623330827802</updated>\n    </task>\n    <task id=\"LOCAL-00019\" summary=\"Testing addition of gradient and cell containing new proteins.\">\n      <created>1623339295546</created>\n      <option name=\"number\" value=\"00019\" />\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623339295546</updated>\n    </task>\n    <task id=\"LOCAL-00020\" summary=\"Changed tissue creation to assign the cell type to cell agents.\">\n      <created>1623342190961</created>\n      <option name=\"number\" value=\"00020\" />\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623342190961</updated>\n    </task>\n    <task id=\"LOCAL-00021\" summary=\"Testing Boost library bug\">\n      <created>1623676295769</created>\n      <option name=\"number\" value=\"00021\" />\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623676295769</updated>\n    </task>\n    <task id=\"LOCAL-00022\" summary=\"Renamed endothelial cell variables in dsl_tissue example.\">\n      <created>1623769512630</created>\n      <option name=\"number\" value=\"00022\" />\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623769512630</updated>\n    </task>\n    <task id=\"LOCAL-00023\" summary=\"Implemented new function to allocate proteins at the start of the simulation.\">\n      <created>1623769543730</created>\n      <option name=\"number\" value=\"00023\" />\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623769543730</updated>\n    </task>\n    <task id=\"LOCAL-00024\" summary=\"Moved old tissue setup to new if statement. Added call to protein set up function during creation timestep.\">\n      <created>1623769590148</created>\n      <option name=\"number\" value=\"00024\" />\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623769590148</updated>\n    </task>\n    <task id=\"LOCAL-00025\" summary=\"Added declarations for ode setup to world class.\">\n      <created>1623769695244</created>\n      <option name=\"number\" value=\"00025\" />\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623769695244</updated>\n    </task>\n    <task id=\"LOCAL-00026\" summary=\"Added functions for ode setup to world class.\">\n      <created>1623769708105</created>\n      <option name=\"number\" value=\"00026\" />\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623769708105</updated>\n    </task>\n    <task id=\"LOCAL-00027\" summary=\"Moved steppers to ODE running function.\">\n      <created>1623774075490</created>\n      <option name=\"number\" value=\"00027\" />\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623774075490</updated>\n    </task>\n    <task id=\"LOCAL-00028\" summary=\"Moved steppers to ODE running function.\">\n      <created>1623859279775</created>\n      <option name=\"number\" value=\"00028\" />\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623859279775</updated>\n    </task>\n    <task id=\"LOCAL-00029\" summary=\"Created logger class\">\n      <created>1623859429651</created>\n      <option name=\"number\" value=\"00029\" />\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623859429651</updated>\n    </task>\n    <task id=\"LOCAL-00030\" summary=\"Filled out logger class with functions, and added it as a member to ECs.\">\n      <created>1623921808650</created>\n      <option name=\"number\" value=\"00030\" />\n      <option name=\"presentableId\" value=\"LOCAL-00030\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623921808650</updated>\n    </task>\n    <task id=\"LOCAL-00031\" summary=\"Added call to logger creation during tissue setup\">\n      <created>1623922265693</created>\n      <option name=\"number\" value=\"00031\" />\n      <option name=\"presentableId\" value=\"LOCAL-00031\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623922265693</updated>\n    </task>\n    <task id=\"LOCAL-00032\" summary=\"Added call to logger creation during tissue setup\">\n      <created>1623922317996</created>\n      <option name=\"number\" value=\"00032\" />\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623922317996</updated>\n    </task>\n    <task id=\"LOCAL-00033\" summary=\"Implemented file writing functions for logger\">\n      <created>1623929232194</created>\n      <option name=\"number\" value=\"00033\" />\n      <option name=\"presentableId\" value=\"LOCAL-00033\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623929232194</updated>\n    </task>\n    <task id=\"LOCAL-00034\" summary=\"Added call to logger during update loop.\">\n      <created>1623930678117</created>\n      <option name=\"number\" value=\"00034\" />\n      <option name=\"presentableId\" value=\"LOCAL-00034\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1623930678117</updated>\n    </task>\n    <task id=\"LOCAL-00035\" summary=\"Created utils namespace and added functions to handle string manipulation\">\n      <created>1624022130583</created>\n      <option name=\"number\" value=\"00035\" />\n      <option name=\"presentableId\" value=\"LOCAL-00035\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1624022130583</updated>\n    </task>\n    <task id=\"LOCAL-00036\" summary=\"Begun changing generators for species to match new layout.\">\n      <created>1624294045236</created>\n      <option name=\"number\" value=\"00036\" />\n      <option name=\"presentableId\" value=\"LOCAL-00036\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1624294045236</updated>\n    </task>\n    <task id=\"LOCAL-00037\" summary=\"Testing spring allocation for flat tissues.\">\n      <created>1624537314654</created>\n      <option name=\"number\" value=\"00037\" />\n      <option name=\"presentableId\" value=\"LOCAL-00037\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1624537314654</updated>\n    </task>\n    <task id=\"LOCAL-00038\" summary=\"Testing spring allocation for flat tissues.\">\n      <created>1624537709983</created>\n      <option name=\"number\" value=\"00038\" />\n      <option name=\"presentableId\" value=\"LOCAL-00038\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1624537709983</updated>\n    </task>\n    <task id=\"LOCAL-00039\" summary=\"Readded missing generated files\">\n      <created>1626693502966</created>\n      <option name=\"number\" value=\"00039\" />\n      <option name=\"presentableId\" value=\"LOCAL-00039\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1626693502966</updated>\n    </task>\n    <task id=\"LOCAL-00040\" summary=\"WORKING TESTS\">\n      <created>1626693810948</created>\n      <option name=\"number\" value=\"00040\" />\n      <option name=\"presentableId\" value=\"LOCAL-00040\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1626693810948</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"41\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Fixed problem CMAKE file not finding sources.\" />\n    <MESSAGE value=\"Created new ODE class and associated files.\" />\n    <MESSAGE value=\"Created functions for checking protein levels in the environment around memagents.\" />\n    <MESSAGE value=\"Added functions for measuring the amount of protein in adjacent memagents\" />\n    <MESSAGE value=\"Changed ODE_system to be a static function. Included additional rate function for example.\" />\n    <MESSAGE value=\"Updated dsl files for testing\" />\n    <MESSAGE value=\"Testing addition of gradient and cell containing new proteins.\" />\n    <MESSAGE value=\"Changed tissue creation to assign the cell type to cell agents.\" />\n    <MESSAGE value=\"Testing Boost library bug\" />\n    <MESSAGE value=\"Renamed endothelial cell variables in dsl_tissue example.\" />\n    <MESSAGE value=\"Implemented new function to allocate proteins at the start of the simulation.\" />\n    <MESSAGE value=\"Moved old tissue setup to new if statement. Added call to protein set up function during creation timestep.\" />\n    <MESSAGE value=\"Added declarations for ode setup to world class.\" />\n    <MESSAGE value=\"Added functions for ode setup to world class.\" />\n    <MESSAGE value=\"Moved steppers to ODE running function.\" />\n    <MESSAGE value=\"Created logger class\" />\n    <MESSAGE value=\"Filled out logger class with functions, and added it as a member to ECs.\" />\n    <MESSAGE value=\"Added call to logger creation during tissue setup\" />\n    <MESSAGE value=\"Implemented file writing functions for logger\" />\n    <MESSAGE value=\"Added call to logger during update loop.\" />\n    <MESSAGE value=\"Created utils namespace and added functions to handle string manipulation\" />\n    <MESSAGE value=\"Begun changing generators for species to match new layout.\" />\n    <MESSAGE value=\"Testing spring allocation for flat tissues.\" />\n    <MESSAGE value=\"Readded missing generated files\" />\n    <MESSAGE value=\"WORKING TESTS\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"WORKING TESTS\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" type=\"com.jetbrains.cidr.execution.debugger.OCBreakpointType\">\n          <url>file://$PROJECT_DIR$/src/objects.h</url>\n          <line>14</line>\n          <option name=\"timeStamp\" value=\"1\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/.idea/workspace.xml	(date 1626716445617)
@@ -15,10 +15,25 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="89557931-1118-44d0-b711-ffcba6aaad23" name="Default Changelist" comment="WORKING TESTS">
+    <list default="true" id="89557931-1118-44d0-b711-ffcba6aaad23" name="Default Changelist" comment="implementing tests">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/EC.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/EC.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/Tissue.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/Tissue.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/creation.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/creation.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/memAgents.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/src/memAgents.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/tests/automated/helper_ODE.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/tests/automated/helper_ODE.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/tests/automated/test_ODE.cpp.o" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/tests/automated/test_ODE.cpp.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/Testing/Temporary/LastTest.log" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/autoSpringAgent" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/autoSpringAgent" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cmake-build-debug/autoSpringAgent[1]_tests.cmake" beforeDir="false" afterPath="$PROJECT_DIR$/cmake-build-debug/autoSpringAgent[1]_tests.cmake" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/EC.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/EC.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/Tissue.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/Tissue.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/creation.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/creation.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/memAgents.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/src/memAgents.cpp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/tests/automated/helper_ODE.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/tests/automated/helper_ODE.cpp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/tests/automated/helper_ODE.h" beforeDir="false" afterPath="$PROJECT_DIR$/tests/automated/helper_ODE.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/tests/automated/test_ODE.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/tests/automated/test_ODE.cpp" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -68,12 +83,18 @@
       <recent name="C:\Users\Tom\MPSProjects\MSM_DSL" />
     </key>
   </component>
-  <component name="RunManager" selected="Google Test.autoSpringAgent">
+  <component name="RunManager" selected="Google Test.CellJunctionTest.crossJunctionODETest">
     <configuration default="true" type="CLionExternalRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
       <method v="2">
         <option name="CLION.EXTERNAL.BUILD" enabled="true" />
       </method>
     </configuration>
+    <configuration name="CellJunctionTest.crossJunctionODETest" type="CMakeGoogleTestRunConfigurationType" factoryName="Google Test" temporary="true" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="tests/automated/autoSpringAgent" TARGET_NAME="autoSpringAgent" RUN_TARGET_PROJECT_NAME="tests/automated/autoSpringAgent" RUN_TARGET_NAME="autoSpringAgent" TEST_CLASS="CellJunctionTest" TEST_METHOD="crossJunctionODETest" TEST_MODE="SUITE_TEST">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+        <option name="BeforeTestRunTask" enabled="true" />
+      </method>
+    </configuration>
     <configuration name="autoSpringAgent" type="CMakeGoogleTestRunConfigurationType" factoryName="Google Test" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="tests/automated/autoSpringAgent" TARGET_NAME="autoSpringAgent" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="tests/automated/autoSpringAgent" RUN_TARGET_NAME="autoSpringAgent" TEST_MODE="SUITE_TEST">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
@@ -131,7 +152,13 @@
       <item itemvalue="CMake Application.gtest_main" />
       <item itemvalue="Google Test.autoSpringAgent" />
       <item itemvalue="CTest Application.All CTest" />
+      <item itemvalue="Google Test.CellJunctionTest.crossJunctionODETest" />
     </list>
+    <recent_temporary>
+      <list>
+        <item itemvalue="Google Test.CellJunctionTest.crossJunctionODETest" />
+      </list>
+    </recent_temporary>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
@@ -457,7 +484,14 @@
       <option name="project" value="LOCAL" />
       <updated>1626693810948</updated>
     </task>
-    <option name="localTasksCounter" value="41" />
+    <task id="LOCAL-00041" summary="implementing tests">
+      <created>1626702200160</created>
+      <option name="number" value="00041" />
+      <option name="presentableId" value="LOCAL-00041" />
+      <option name="project" value="LOCAL" />
+      <updated>1626702200160</updated>
+    </task>
+    <option name="localTasksCounter" value="42" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -476,7 +510,6 @@
     <option name="oldMeFiltersMigrated" value="true" />
   </component>
   <component name="VcsManagerConfiguration">
-    <MESSAGE value="Fixed problem CMAKE file not finding sources." />
     <MESSAGE value="Created new ODE class and associated files." />
     <MESSAGE value="Created functions for checking protein levels in the environment around memagents." />
     <MESSAGE value="Added functions for measuring the amount of protein in adjacent memagents" />
@@ -501,7 +534,8 @@
     <MESSAGE value="Testing spring allocation for flat tissues." />
     <MESSAGE value="Readded missing generated files" />
     <MESSAGE value="WORKING TESTS" />
-    <option name="LAST_COMMIT_MESSAGE" value="WORKING TESTS" />
+    <MESSAGE value="implementing tests" />
+    <option name="LAST_COMMIT_MESSAGE" value="implementing tests" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
Index: tests/automated/helper_ODE.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Thomas Mead on 28/06/2021.\n//\n\n#ifndef TESTS_AUTOMATED_AUTOSPRINGAGENT_HELPER_ODE_H\n#define TESTS_AUTOMATED_AUTOSPRINGAGENT_HELPER_ODE_H\n\n#include <gtest/gtest.h>\n\ntypedef boost::array<float, 2> basic_ode_states;\ntypedef boost::array<float, 4> crossCell_ode_states;\ntypedef boost::array<float, 4> multiAgent_ode_states;\ntypedef boost::array<float, 3> basicFil_ode_states;\ntypedef boost::array<float, 1> basicDistribution_ode_states;\ntypedef boost::array<float, 4> cellJunction_ode_states;\n\nclass World;\nclass World_Container;\nclass MemAgent;\nclass Tissue_Container;\nclass Tissue_Monolayer;\nclass Cell;\n\nclass BasicODEMemAgentTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\n\tMemAgent *memAgent1;\n\tMemAgent *memAgent2;\n\tMemAgent *memAgent3;\n\n\tvoid addWorld(World *world);\n\tvoid addWorldContainer(World_Container *worldContainer);\n\tvoid createMemAgents(EC *dummyCell, World *world);\n\tvoid setupEnvironment();\n\tvoid runODE(MemAgent *memAgent);\n\n\tstatic void BasicMemAgentODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t);\n};\n\nclass CrossCellODEMemAgentTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\n\tMemAgent *memAgent1;\n\tMemAgent *memAgent2;\n\tMemAgent *memAgent3;\n\n\tvoid addWorld(World *crossCellWorld);\n\tvoid addWorldContainer(World_Container *crossCellWorldContainer);\n\tvoid createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world);\n\tvoid setupEnvironment();\n\tstatic void runODE(MemAgent *memAgent);\n\n\tstatic void CrossCellODE_system(const crossCell_ode_states &x, crossCell_ode_states &dxdt, double t);\n\tvoid setupAgentProteins() const;\n\n\tvoid printMemAgentProteinLevels(int timestep) const;\n};\n\nclass MultiNeighbourODEMemAgentTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\n\t// Scenario 1.\n\n\tMemAgent *memAgent1;\n\tMemAgent *memAgent2;\n\tMemAgent *memAgent3;\n\n\t// Scenario 2\n\n\tMemAgent *memAgent4;\n\tMemAgent *memAgent5;\n\tMemAgent *memAgent6;\n\tMemAgent *memAgent7;\n\n\tvoid addWorld(World *multiNeighbourWorld);\n\tvoid addWorldContainer(World_Container *multiNeighbourWorldContainer);\n\tvoid createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world);\n\tvoid setupEnvironment();\n\tstatic void runODE(MemAgent *memAgent);\n\n\tstatic void MultiAgentODE_system(const multiAgent_ode_states &x, multiAgent_ode_states &dxdt, double t);\n\tvoid setupAgentProteins() const;\n\n\tvoid printMemAgentProteinLevels(int timestep) const;\n};\n\nclass BasicFilODEMemAgentTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\n\tMemAgent *memAgent1;\n\tMemAgent *memAgent2;\n\n\tvoid addWorld(World *basicFilWorld);\n\tvoid addWorldContainer(World_Container *basicFilWorldContainer);\n\tvoid createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world);\n\tvoid setupEnvironment();\n\tstatic void runODE(MemAgent *memAgent);\n\n\tstatic void basicFilODE_system(const basicFil_ode_states &x, basicFil_ode_states &dxdt, double t);\n\tvoid setupAgentProteins() const;\n\n\tvoid printMemAgentProteinLevels(int timestep) const;\n};\n\nclass BasicCellDistributionTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\tTissue_Container *tissueContainer;\n\tCell *cell;\n\n\tvoid addWorld(World *basicCellDistributionWorld);\n\tvoid addWorldContainer(World_Container *basicCellDistributionWorldContainer);\n\tvoid setupEnvironment();\n\tvoid setupCell();\n\tstatic void runODE(MemAgent *memAgent);\n\tstatic void basicCellDistribution_system(const basicDistribution_ode_states &x, basicDistribution_ode_states &dxdt, double t);\n\n\tvoid printCellProteinLevels(int timestep) const;\n};\n\nclass CellJunctionTest : public ::testing::Test {\nprotected:\n\tvoid SetUp() override;\n\tvoid TearDown() override;\npublic:\n\tWorld *world;\n\tWorld_Container *worldContainer;\n\tTissue_Container *tissueContainer;\n\tTissue_Monolayer *tissueMonolauer;\n\n\tvoid addWorld(World *cellJunctionWorld);\n\tvoid addWorldContainer(World_Container *cellJunctionWorldContainer);\n\tvoid setupEnvironment();\n\tvoid setupCells();\n\tstatic void runODE(MemAgent *memAgent);\n\tstatic void cellJunction_system(const cellJunction_ode_states &x, cellJunction_ode_states &dxdt, double t);\n\n\tvoid printCellProteinLevels(int timestep) const;\n};\n\nvoid constantODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t);\nvoid linearODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t);\n\n#endif //TESTS_AUTOMATED_AUTOSPRINGAGENT_HELPER_ODE_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/automated/helper_ODE.h b/tests/automated/helper_ODE.h
--- a/tests/automated/helper_ODE.h	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/tests/automated/helper_ODE.h	(date 1626708337891)
@@ -150,7 +150,7 @@
 	World *world;
 	World_Container *worldContainer;
 	Tissue_Container *tissueContainer;
-	Tissue_Monolayer *tissueMonolauer;
+	Tissue_Monolayer *tissueMonolayer;
 
 	void addWorld(World *cellJunctionWorld);
 	void addWorldContainer(World_Container *cellJunctionWorldContainer);
Index: tests/automated/test_ODE.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Thomas Mead on 28/06/2021.\n//\n\n#include <boost/array.hpp>\n#include <boost/numeric/odeint.hpp>\n\n// Core MSM includes\n#include \"../../src/objects.h\"\n#include \"../../src/world.h\"\n\n// Test suite includes\n#include <cmath>\n#include \"helper_ODE.h\"\n#include \"memAgents.h\"\n#include \"Tissue.h\"\n#include \"EC.h\"\n\nnamespace odeint = boost::numeric::odeint;\n\n// Test that an ODE with a constant rate of change increases a product and decreases a reactant by the rate of change.\n// Runs for a single timestep.\nTEST(test_ODE, ODEConstantRate) {\n\tbasic_ode_states current_states;\n\tbasic_ode_states new_states;\n\todeint::runge_kutta4<basic_ode_states> stepper;\n\n\tcurrent_states[0] = 100.0f;\n\tcurrent_states[1] = 0.0f;\n\n\tstepper.do_step(constantODE_system, current_states, 0.0, new_states, 1);\n\n\tEXPECT_EQ(new_states[0], 95.0f);\n\tEXPECT_EQ(new_states[1], 5.0f);\n}\n\n// Test that an ODE with a constant rate of change increases a product and decreases a reactant by the rate of change.\n// Runs for multiple timesteps.\nTEST(test_ODE, multi_ODEConstantRate) {\n\tbasic_ode_states ode_states;\n\todeint::runge_kutta4<basic_ode_states> stepper;\n\n\tode_states[0] = 100;\n\tode_states[1] = 0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tstepper.do_step(constantODE_system, ode_states, 0.0, 1);\n\t}\n\n\tEXPECT_EQ(round(ode_states[0]), 75);\n\tEXPECT_EQ(round(ode_states[1]), 25);\n}\n\n// Test that an ODE with a constant rate of change increases a product and decreases a reactant by the rate of change.\n// Runs for a single timestep.\nTEST(test_ODE, ODELinearRate) {\n\tbasic_ode_states current_states;\n\tbasic_ode_states new_states;\n\todeint::runge_kutta4<basic_ode_states> stepper;\n\n\tcurrent_states[0] = 100;\n\tcurrent_states[1] = 0;\n\n\tstepper.do_step(linearODE_system, current_states, 0.0, new_states, 1);\n\tEXPECT_EQ(round(new_states[0]), 90);\n\tEXPECT_EQ(round(new_states[1]), 10);\n}\n\nTEST_F(BasicODEMemAgentTest, environmentCheckTest) {\n\tEXPECT_EQ(round(memAgent1->get_environment_protein_level(\"B\")), 26);\n\tEXPECT_EQ(round(memAgent2->get_environment_protein_level(\"B\")), 25);\n\tEXPECT_EQ(round(memAgent3->get_environment_protein_level(\"B\")), 25);\n\n}\n\nTEST_F(BasicODEMemAgentTest, memAgentTest) {\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"A\")), 270);\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"A\")), 260);\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"A\")), 260);\n}\n\nTEST_F(CrossCellODEMemAgentTest, cellODETest) {\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"A\")), 1);\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"B\")), 1);\n\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"A\")), 11);\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"B\")), 1);\n\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"A\")), 11);\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"B\")), 1);\n}\n\nTEST_F(CrossCellODEMemAgentTest, junctionODETest) {\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"C\")), 11);\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"D\")), 1);\n\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"C\")), 11);\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"D\")), 1);\n\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"C\")), 1);\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"D\")), 1);\n}\n\n// Tests that memAgents are able to check multiple neighbours.\n// Runs an ODE in two memAgents with have either 2 (memAgent2) or 3 (memAgent7) neighbours, for a single timestep.\n// TODO: Revisit this test, asynchronous updating of memAgents.\nTEST_F(MultiNeighbourODEMemAgentTest, cellODETest) {\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"A\")), 20);\n\tEXPECT_EQ(round(memAgent7->get_memAgent_protein_level(\"C\")), 25);\n\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"B\")), 5);\n\tEXPECT_EQ(round(memAgent3->get_memAgent_protein_level(\"B\")), 5);\n\tEXPECT_EQ(round(memAgent4->get_memAgent_protein_level(\"D\")), 5);\n\tEXPECT_EQ(round(memAgent5->get_memAgent_protein_level(\"D\")), 5);\n\tEXPECT_EQ(round(memAgent6->get_memAgent_protein_level(\"D\")), 5);\n}\n\nTEST_F(BasicFilODEMemAgentTest, basicFilTest) {\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"B\")), 26);\n\tEXPECT_EQ(round(memAgent1->get_memAgent_protein_level(\"C\")), 26);\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"B\")), 26);\n\tEXPECT_EQ(round(memAgent2->get_memAgent_protein_level(\"C\")), 26);\n}\n\nTEST_F(BasicCellDistributionTest, preDistributionTest) {\n\tEXPECT_EQ(this->cell->cell_agent->get_cell_protein_level(\"A\"), 1000);\n\tEXPECT_EQ(this->cell->cell_agent->nodeAgents[0]->get_memAgent_protein_level(\"A\"), 40);\n}\n\nTEST_F(BasicCellDistributionTest, postDistributionTest) {\n\tfor (int i = 0; i < 10; i++) {\n\t\tif (i != 0) {\n\t\t\tthis->cell->cell_agent->distribute_proteins();\n\t\t}\n\t\tfor (auto memAgent : this->cell->cell_agent->nodeAgents) {\n\t\t\trunODE(memAgent);\n\t\t}\n\t\tthis->cell->cell_agent->calculate_cell_protein_levels();\n\t\tthis->printCellProteinLevels(i+1);\n\t}\n\tEXPECT_EQ(this->cell->cell_agent->get_cell_protein_level(\"A\"), 750);\n\tEXPECT_EQ(this->cell->cell_agent->nodeAgents[0]->get_memAgent_protein_level(\"A\"), 30);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/automated/test_ODE.cpp b/tests/automated/test_ODE.cpp
--- a/tests/automated/test_ODE.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/tests/automated/test_ODE.cpp	(date 1626712256524)
@@ -141,3 +141,22 @@
 	EXPECT_EQ(this->cell->cell_agent->get_cell_protein_level("A"), 750);
 	EXPECT_EQ(this->cell->cell_agent->nodeAgents[0]->get_memAgent_protein_level("A"), 30);
 }
+
+TEST_F(CellJunctionTest, crossJunctionODETest) {
+	for (int i = 0; i < 10; i++) {
+		if (i != 0) {
+			for (auto cell : tissueMonolayer->m_cell_agents) {
+				cell->distribute_proteins();
+			}
+		}
+		for (auto cell : tissueMonolayer->m_cell_agents) {
+//			for (auto memAgent : cell->nodeAgents) {
+//				runODE(memAgent);
+//			}
+			cell->calculate_cell_protein_levels();
+		}
+		this->printCellProteinLevels(i+1);
+	}
+//	EXPECT_EQ(this->cell->cell_agent->get_cell_protein_level("A"), 750);
+//	EXPECT_EQ(this->cell->cell_agent->nodeAgents[0]->get_memAgent_protein_level("A"), 30);
+}
Index: tests/automated/helper_ODE.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Thomas Mead on 28/06/2021.\n//\n\n#include <boost/array.hpp>\n#include <boost/numeric/odeint.hpp>\n\n// Core MSM includes\n#include \"../../src/objects.h\"\n#include \"../../src/world.h\"\n\n// Test suite includes\n#include \"helper_ODE.h\"\n#include \"EC.h\"\n#include \"memAgents.h\"\n#include \"Tissue.h\"\n#include \"environment.h\"\n#include \"protein.h\"\n\nnamespace odeint = boost::numeric::odeint;\n\n/*****************************************************************************************\n*  Name:\t\tBasicODEMemAgentTest::SetUp()\n*  Description: Creates a world with three memAgents, which have a certain level of protein A.\n*\t  \t\t\tThe world has a certain level of protein B.\n*\t  \t\t\tThe world runs 10 rounds of updating an ODE between A and B, and checks the\n*\t  \t\t\tlevels in the memAgent after these.\n*\n*\t  \t\t\tODE: 1 B -> 1 A every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\nvoid BasicODEMemAgentTest::SetUp() {\n\t// Setup world container for this test fixture.\n\tauto *w_container = new World_Container();\n\taddWorldContainer(w_container);\n\n\t// Setup world for this test fixture - generates 50x50x50 world w/ no objects.\n\tworldContainer->world_setup();\n\tauto world = worldContainer->get_world();\n\taddWorld(world);\n\n\t// Create an uninitialised \"dummy\" cell for use with the MemAgents.\n\tauto dummyCell = new EC(world);\n\tworld->ECagents.push_back(dummyCell);\n\n\t// Create new memAgents.\n\tcreateMemAgents(dummyCell, world);\n\n\t// Set protein levels for each env agent.\n\tsetupEnvironment();\n\n\t// Add proteins to memAgents.\n\tmemAgent1->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\n\tfor (int i = 0; i < 10; i++) {\n\t\trunODE(memAgent1);\n\t\trunODE(memAgent2);\n\t\trunODE(memAgent3);\n\t}\n}\n\nvoid BasicODEMemAgentTest::TearDown() {\n\n}\n\nvoid BasicODEMemAgentTest::addWorld(World *world) {\n\tthis->world = world;\n}\n\nvoid BasicODEMemAgentTest::addWorldContainer(World_Container *worldContainer) {\n\tthis->worldContainer = worldContainer;\n}\n\nvoid BasicODEMemAgentTest::createMemAgents(EC *dummyCell, World *world) {\n\t// Create three memAgents, set their positions and add them to the world.\n\tauto memAgent1 = new MemAgent(dummyCell, world); // Isolated.\n\tthis->memAgent1 = memAgent1;\n\tmemAgent1->Mx = 25;\n\tmemAgent1->My = 25;\n\tmemAgent1->Mz = 25;\n\tthis->world->grid[25][25][25].type = const_M;\n\n\tauto memAgent2 = new MemAgent(dummyCell, world); // 2 + 3 are adjacent.\n\tthis->memAgent2 = memAgent2;\n\tmemAgent2->Mx = 30;\n\tmemAgent2->My = 30;\n\tmemAgent2->Mz = 30;\n\tthis->world->grid[30][30][30].type = const_M;\n\n\tauto memAgent3 = new MemAgent(dummyCell, world); // 2 + 3 are adjacent.\n\tthis->memAgent3 = memAgent3;\n\tmemAgent3->Mx = 31;\n\tmemAgent3->My = 30;\n\tmemAgent3->Mz = 30;\n\tthis->world->grid[31][30][30].type = const_M;\n}\n\nvoid BasicODEMemAgentTest::setupEnvironment() {\n\tEnv *ep;\n\tfor (int x = 0; x < world->gridXDimensions; x++) {\n\t\tfor (int y = 0; y < world->gridYDimensions; y++) {\n\t\t\tfor (int z = 0; z < world->gridYDimensions; z++) {\n\t\t\t\tif (world->grid[x][y][z].type == const_E) {\n\t\t\t\t\tauto proteinB = new protein(\"B\", PROTEIN_LOCATION_ENVIRONMENT, 1, false, 0, 100);\n\t\t\t\t\tep = world->grid[x][y][z].Eid;\n\t\t\t\t\tep->owned_proteins.push_back(proteinB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid BasicODEMemAgentTest::BasicMemAgentODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\n\tdxdt[0] = +B; // Rate of change for species A\n\tdxdt[1] = 0;\n}\n\nvoid BasicODEMemAgentTest::runODE(MemAgent *memAgent) {\n\tbasic_ode_states ode_states;\n\todeint::euler<basic_ode_states> stepper;\n\n\tode_states[0] = memAgent->get_memAgent_protein_level(\"A\"); // Protein A\n\tode_states[1] = memAgent->get_environment_protein_level(\"B\"); // Protein B\n\n\tstepper.do_step(BasicMemAgentODE_system, ode_states, 0.0, 1);\n\n\tmemAgent->set_protein_level(\"A\", ode_states[0]);\n}\n\nvoid constantODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\n\tdxdt[0] = -5; // Rate of change for species A\n\tdxdt[1] = +5; // Rate of change for species B\n}\n\nvoid linearODE_system(const basic_ode_states &x, basic_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\n\tdxdt[0] = -(x[0] * 0.1); // Rate of change for species A\n\tdxdt[1] = +(x[0] * 0.1); // Rate of change for species B\n}\n\n/*****************************************************************************************\n*  Name:\t\tCrossCellODEMemAgentTest::SetUp()\n*  Description: - Creates a world with three memAgents, which each have a certain level of\n*  \t\t\t\tproteins A, B, C and D.\n *  \t\t\t- memAgents 1 & 2 are junctional and belong to different cells.\n*\t  \t\t\t- memAgent 3 belongs to the same cell as memAgent 2.\n*\t  \t\t\tDiagram:\n*\n*\t  \t\t\tO O O O O O O O O O O O O O O O\n*\t  \t\t\tO O O O O O 1 2 3 O O O O O O O\n*\t  \t\t\tO O O O O O O O O O O O O O O O\n*\n*\t  \t\t\t- The world runs 10 rounds of updating an ODE between A and B (cell proteins) as well as\n*\t  \t\t\tC and D (junctional proteins) and checks the levels in the memAgent after these.\n*\t  \t\t\t- Tests whether junctional and intercell ODEs work correctly.\n*\n*\t  \t\t\tODE: 1 B -> 1 A every timestep.\n*\t  \t\t\tODE: 1 D -> 1 C every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid CrossCellODEMemAgentTest::SetUp() {\n\t// Setup world container for this test fixture.\n\tauto w_container = new World_Container();\n\taddWorldContainer(w_container);\n\n\t// Setup world for this test fixture - generates 50x50x50 world w/ no objects.\n\tworldContainer->world_setup();\n\tauto world = worldContainer->get_world();\n\taddWorld(world);\n\n\t// Create two uninitialised \"dummy\" cells for use with the MemAgents.\n\tauto dummyCell1 = new EC(world);\n\tauto dummyCell2 = new EC(world);\n\tworld->ECagents.push_back(dummyCell1);\n\tworld->ECagents.push_back(dummyCell2);\n\n\t// Create memAgents and assign them to cells.\n\tcreateMemAgents(dummyCell1, dummyCell2, world);\n\t// Setup agent proteins.\n\tsetupAgentProteins();\n\n\tstd::cout << \"mem1_A,\" << \"mem2_A,\" << \"mem3_A,\"\n\t\t\t  << \"mem1_B,\" << \"mem2_B,\" << \"mem3_B,\"\n\t\t\t  << \"mem1_C,\" << \"mem2_C,\" << \"mem3_C,\"\n\t\t\t  << \"mem1_D,\" << \"mem2_D,\" << \"mem3_D,\" <<  \"time\\n\";\n\tprintMemAgentProteinLevels(0);\n\n\tfor (int i = 0; i < 10; i++) {\n\t\trunODE(memAgent1);\n\t\trunODE(memAgent2);\n\t\trunODE(memAgent3);\n\t\tprintMemAgentProteinLevels(i + 1);\n\t}\n}\n\nvoid CrossCellODEMemAgentTest::TearDown() {\n\n}\n\nvoid CrossCellODEMemAgentTest::addWorld(World *crossCellWorld) {\n\tthis->world = crossCellWorld;\n}\n\nvoid CrossCellODEMemAgentTest::addWorldContainer(World_Container *crossCellWorldContainer) {\n\tthis->worldContainer = crossCellWorldContainer;\n}\n\nvoid CrossCellODEMemAgentTest::createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world) {\n\t// Create three memAgents, set their positions and add them to the world.\n\tauto memAgent1 = new MemAgent(dummyCell1, world);\n\tthis->memAgent1 = memAgent1;\n\tmemAgent1->Mx = 25;\n\tmemAgent1->My = 25;\n\tmemAgent1->Mz = 25;\n\tmemAgent1->junction = true;\n\tthis->world->grid[25][25][25].type = const_M;\n\tthis->world->grid[25][25][25].Mids.push_back(memAgent1);\n\n\tauto memAgent2 = new MemAgent(dummyCell2, world);\n\tthis->memAgent2 = memAgent2;\n\tmemAgent2->Mx = 26;\n\tmemAgent2->My = 25;\n\tmemAgent2->Mz = 25;\n\tmemAgent2->junction = true;\n\tthis->world->grid[26][25][25].type = const_M;\n\tthis->world->grid[26][25][25].Mids.push_back(memAgent2);\n\n\tauto memAgent3 = new MemAgent(dummyCell2, world);\n\tthis->memAgent3 = memAgent3;\n\tmemAgent3->Mx = 27;\n\tmemAgent3->My = 25;\n\tmemAgent3->Mz = 25;\n\tmemAgent3->junction = false;\n\tthis->world->grid[27][25][25].type = const_M;\n\tthis->world->grid[27][25][25].Mids.push_back(memAgent3);\n}\n\nvoid CrossCellODEMemAgentTest::setupAgentProteins() const {\n\tmemAgent1->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 1, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 1, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 1, false, 0,100));\n\n\tmemAgent1->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 1, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 1, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 1, false, 0, 100));\n\n\tmemAgent1->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n\n\tmemAgent1->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 1, false, 0, 100));\n}\n\nvoid CrossCellODEMemAgentTest::setupEnvironment() {\n\n}\n\nvoid CrossCellODEMemAgentTest::runODE(MemAgent *memAgent) {\n\tcrossCell_ode_states ode_states;\n\todeint::euler<crossCell_ode_states> stepper;\n\n\tode_states[0] = memAgent->get_memAgent_protein_level(\"A\"); // Protein A (Cell Protein) *Uses this cell value*\n\tode_states[1] = memAgent->get_local_protein_level(\"B\"); // Protein B (Cell Protein) *Uses neighbour's value*\n\tode_states[2] = memAgent->get_memAgent_protein_level(\"C\"); // Protein C (Junctional Protein) *Uses this cell value*\n\tode_states[3] = memAgent->get_junction_protein_level(\"D\"); // Protein D (Junctional Protein) *Uses neighbour's value*\n\n\tstepper.do_step(CrossCellODE_system, ode_states, 0.0, 1);\n\n\tmemAgent->set_protein_level(\"A\", ode_states[0]);\n\tmemAgent->set_protein_level(\"C\", ode_states[2]);\n\n\tmemAgent->distribute_calculated_proteins(\"B\", ode_states[1], true); /* Use this cell value */\n\tmemAgent->distribute_calculated_proteins(\"D\", ode_states[3], false); /* Use neighbour's value */\n}\n\nvoid CrossCellODEMemAgentTest::CrossCellODE_system(const crossCell_ode_states &x, crossCell_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\tdouble C = x[2];\n\tdouble D = x[3];\n\n\tdxdt[0] = +B; \t// Rate of change for species A\n\tdxdt[1] = 0; \t// Rate of change for species B\n\tdxdt[2] = +D; \t// Rate of change for species C\n\tdxdt[3] = 0; \t// Rate of change for species B\n}\n\nvoid CrossCellODEMemAgentTest::printMemAgentProteinLevels(int timestep) const {\n\n\tstd::cout << memAgent1->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent1->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent1->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent1->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << timestep << \"\\n\";\n}\n\n/*****************************************************************************************\n*  Name:\t\tMultiNeighbourODEMemAgentTest::SetUp()\n*  Description: - Creates a world with seven memAgents, which each have a certain level of proteins A, B.\n*  \t\t\t\t- memAgents 1, 2 & 3 belong to the same cell.\n*\t  \t\t\t- memAgents 4, 5 & 6 belong to the same cell.\n*\n*\t  \t\t\tDiagram:\n*\n*\t  \t\t\tO O O O O O O O O O O O O O O O\n*\t  \t\t\tO O 1 2 3 O 0 0 0 O 4 5 6 O O O\n*\t  \t\t\tO O O O O O O O O O O 7 O O O O\n*\t  \t\t\tO O O O O O O O O O O O O O O O\n*\n*\t  \t\t\tThe world runs 10 rounds of updating an ODE between A and B (cell proteins)\n*\t  \t\t\tand checks the levels in the memAgents after this.\n*\n*\t  \t\t\tODE: 1 B -> 1 A every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid MultiNeighbourODEMemAgentTest::SetUp() {\n\t// Setup world container for this test fixture.\n\tauto w_container = new World_Container();\n\taddWorldContainer(w_container);\n\n\t// Setup world for this test fixture - generates 50x50x50 world w/ no objects.\n\tworldContainer->world_setup();\n\tauto world = worldContainer->get_world();\n\taddWorld(world);\n\n\t// Create two uninitialised \"dummy\" cells for use with the MemAgents.\n\tauto dummyCell1 = new EC(world);\n\tauto dummyCell2 = new EC(world);\n\tworld->ECagents.push_back(dummyCell1);\n\tworld->ECagents.push_back(dummyCell2);\n\n\t// Create memAgents and assign them to cells.\n\tcreateMemAgents(dummyCell1, dummyCell2, world);\n\t// Setup agent proteins.\n\tsetupAgentProteins();\n\n\tstd::cout << \"mem1_A,\" << \"mem2_A,\" << \"mem3_A,\"\n\t\t\t  << \"mem1_B,\" << \"mem2_B,\" << \"mem3_B,\"\n\t\t\t  << \"mem4_C,\" << \"mem5_C,\" << \"mem6_C,\" << \"mem7_C,\"\n\t\t\t  << \"mem4_D,\" << \"mem5_D,\" << \"mem6_D,\" << \"mem7_D,\"\n\t\t\t  <<  \"time\\n\";\n\n\tprintMemAgentProteinLevels(0);\n\n\tfor (int i = 0; i < 1; i++) {\n\t\t// Updating is not asynchronous, so update only two memAgents and check that they're .\n\t\trunODE(memAgent2);\n\t\trunODE(memAgent7);\n\t\tprintMemAgentProteinLevels(i + 1);\n\t}\n}\n\nvoid MultiNeighbourODEMemAgentTest::TearDown() {\n\n}\n\nvoid MultiNeighbourODEMemAgentTest::addWorld(World *multiNeighbourWorld) {\n\tthis->world = multiNeighbourWorld;\n}\n\nvoid MultiNeighbourODEMemAgentTest::addWorldContainer(World_Container *multiNeighbourWorldContainer) {\n\tthis->worldContainer = multiNeighbourWorldContainer;\n}\n\nvoid MultiNeighbourODEMemAgentTest::createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world) {\n\t// Scenario 1.\n\tauto *memAgent1 = new MemAgent(dummyCell1, world);\n\tthis->memAgent1 = memAgent1;\n\tmemAgent1->Mx = 19;\n\tmemAgent1->My = 20;\n\tmemAgent1->Mz = 20;\n\tmemAgent1->junction = false;\n\tthis->world->grid[19][20][20].type = const_M;\n\tthis->world->grid[19][20][20].Mids.push_back(memAgent1);\n\n\tauto *memAgent2 = new MemAgent(dummyCell1, world);\n\tthis->memAgent2 = memAgent2;\n\tmemAgent2->Mx = 20;\n\tmemAgent2->My = 20;\n\tmemAgent2->Mz = 20;\n\tmemAgent2->junction = false;\n\tthis->world->grid[20][20][20].type = const_M;\n\tthis->world->grid[20][20][20].Mids.push_back(memAgent2);\n\n\tauto *memAgent3 = new MemAgent(dummyCell1, world);\n\tthis->memAgent3 = memAgent3;\n\tmemAgent3->Mx = 21;\n\tmemAgent3->My = 20;\n\tmemAgent3->Mz = 20;\n\tmemAgent3->junction = false;\n\tthis->world->grid[21][20][20].type = const_M;\n\tthis->world->grid[21][20][20].Mids.push_back(memAgent3);\n\n\t// Scenario 2\n\n\tauto *memAgent4 = new MemAgent(dummyCell1, world);\n\tthis->memAgent4 = memAgent4;\n\tmemAgent4->Mx = 29;\n\tmemAgent4->My = 30;\n\tmemAgent4->Mz = 30;\n\tmemAgent4->junction = true;\n\tthis->world->grid[29][30][30].type = const_M;\n\tthis->world->grid[29][30][30].Mids.push_back(memAgent4);\n\n\tauto *memAgent5 = new MemAgent(dummyCell1, world);\n\tthis->memAgent5 = memAgent5;\n\tmemAgent5->Mx = 30;\n\tmemAgent5->My = 30;\n\tmemAgent5->Mz = 30;\n\tmemAgent5->junction = true;\n\tthis->world->grid[30][30][30].type = const_M;\n\tthis->world->grid[30][30][30].Mids.push_back(memAgent5);\n\n\tauto *memAgent6 = new MemAgent(dummyCell1, world);\n\tthis->memAgent6 = memAgent6;\n\tmemAgent6->Mx = 31;\n\tmemAgent6->My = 30;\n\tmemAgent6->Mz = 30;\n\tmemAgent6->junction = true;\n\tthis->world->grid[31][30][30].type = const_M;\n\tthis->world->grid[31][30][30].Mids.push_back(memAgent6);\n\n\tauto *memAgent7 = new MemAgent(dummyCell2, world);\n\tthis->memAgent7 = memAgent7;\n\tmemAgent7->Mx = 30;\n\tmemAgent7->My = 29;\n\tmemAgent7->Mz = 30;\n\tmemAgent7->junction = true;\n\tthis->world->grid[30][29][30].type = const_M;\n\tthis->world->grid[30][29][30].Mids.push_back(memAgent7);\n}\n\nvoid MultiNeighbourODEMemAgentTest::setupEnvironment() {\n\n}\n\nvoid MultiNeighbourODEMemAgentTest::runODE(MemAgent *memAgent) {\n\tmultiAgent_ode_states ode_states;\n\todeint::euler<multiAgent_ode_states> stepper;\n\n\tode_states[0] = memAgent->get_memAgent_protein_level(\"A\"); // Protein A (Cell Protein) *Uses local value*\n\tode_states[1] = memAgent->get_local_protein_level(\"B\"); // Protein B (Cell Protein) *Uses neighbour's value*\n\tode_states[2] = memAgent->get_memAgent_protein_level(\"C\"); // Protein C (Junctional Protein) *Uses local value*\n\tode_states[3] = memAgent->get_junction_protein_level(\"D\"); // Protein D (Junctional Protein) *Uses neighbour's value*\n\n\tstepper.do_step(MultiAgentODE_system, ode_states, 0.0, 1);\n\n\tmemAgent->set_protein_level(\"A\", ode_states[0]);\n\tmemAgent->set_protein_level(\"C\", ode_states[2]);\n\n\tmemAgent->distribute_calculated_proteins(\"B\", ode_states[1], true); /* Use this cell value */\n\tmemAgent->distribute_calculated_proteins(\"D\", ode_states[3], false); /* Use neighbour's value */\n}\n\nvoid MultiNeighbourODEMemAgentTest::MultiAgentODE_system(const multiAgent_ode_states &x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t multiAgent_ode_states &dxdt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\tdouble C = x[2];\n\tdouble D = x[3];\n\n\tdxdt[0] = +x[1] * 0.5; \t// Rate of change for species A\n\tdxdt[1] = -x[1] * 0.5; \t// Rate of change for species B\n\tdxdt[2] = +x[3] * 0.5; \t// Rate of change for species C\n\tdxdt[3] = -x[3] * 0.5; \t// Rate of change for species B\n}\n\nvoid MultiNeighbourODEMemAgentTest::setupAgentProteins() const {\n\t// Scenario 1\n\tmemAgent1->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent1->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 10, false, 0, 100));\n\n\t// Scenario 2\n\tmemAgent4->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent5->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent6->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent7->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent4->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent5->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent6->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\tmemAgent7->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 10, false, 0, 100));\n\n\t// Set everything else to 0.\n\tmemAgent1->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\tmemAgent1->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\tmemAgent2->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\tmemAgent3->owned_proteins.push_back(new protein(\"D\", PROTEIN_LOCATION_JUNCTION, 0, false, 0, 100));\n\n\tmemAgent4->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent5->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent6->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent7->owned_proteins.push_back(new protein(\"A\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent4->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent5->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent6->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n\tmemAgent7->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_CELL, 0, false, 0, 100));\n}\n\nvoid MultiNeighbourODEMemAgentTest::printMemAgentProteinLevels(int timestep) const {\n\t\t\t  /* Scenario 1 */\n\tstd::cout << memAgent1->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"A\") << \",\"\n\t\t\t  << memAgent1->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent3->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  /* Scenario 2 */\n\t\t\t  << memAgent4->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent5->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent6->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent7->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent4->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << memAgent5->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << memAgent6->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << memAgent7->get_memAgent_protein_level(\"D\") << \",\"\n\t\t\t  << timestep << \"\\n\";\n}\n\n/*****************************************************************************************\n*  Name:\t\tMultiNeighbourODEMemAgentTest::SetUp()\n*  Description: - Creates a world with two memAgents, which each have a certain level of proteins B, C.\n*  \t\t\t\t- Protein A is found in the environment\n*  \t\t\t\t- memAgents 1 & 2 belong to different cells.\n*\n*\t  \t\t\tDiagram:\n*\n*\t  \t\t\t0 0 0 0 0 0 0 0 0 0\n*\t  \t\t\t0 0 0 0 1 2 0 0 0 0\n*\t  \t\t\t0 0 0 0 0 0 0 0 0 0\n*\n*\t  \t\t\tThe world runs 10 rounds of updating an ODE between A and B (cell proteins)\n*\t  \t\t\tand checks the levels in the memAgents after this.\n*\n*\t  \t\t\tODE: 1 A -> 1 B every timestep.\n*\t  \t\t\tODE: 1 B -> 1 C every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid BasicFilODEMemAgentTest::SetUp() {\n\t// Setup world container for this test fixture.\n\tauto w_container = new World_Container();\n\taddWorldContainer(w_container);\n\n\t// Setup world for this test fixture - generates 50x50x50 world w/ no objects.\n\tworldContainer->world_setup();\n\tauto world = worldContainer->get_world();\n\taddWorld(world);\n\n\t// Create two uninitialised \"dummy\" cells for use with the MemAgents.\n\tauto dummyCell1 = new EC(world);\n\tauto dummyCell2 = new EC(world);\n\tworld->ECagents.push_back(dummyCell1);\n\tworld->ECagents.push_back(dummyCell2);\n\n\t//Setup\n\tsetupEnvironment();\n\n\t// Create memAgents and assign them to cells.\n\tcreateMemAgents(dummyCell1, dummyCell2, world);\n\t// Setup agent proteins.\n\tsetupAgentProteins();\n\n\tstd::cout << \"mem1_B,\" << \"mem2_B,\"\n\t\t\t  << \"mem1_C,\" << \"mem2_C,\"\n\t\t\t  <<  \"time\\n\";\n\n\tprintMemAgentProteinLevels(0);\n\n\tfor (int i = 0; i < 1; i++) {\n\t\trunODE(memAgent1);\n\t\trunODE(memAgent2);\n\t\tprintMemAgentProteinLevels(i + 1);\n\t}\n}\n\nvoid BasicFilODEMemAgentTest::TearDown() {\n\n}\n\nvoid BasicFilODEMemAgentTest::addWorld(World *basicFilWorld) {\n\tthis->world = basicFilWorld;\n}\n\nvoid BasicFilODEMemAgentTest::addWorldContainer(World_Container *basicFilWorldContainer) {\n\tthis->worldContainer = basicFilWorldContainer;\n}\n\nvoid BasicFilODEMemAgentTest::createMemAgents(EC *dummyCell1, EC *dummyCell2, World *world) {\n\tauto memAgent1 = new MemAgent(dummyCell1, world);\n\tthis->memAgent1 = memAgent1;\n\tmemAgent1->Mx = 25;\n\tmemAgent1->My = 25;\n\tmemAgent1->Mz = 25;\n\tthis->world->grid[25][25][25].Fids.push_back(memAgent1);\n\n\tauto memAgent2 = new MemAgent(dummyCell2, world);\n\tthis->memAgent2 = memAgent1;\n\tmemAgent2->Mx = 26;\n\tmemAgent2->My = 25;\n\tmemAgent2->Mz = 25;\n\tthis->world->grid[26][25][25].Fids.push_back(memAgent1);\n}\n\nvoid BasicFilODEMemAgentTest::setupEnvironment() {\n\tEnv *ep;\n\tfor (int x = 0; x < world->gridXDimensions; x++) {\n\t\tfor (int y = 0; y < world->gridYDimensions; y++) {\n\t\t\tfor (int z = 0; z < world->gridYDimensions; z++) {\n\t\t\t\tif (world->grid[x][y][z].type == const_E) {\n\t\t\t\t\tauto proteinA = new protein(\"A\", PROTEIN_LOCATION_ENVIRONMENT, 1, false, 0, 100);\n\t\t\t\t\tep = world->grid[x][y][z].Eid;\n\t\t\t\t\tep->owned_proteins.push_back(proteinA);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid BasicFilODEMemAgentTest::runODE(MemAgent *memAgent) {\n\tbasicFil_ode_states ode_states;\n\todeint::euler<basicFil_ode_states> stepper;\n\n\tode_states[0] = memAgent->get_environment_protein_level(\"A\"); // THIS IS FINE.\n\tode_states[1] = memAgent->get_local_protein_level(\"B\") + memAgent->get_filopodia_protein_level(\"B\"); // THIS IS FOR THE REACTANT OF REACTION 2\n\tode_states[2] = memAgent->get_memAgent_protein_level(\"C\"); // THIS IS FINE.\n\n\tstepper.do_step(basicFilODE_system, ode_states, 0.0, 1);\n\n\tmemAgent->set_protein_level(\"B\", ode_states[1]);\n\tmemAgent->set_protein_level(\"C\", ode_states[2]);\n}\n\nvoid BasicFilODEMemAgentTest::basicFilODE_system(const basicFil_ode_states &x, basicFil_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\tdouble C = x[2];\n\n\tdxdt[0] = 0; \t// Rate of change for species A\n\tdxdt[1] = +A -B; \t// Rate of change for species B product\n\tdxdt[2] = +B; \t// Rate of change for species B reactant\n}\n\nvoid BasicFilODEMemAgentTest::setupAgentProteins() const {\n\tthis->memAgent1->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_MEMBRANE, 0, false, 0, 100));\n\tthis->memAgent1->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_MEMBRANE, 0, false, 0, 100));\n\n\tthis->memAgent2->owned_proteins.push_back(new protein(\"B\", PROTEIN_LOCATION_MEMBRANE, 0, false, 0, 100));\n\tthis->memAgent2->owned_proteins.push_back(new protein(\"C\", PROTEIN_LOCATION_MEMBRANE, 0, false, 0, 100));\n}\n\nvoid BasicFilODEMemAgentTest::printMemAgentProteinLevels(int timestep) const {\n\tstd::cout << memAgent1->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"B\") << \",\"\n\t\t\t  << memAgent1->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << memAgent2->get_memAgent_protein_level(\"C\") << \",\"\n\t\t\t  << timestep << \"\\n\";\n}\n/*****************************************************************************************\n*  Name:\t\tBasicCellDistributionTest::SetUp()\n*  Description: - Creates a single, 2D cell in the world. Each timestep, this cell distributes\n*\t\t\t\tout a protein, runs an ODE to reduce the levels at the memAgents by 1. The test\n*\t\t\t\tthen reports the total level of protein each timestep.\n*\n*\t  \t\t\tODE: -1A every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\nvoid BasicCellDistributionTest::SetUp() {\n\tauto w_container = new World_Container();\n\taddWorldContainer(w_container);\n\n\t// Setup world for this test fixture - generates 50x50x50 world w/ no objects.\n\tworldContainer->world_setup();\n\tauto world = worldContainer->get_world();\n\taddWorld(world);\n\tsetupCell();\n\tstd::cout << \"Protein,\" << \"Level,\" << \"Timestep\" << \"\\n\";\n\tprintCellProteinLevels(0);\n\tthis->cell->cell_agent->distribute_proteins();\n}\n\nvoid BasicCellDistributionTest::TearDown() {\n\n}\n\nvoid BasicCellDistributionTest::addWorld(World *basicCellDistributionWorld) {\n\tthis->world = basicCellDistributionWorld;\n}\n\nvoid BasicCellDistributionTest::addWorldContainer(World_Container *basicCellDistributionWorldContainer) {\n\tthis->worldContainer = basicCellDistributionWorldContainer;\n}\n\nvoid BasicCellDistributionTest::setupEnvironment() {\n\n}\n\nvoid BasicCellDistributionTest::setupCell() {\n\tthis->tissueContainer = new Tissue_Container(this->world);\n\n\t// Create a new cell type for our cell, with a total of 25 memAgents.\n\tauto *basicCellShape = new Shape_Square(CELL_SHAPE_SQUARE, 5, 5);\n\tauto *basicCellType = new Cell_Type(this->tissueContainer, \"basicCellType\", basicCellShape);\n\tbasicCellType->add_protein(new protein(\"A\", PROTEIN_LOCATION_CELL, 1000, false, 0, 10000));\n\n\t// Create the cell using the defined tissue container.\n\ttissueContainer->create_cell(\"BasicCell\", basicCellType, new Coordinates(25, 25, 25));\n\tthis->cell = tissueContainer->cells[0];\n\tthis->cell->cell_agent->set_initial_proteins();\n}\n\nvoid BasicCellDistributionTest::runODE(MemAgent *memAgent) {\n\tbasicDistribution_ode_states ode_states;\n\todeint::euler<basicDistribution_ode_states> stepper;\n\n\tode_states[0] = memAgent->get_memAgent_protein_level(\"A\");\n\tstepper.do_step(basicCellDistribution_system, ode_states, 0.0, 1);\n\n\tmemAgent->set_protein_level(\"A\", ode_states[0]);\n}\n\nvoid BasicCellDistributionTest::basicCellDistribution_system(const basicDistribution_ode_states &x, basicDistribution_ode_states &dxdt, double t) {\n\tdouble A = x[0];\n\tdxdt[0] = -1; \t// Rate of change for species A\n}\n\nvoid BasicCellDistributionTest::printCellProteinLevels(int timestep) const {\n\t// Only one cell in this setup.\n\tauto cell = this->cell;\n\tfor (auto protein : cell->m_cell_type->proteins) {\n\t\tstd::cout << protein->get_name() << \",\" << protein->get_level() << \",\";\n\t}\n\tstd::cout << timestep << \"\\n\";\n}\n\n/*****************************************************************************************\n*  Name:\t\tCellJunctionTest::SetUp()\n*  Description: - Creates a monolayer of two cells, and updates an ODE that relies on cross-cell\n*\t\t\t\tcommunication.\n*\t\t\t\t- Also checks that junctional proteins are only distributed to junction memAgents.\n*\n*\t  \t\t\tODE: 1A (from adjacent cell) + 1B (this cell) -> 1AB every timestep.\n*\t  \t\t\tODE: 1AB (this cell) -> 1C (this cell) every timestep.\n*\n*  Returns:\t\tvoid\n******************************************************************************************/\nvoid CellJunctionTest::SetUp() {\n\n}\n\nvoid CellJunctionTest::TearDown() {\n\n}\n\nvoid CellJunctionTest::addWorld(World *cellJunctionWorld) {\n\tthis->world = cellJunctionWorld;\n}\n\nvoid CellJunctionTest::addWorldContainer(World_Container *cellJunctionWorldContainer) {\n\tthis->worldContainer = cellJunctionWorldContainer;\n}\n\nvoid CellJunctionTest::setupEnvironment() {\n\n}\n\nvoid CellJunctionTest::setupCells() {\n\n}\n\nvoid CellJunctionTest::runODE(MemAgent *memAgent) {\n\n}\n/*\n * ODE: 1A (from adjacent cell) + 1B (this cell) -> 1AB every timestep.\n * ODE: 1AB (this cell) -> 1C (this cell) every timestep.\n*/\n\nvoid CellJunctionTest::cellJunction_system(const cellJunction_ode_states &x,\n\t\t\t\t\t\t\t\t\t\t   cellJunction_ode_states &dxdt,\n\t\t\t\t\t\t\t\t\t\t   double t) {\n\tdouble A = x[0];\n\tdouble B = x[1];\n\tdouble AB = x[2];\n\tdouble C = x[3];\n\n\tdxdt[0] = -x[0]; \t// Rate of change for species A\n\tdxdt[1] = -x[1];\t// Rate of change for species B\n\tdxdt[2] = +(x[0] + x[2]) -;\t// Rate of change for species AB\n\tdxdt[3] = +1;\t// Rate of change for species C\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/automated/helper_ODE.cpp b/tests/automated/helper_ODE.cpp
--- a/tests/automated/helper_ODE.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/tests/automated/helper_ODE.cpp	(date 1626715945348)
@@ -777,8 +777,27 @@
 *
 *  Returns:		void
 ******************************************************************************************/
+
 void CellJunctionTest::SetUp() {
+	auto w_container = new World_Container();
+	addWorldContainer(w_container);
 
+	// Setup world for this test fixture - generates 50x50x50 world w/ no objects.
+	worldContainer->world_setup();
+	addWorld(worldContainer->get_world());
+	setupCells();
+	std::cout << "Cell,"
+			  << "Protein_A,"
+			  << "Protein_B,"
+			  << "Protein_AB,"
+			  << "Protein_C,"
+			  << "Level,"
+			  << "Timestep"
+			  << "\n";
+	printCellProteinLevels(0);
+	for (auto cell : tissueMonolayer->m_cell_agents) {
+		cell->distribute_proteins();
+	}
 }
 
 void CellJunctionTest::TearDown() {
@@ -798,12 +817,50 @@
 }
 
 void CellJunctionTest::setupCells() {
+	// Actually sets up a tissue monolayer
+	this->tissueContainer = new Tissue_Container(this->world);
+
+	// Create a new cell type for our cell, with a total of 25 memAgents.
+	auto *basicCellShape = new Shape_Square(CELL_SHAPE_SQUARE, 5, 5);
+	auto *basicCellType = new Cell_Type(this->tissueContainer, "basicCellType", basicCellShape);
 
+	basicCellType->add_protein(new protein("A", PROTEIN_LOCATION_JUNCTION, 1000, false, 0, 10000));
+	basicCellType->add_protein(new protein("B", PROTEIN_LOCATION_JUNCTION, 1000, false, 0, 10000));
+	basicCellType->add_protein(new protein("AB", PROTEIN_LOCATION_CELL, 0, false, 0, 10000));
+	basicCellType->add_protein(new protein("C", PROTEIN_LOCATION_CELL, 0, false, 0, 10000));
+
+	auto *basicTissueType = new Tissue_Type_Flat(this->tissueContainer,"basicTissueType", basicCellType, CELL_CONFIGURATION_FLAT, 1, 2);
+	// Create the tissue using the defined tissue container.
+	this->tissueContainer->create_tissue("basicTissue", basicTissueType, new Coordinates(25, 25, 25));
+	this->tissueMonolayer = dynamic_cast<Tissue_Monolayer *>(tissueContainer->tissues[0]);
+
+	// Force add the proteins to the memAgents and check whether they're at a junction.
+	// TODO: ASK KATIE ABOUT WHETHER MEMAGENTS ARE DEFINED AS JUNCTIONAL OR NOT.
+	for (auto cell : this->tissueMonolayer->m_cell_agents) {
+		for (auto memAgent : cell->nodeAgents) {
+			memAgent->add_cell_proteins();
+			memAgent->JunctionTest(true);
+		}
+	}
 }
 
 void CellJunctionTest::runODE(MemAgent *memAgent) {
+	cellJunction_ode_states ode_states;
+	odeint::euler<cellJunction_ode_states> stepper;
+
+	ode_states[0] = memAgent->get_local_protein_level("A");
+	ode_states[1] = memAgent->get_junction_protein_level("B");
+	ode_states[2] = memAgent->get_local_protein_level("AB");
+	ode_states[3] = memAgent->get_local_protein_level("C");
 
+	stepper.do_step(cellJunction_system, ode_states, 0.0, 1);
+
+	memAgent->distribute_calculated_proteins("A", ode_states[0], false);
+	memAgent->distribute_calculated_proteins("B", ode_states[1], false);
+	memAgent->distribute_calculated_proteins("AB", ode_states[2], false);
+	memAgent->distribute_calculated_proteins("C", ode_states[3], false);
 }
+
 /*
  * ODE: 1A (from adjacent cell) + 1B (this cell) -> 1AB every timestep.
  * ODE: 1AB (this cell) -> 1C (this cell) every timestep.
@@ -819,7 +876,18 @@
 
 	dxdt[0] = -x[0]; 	// Rate of change for species A
 	dxdt[1] = -x[1];	// Rate of change for species B
-	dxdt[2] = +(x[0] + x[2]) -;	// Rate of change for species AB
-	dxdt[3] = +1;	// Rate of change for species C
+	dxdt[2] = +(x[0] + x[1]) -x[2]*0.5;	// Rate of change for species AB
+	dxdt[3] = +x[2] * 0.5;	// Rate of change for species C
+}
+
+void CellJunctionTest::printCellProteinLevels(int timestep) const {
+	auto tissue = this->tissueMonolayer;
+	for (auto cell : tissue->m_cell_agents) {
+		std::cout << cell->cell_number << ",";
+		for (auto protein : cell->m_cell_type->proteins) {
+			std::cout << protein->get_level() << ",";
+		}
+		std::cout << timestep << "\n";
+	}
 }
 
Index: cmake-build-debug/Testing/Temporary/LastTest.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Start testing: Jul 19 12:22 BST\n----------------------------------------------------------\nEnd testing: Jul 19 12:22 BST\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-build-debug/Testing/Temporary/LastTest.log b/cmake-build-debug/Testing/Temporary/LastTest.log
--- a/cmake-build-debug/Testing/Temporary/LastTest.log	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/cmake-build-debug/Testing/Temporary/LastTest.log	(date 1626716433274)
@@ -1,3 +1,3 @@
-Start testing: Jul 19 12:22 BST
+Start testing: Jul 19 18:40 BST
 ----------------------------------------------------------
-End testing: Jul 19 12:22 BST
+End testing: Jul 19 18:40 BST
Index: cmake-build-debug/autoSpringAgent[1]_tests.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>add_test( HelloTest.CheckGoogleTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=HelloTest.CheckGoogleTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( HelloTest.CheckGoogleTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( test_ODE.ODEConstantRate /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=test_ODE.ODEConstantRate]==] --gtest_also_run_disabled_tests)\nset_tests_properties( test_ODE.ODEConstantRate PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( test_ODE.multi_ODEConstantRate /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=test_ODE.multi_ODEConstantRate]==] --gtest_also_run_disabled_tests)\nset_tests_properties( test_ODE.multi_ODEConstantRate PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( test_ODE.ODELinearRate /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=test_ODE.ODELinearRate]==] --gtest_also_run_disabled_tests)\nset_tests_properties( test_ODE.ODELinearRate PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( BasicODEMemAgentTest.environmentCheckTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicODEMemAgentTest.environmentCheckTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( BasicODEMemAgentTest.environmentCheckTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( BasicODEMemAgentTest.memAgentTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicODEMemAgentTest.memAgentTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( BasicODEMemAgentTest.memAgentTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( CrossCellODEMemAgentTest.cellODETest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=CrossCellODEMemAgentTest.cellODETest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( CrossCellODEMemAgentTest.cellODETest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( CrossCellODEMemAgentTest.junctionODETest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=CrossCellODEMemAgentTest.junctionODETest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( CrossCellODEMemAgentTest.junctionODETest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( MultiNeighbourODEMemAgentTest.cellODETest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=MultiNeighbourODEMemAgentTest.cellODETest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( MultiNeighbourODEMemAgentTest.cellODETest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( BasicFilODEMemAgentTest.basicFilTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicFilODEMemAgentTest.basicFilTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( BasicFilODEMemAgentTest.basicFilTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( BasicCellDistributionTest.preDistributionTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicCellDistributionTest.preDistributionTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( BasicCellDistributionTest.preDistributionTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nadd_test( BasicCellDistributionTest.postDistributionTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicCellDistributionTest.postDistributionTest]==] --gtest_also_run_disabled_tests)\nset_tests_properties( BasicCellDistributionTest.postDistributionTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)\nset( autoSpringAgent_TESTS HelloTest.CheckGoogleTest test_ODE.ODEConstantRate test_ODE.multi_ODEConstantRate test_ODE.ODELinearRate BasicODEMemAgentTest.environmentCheckTest BasicODEMemAgentTest.memAgentTest CrossCellODEMemAgentTest.cellODETest CrossCellODEMemAgentTest.junctionODETest MultiNeighbourODEMemAgentTest.cellODETest BasicFilODEMemAgentTest.basicFilTest BasicCellDistributionTest.preDistributionTest BasicCellDistributionTest.postDistributionTest)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-build-debug/autoSpringAgent[1]_tests.cmake b/cmake-build-debug/autoSpringAgent[1]_tests.cmake
--- a/cmake-build-debug/autoSpringAgent[1]_tests.cmake	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/cmake-build-debug/autoSpringAgent[1]_tests.cmake	(date 1626715951215)
@@ -22,4 +22,6 @@
 set_tests_properties( BasicCellDistributionTest.preDistributionTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)
 add_test( BasicCellDistributionTest.postDistributionTest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=BasicCellDistributionTest.postDistributionTest]==] --gtest_also_run_disabled_tests)
 set_tests_properties( BasicCellDistributionTest.postDistributionTest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)
-set( autoSpringAgent_TESTS HelloTest.CheckGoogleTest test_ODE.ODEConstantRate test_ODE.multi_ODEConstantRate test_ODE.ODELinearRate BasicODEMemAgentTest.environmentCheckTest BasicODEMemAgentTest.memAgentTest CrossCellODEMemAgentTest.cellODETest CrossCellODEMemAgentTest.junctionODETest MultiNeighbourODEMemAgentTest.cellODETest BasicFilODEMemAgentTest.basicFilTest BasicCellDistributionTest.preDistributionTest BasicCellDistributionTest.postDistributionTest)
+add_test( CellJunctionTest.crossJunctionODETest /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug/autoSpringAgent [==[--gtest_filter=CellJunctionTest.crossJunctionODETest]==] --gtest_also_run_disabled_tests)
+set_tests_properties( CellJunctionTest.crossJunctionODETest PROPERTIES WORKING_DIRECTORY /Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/cmake-build-debug)
+set( autoSpringAgent_TESTS HelloTest.CheckGoogleTest test_ODE.ODEConstantRate test_ODE.multi_ODEConstantRate test_ODE.ODELinearRate BasicODEMemAgentTest.environmentCheckTest BasicODEMemAgentTest.memAgentTest CrossCellODEMemAgentTest.cellODETest CrossCellODEMemAgentTest.junctionODETest MultiNeighbourODEMemAgentTest.cellODETest BasicFilODEMemAgentTest.basicFilTest BasicCellDistributionTest.preDistributionTest BasicCellDistributionTest.postDistributionTest CellJunctionTest.crossJunctionODETest)
Index: src/memAgents.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <math.h>\n\n#include \"objects.h\"\n#include \"memAgents.h\"\n#include \"environment.h\"\n#include \"EC.h\"\n#include \"utils.h\"\n\n\nfloat steps = 0.5f;\n\nint right1 = 0;\nint left1 = 0;\nint right2 = 0;\nint left2 = 0;\nint middle = 0;\nint count3 = 0;\n\nfloat overallVEGF = 0.0f;\nint overallflag = 0;\nint Dolaycount = 0;\n//----------------------------------------------------------------------------------\n/**\n *\n * This is needed to tell if triangle positions have changed when \n * on the fly surface agent coverage flag is switched ON (quick calculatoin of voxelisatoin though incomplete and shouldnt be used durnig real simulations, only in development to see faster, then retest with on the fly surface OFF to ensure full surface created.\n */\nvoid MemAgent::store_previous_triangle_pos(void) {\n    if ((node == true) && ((FIL == NONE) || (FIL == BASE))) {\n        previous.x = Mx;\n        previous.y = My;\n        previous.z = Mz;\n    }\n}\n//----------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n/**\n * \n * Calculate memAgents Notch receptor activation from local Dll4 ligands seen in grid\n */\nvoid MemAgent::NotchResponse(void) {\n\n    int i = 0;\n    int j;\n    int flag = 0;\n\n    do {\n        if (worldP->neigh[i].type == const_M) {\n            for (j = 0; j < (int) worldP->neigh[i].Mids.size(); j++) {\n                if (flag == 0) {\n                    if (worldP->neigh[i].Mids[j]->Cell != Cell) {\n                        //if more than number of notch receptors  only take amount needed to activate notches\n                        if (worldP->neigh[i].Mids[j]->Dll4 > Notch1) {\n                            worldP->neigh[i].Mids[j]->Dll4 -= Notch1;\n                            activeNotch = activeNotch + Notch1;\n                            Notch1 = 0.0f;\n                            flag = 1;\n\n                        }//take all of it if less than it has notch receptors\n                        else {\n                            Notch1 = Notch1 - worldP->neigh[i].Mids[j]->Dll4;\n                            activeNotch = activeNotch + worldP->neigh[i].Mids[j]->Dll4;\n                            worldP->neigh[i].Mids[j]->Dll4 = 0.0f;\n                        }\n                    }\n                }\n            }\n        }\n\n        i++;\n\n    } while ((flag == 0) && (i < NEIGH));\n\n}\n\n//------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------\n/**\n * \n * only used for TIP memAgents (at the tip of a filopodium) to calculate length of current filopodium from spring lengths of all springs in this fil.\n * \n * filNeigh refers to the node agent one the other end of the current filopdia spring being measured.\n * \n *\n * @param type\n * @return float\n */\nfloat MemAgent::FilLength(int type) {\n\n    int score = 0;\n    MemAgent* Mcurrent;\n    float length = 0.0f;\n\n\tstd::vector <MemAgent*> stored;\n\n    if (type == BASE) Mcurrent = plusSite;\n\n    else Mcurrent = this;\n\n    if (Mcurrent != NULL) {\n        do {\n            //score++;\n            if (type == TIP) {\n                stored.push_back(Mcurrent);\n                if (Mcurrent->Mx - Mcurrent->filNeigh->Mx >= (float) this->worldP->gridXDimensions / 2.0f)\n                    length += worldP->getDist(Mcurrent->Mx - this->worldP->gridXDimensions, Mcurrent->My, Mcurrent->Mz, Mcurrent->filNeigh->Mx, Mcurrent->filNeigh->My, Mcurrent->filNeigh->Mz);\n                else if (Mcurrent->filNeigh->Mx - Mcurrent->Mx >= (float) this->worldP->gridXDimensions / 2.0f)\n                    length += worldP->getDist(Mcurrent->Mx, Mcurrent->My, Mcurrent->Mz, Mcurrent->filNeigh->Mx - this->worldP->gridXDimensions, Mcurrent->filNeigh->My, Mcurrent->filNeigh->Mz);\n                else\n                    length += worldP->getDist(Mcurrent->Mx, Mcurrent->My, Mcurrent->Mz, Mcurrent->filNeigh->Mx, Mcurrent->filNeigh->My, Mcurrent->filNeigh->Mz);\n                Mcurrent = Mcurrent->filNeigh;\n            } else if (type == BASE) Mcurrent = Mcurrent->plusSite;\n\n        } while (Mcurrent->FIL != BASE);\n    }\n\n    return (length);\n}\n//----------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n/**\n * When a memAgent at the tip of a filopodium (FIL=TIP) touches another cells filopodium it triggers both fils nodeAgents to lose all their focal adhesions (FAs) and advance the veil.\n * \n */\nvoid MemAgent::veilAdvance(void) {\n\n    int flag = 0;\n    int i;\n    MemAgent* currentNode;\n    MemAgent* nextNode;\n    \n    int count = 0;\n    //go back through connected spring nodes and release their FAs\n    currentNode = filNeigh;\n\n    do {\n\n        if (currentNode->FIL != BASE) {\n            count++;\n            currentNode->FA = false;\n            currentNode->SpringNeigh[0]->veilAdvancing = true; \n            /** \n             * important to flag as veil advancing here so that newNodes() doesnt insert a new node in the middle of the spring when it goes over threshold legnth for an adhesion node as per filopodia extension*/\n            nextNode = currentNode->filNeigh;\n            currentNode = nextNode;\n        } else if (count > 0) {\n            flag = 1;\n            for (i = 0; i < currentNode->neighs; i++)\n                if (currentNode->SpringNeigh[i]->filopodia == true) {\n                    currentNode->SpringNeigh[i]->veilAdvancing = true;\n                }\n            currentNode->veilAdvancing = true;\n        } else flag = 1;\n\n        if (currentNode->FIL == BASE)currentNode->veilAdvancing = true;\n\n\n    } while (flag == 0);\n\n\n}\n//----------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n/**\n * Retract filopodium\n * \n * @return bool retracted\n */\nbool MemAgent::filRetract(void) {\n\n    int flag = 0;\n    int i, k;\n    float B, D;\n    int FLAG = 0;\n\n\tstd::vector<Spring*>::iterator Q;\n\tstd::vector<MemAgent*>::iterator L;\n    Spring* neighStp;\n    int XA;\n    float length;\n    MemAgent* memp;\n\tstd::vector<MemAgent*>::iterator T;\n\n    ///release this memAgents adhesion (FIL=TIP for this node) \n    FA = false;\n    ///flag it for deletion, which will also stop it being assessed in any further update functions e.g. receptor activation\n    deleteFlag = true;\n\n    ///locate its nearest nodeAgent back in the fil then calculate length of its spring.\n    MemAgent* mp = filNeigh;\n\n    XA = (int) Mx - (int) mp->Mx;\n    B = (int) My - (int) mp->My;\n    D = (int) Mz - (int) mp->Mz;\n\n    //toroidal adjustments\n    if(TOROIDAL_X){\n    if (sqrt(XA * XA) >= (int) ((float) this->worldP->gridXDimensions / 2.0f)) {\n\n        if (XA > 0) XA = -(this->worldP->gridXDimensions - XA);\n        else XA = this->worldP->gridXDimensions - abs(XA);\n        length = sqrt((XA * XA)+(B * B)+(D * D));\n\n    } else {\n        length = worldP->getDist(Mx, My, Mz, mp->Mx, mp->My, mp->Mz);\n    }\n    }\n    else {\n        length = worldP->getDist(Mx, My, Mz, mp->Mx, mp->My, mp->Mz);\n    }\n\n    ///if its spring length>1 (so nodeAgents either end of spring are not nearest neighbours in grid, return flase and stop function. It will reassess next timestep after the spring has retracted further\n    if ((int) length > 1) {\n\n        return (false);\n    }\n    ///else, the current tip has retracted the spring back to the node agents adhered at the other end of the current spring\n    else {\n        i = 0;\n        flag = 0;\n        this->Cell->filopodiaRetractions.push_back(std::array<int, 3>{ (int)mp->Mx, (int)mp->My, (int)mp->Mz });\n        ///update current actin usage by minusing the current length of the spring from cells list, as this spring is now going to be deleted\n         Cell->actinUsed -= length;\n         \n         ///if the nodeAgent at the other end of the spring is the BASE of the filopodium then reset it to NONE state and delete all springs and agents associated\n        if (mp->FIL == BASE) {\n            \n            mp->FIL = NONE;\n            \n            ///if vessel is blindended dont release adhesion, otherwise do. keeps it fixed and sewn up at front of sprout in this setup\n            ///releasing adhesion keeps cell brod moving freely, filopida adheisn can root it stuck while they exist\n            if(BLINDENDED_SPROUT==true){\n                if(mp->labelledBlindended!=true) mp->FA=false;\n            }\n            //else mp->FA=false;\n            \n            //send the actin back to the filNeigh as tipnode to be deleted\n            mp->filTokens += filTokens;\n            \n            //ANALYSIS of filopodia can be done here\n            if (ANALYSIS_contactsTest == true) {\n                mp->base_fil_belong->time_retract_complete = worldP->timeStep;\n                mp->base_fil_belong->retracted = true;\n                mp->base_fil_belong = NULL;\n            }\n\n            //the BASE->NONE state returns to not veiladvancing state incase it had been previously advancing\n            mp->veilAdvancing = false; \n            \n            //find where this spring is listed in each memAgent and remove\n            for (i = 0; i < mp->neighs; i++) {\n\n                if (mp->neigh[i] == this) {\n\n                    neighStp = mp->SpringNeigh[i];\n                    mp->neigh[i] = NULL;\n                    mp->SpringNeigh[i] = NULL;\n\n                    FLAG = 1;\n                }\n                if ((FLAG == 1) && (mp->neighs > i + 1)) {\n                    mp->neigh[i] = mp->neigh[i + 1];\n                    mp->SpringNeigh[i] = mp->SpringNeigh[i + 1];\n                    mp->neigh[i + 1] = NULL;\n                    mp->SpringNeigh[i + 1] = NULL;\n                }\n            }\n\n            mp->neighs--;\n        } else {\n           ///if filNeigh !=BASE then it is a stalk node within the filopodium. so just rename it the new current tip and delete the old tipnode\n            mp->FIL = TIP;\n            //set its filtip timer so that it will be retracted in this same way on next assessment\n            mp->filTipTimer = FILTIPMAX + 1;\n            neighStp = mp->SpringNeigh[0];\n            mp->neigh[0] = NULL;\n            mp->SpringNeigh[0] = NULL;\n            mp->neighs = 0;\n            //flag as deleted so dont assess receptors etc. \n            mp->deleteFlag = true;\n//pass down tipnodes actin to this new tip as the old will be deleted\n            mp->filTokens += filTokens;\n\n        }\n\n        mp->plusSite = NULL;\n\n        //remove the spring from list\n        i = 0;\n        flag = 0;\n        do {\n\n            if (Cell->Springs[i] == neighStp) {\n                flag = 1;\n                Q = Cell->Springs.begin();\n                Cell->Springs.erase(Q + i);\n                i--;\n            }\n            i++;\n\n        } while ((i < (int) Cell->Springs.size()) && (flag == 0));\n        if (flag == 0) {\n\t\t\tstd::cout << \"filRetract: hasnt found spring in list\" << std::endl;\n\t\t\tstd::cout.flush();\n        }\n\n        //remove the tip node from cells list\n        i = 0;\n        flag = 0;\n        do {\n\n            if (Cell->nodeAgents[i] == this) {\n                flag = 1;\n                L = Cell->nodeAgents.begin();\n                Cell->nodeAgents.erase(L + i);\n            }\n            i++;\n        } while ((i < (int) Cell->nodeAgents.size()) && (flag == 0));\n        if (flag == 0) {\n\t\t\tstd::cout << \"filRetract: hasnt found in node list\" << std::endl;\n\t\t\tstd::cout.flush();\n        }\n\n        //need to go through and remove springAgents from grid, though really shouldnt have any as its less than 1 distance. just to be sure...-------------------\n        //delete old grid ref\n        if (neighStp->agents.size() > 0) {\n\n            for (i = 0; i < (int) neighStp->agents.size(); i++) {\n                memp = neighStp->agents[i];\n                worldP->deleteOldGridRef(memp, true);\n                memp->deleteFlag = true;\n\n                if (memp->assessed == true) {\n                    k = 0;\n                    flag = 0;\n                    do {\n\n                        if (memp->Cell->springAgents[k] == memp) {\n                            flag = 1;\n                            L = memp->Cell->springAgents.begin();\n                            memp->Cell->springAgents.erase(L + k);\n                        }\n                        k++;\n                    } while ((k < (int) memp->Cell->springAgents.size()) && (flag == 0));\n                    if (flag == 0) {\n\t\t\t\t\t\tstd::cout << \"deleting spring agent in main: hasnt found in list\" << std::endl;\n\t\t\t\t\t\tstd::cout.flush();\n                    }\n                    delete memp;\n                }\n            }\n        }\n        \n\n        delete neighStp;\n        return (true);\n    }\n\n}\n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n/**\n * Used in TokenTrading to allocate actin to nearby node if current agent is a surface node, which are unable to extend filopodia themselves\n * @return MemAgent* to nearest node in surface triangle\n */\nMemAgent* MemAgent::find_nearest_triangle_node(void) {\n\n    int dist1, dist2, dist3;\n\n    MemAgent* nearest;\n\n    if (fabs(Mx - triangle[0]->Mx) >= (float) worldP->gridXDimensions / 2.0f) {\n        if (Mx > triangle[0]->Mx) dist1 = worldP->getDist(Mx - worldP->gridXDimensions, My, Mz, triangle[0]->Mx, triangle[0]->My, triangle[0]->Mz);\n        else dist1 = worldP->getDist(Mx, My, Mz, triangle[0]->Mx - worldP->gridXDimensions, triangle[0]->My, triangle[0]->Mz);\n    } else dist1 = worldP->getDist(Mx, My, Mz, triangle[0]->Mx, triangle[0]->My, triangle[0]->Mz);\n\n    if (fabs(Mx - triangle[1]->Mx) >= (float) worldP->gridXDimensions / 2.0f) {\n        if (Mx > triangle[1]->Mx) dist2 = worldP->getDist(Mx - worldP->gridXDimensions, My, Mz, triangle[1]->Mx, triangle[1]->My, triangle[1]->Mz);\n        else dist2 = worldP->getDist(Mx, My, Mz, triangle[1]->Mx - worldP->gridXDimensions, triangle[1]->My, triangle[1]->Mz);\n    } else dist2 = worldP-> getDist(Mx, My, Mz, triangle[1]->Mx, triangle[1]->My, triangle[1]->Mz);\n\n    if (fabs(Mx - triangle[2]->Mx) >= (float) worldP->gridXDimensions / 2.0f) {\n        if (Mx > triangle[2]->Mx) dist3 = worldP->getDist(Mx - worldP->gridXDimensions, My, Mz, triangle[2]->Mx, triangle[2]->My, triangle[2]->Mz);\n        else dist3 = worldP->getDist(Mx, My, Mz, triangle[2]->Mx - worldP->gridXDimensions, triangle[2]->My, triangle[2]->Mz);\n    } else dist3 = worldP->getDist(Mx, My, Mz, triangle[2]->Mx, triangle[2]->My, triangle[2]->Mz);\n\n    if ((dist1 <= dist2) && (dist1 <= dist3)) nearest = triangle[0];\n    else if ((dist2 <= dist1) && (dist2 <= dist3))nearest = triangle[1];\n    else if ((dist3 <= dist2) && (dist3 <= dist1))nearest = triangle[2];\n    else std::cout << \"cant find a nearest triangle node!\" << std::endl;\n\n    return (nearest);\n\n}\n//---------------------------------------------------------------------------------------------\n//--------------------\nvoid MemAgent:: TokenTrading(void){\n    //older version of actinFlow used in original papers.\n    int flag=0;\n    MemAgent* nearest;\n    \n    //int diffFlag=0;\n    //int i=0;\n    //int chose;\n    \n    //lose old tokens------------------------\n    if(VRinactiveCounter>TokDisRate){\n        filTokens=0;\n        flag=1;\n        VRinactiveCounter=0;\n        //cout<<\"deactivated!\"<<endl;\n        \n    }\n    //if in a stalk and hemmed in all around so doesnt activate much then will stop passing others tokens up.. - although it will for a while, one timer is reset.\n    //----------------------------------------\n    \n    if(flag==0){\n        \n        //pass tokens up filopodia\n        if((FIL==STALK)||(FIL==BASE)){\n            if(plusSite==NULL){\n                //cout<<\"no plusSite\"; cout.flush();\n            }\n            else{\n                \n                plusSite->filTokens+=filTokens;\n                filTokens=0;\n                \n                \n            }\n        }\n        else if((triangle.size()!=0)&&(filTokens>0)){\n            //pick nearest node in triangle to give tokens to.\n            \n            nearest = find_nearest_triangle_node();\n            nearest->filTokens+=filTokens;\n            filTokens=0;\n            \n        }\n        \n        \n    }\n    \n}\n////---------------------------------------------------------------------------------------------\n/**\n * move actin up filopodia to the tip and also from surface agents to their nearest node agent as they cant extend their own filopdium, only nodeAgents can\n */\nvoid MemAgent::ActinFlow(void) {\n\n    int flag = 0;\n    MemAgent* nearest;\n\n\n    //lose all actin tokens (opposite of recruitment also simplified degradation) if VEGFR-2 receptors havent activated for a while------------------------\n    if (VRinactiveCounter > TokDisRate) {\n        filTokens = 0;\n        flag = 1;\n        VRinactiveCounter = 0;\n        //cout<<\"deactivated!\"<<endl;\n\n    }\n    //!WORTH BUG TESTING!if in a stalk and hemmed in all around so doesnt activate much then will stop passing others tokens up.. - although it will for a while, one timer is reset.\n    //----------------------------------------\n\n    if (flag == 0) {\n\n        //pass tokens up filopodia towards tipnode\n        if ((FIL == STALK) || (FIL == BASE)) {\n            if (plusSite == NULL) {\n\t\t\t\tstd::cout<<\"no plusSite_BUG DETECTED in memAgents.cpp line 429\"; std::cout.flush(); ///!WORTH BUG TESTING! if this shows up then plusSite is not labelling correctly\n            } else {\n\n                plusSite->filTokens += filTokens;\n                filTokens = 0;\n\n\n            }\n        } else if ((triangle.size() != 0) && (filTokens > 0)) {\n            ///!WORTH BUG TESTING! is this def sending all surface agents accumulated actin around? and not any tipnodes in filopodia? Prob ok, but worth a recheck\n            ///pick nearest node in triangle to give tokens to if a surface agent (which should have triangle.size()!=0\n\n            nearest = find_nearest_triangle_node();\n            nearest->filTokens += filTokens;\n            filTokens = 0;\n\n        }\n\n\n    }\n\n}\n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n/**\n * \n * this function will inhibit filopodia existing with  radius N of another filopodia\n * N = 1 for CELL_SETUP 2 (as corases grid and smaller cells. Also for CELL_SETUP = 1 when ENV  =1 (2D) as fils nedd to line up closer to get some in the thin astrocyte sections\n * N=4 with CELL SETUP 1 and Env 3D VEGF as fils can then grow all over the cell.. \n * !WORTH A BUG TEST! N prob doesnt actually matter now, could set for =1 under all conditions as actinMAX keeps fils in check.. but test properly to be sure.\n * @param x position\n * @param y position\n * @param z position\n * @param N radius\n */\nvoid MemAgent::tryActinPassRadiusN(int x, int y, int z, int N) {\n    int i, j, k, X, Y, Z, m;\n    int flag = 0;\n    int flag2 = 0;\n    //checks the cube of neighbours surrounding a point - rather than the sphere of neighs\n\n    X = x - N;\n    Y = y - N;\n    Z = z - N;\n\n    for (i = X; i <= X + (2 * N); i++) {\n        for (j = Y; j <= Y + (2 * N); j++) {\n            for (k = Z; k <= Z + (2 * N); k++) {\n                if (flag == 0) {\n\n                    if (worldP->insideWorld(i, j, k) == true) {\n                        if (worldP->grid[i][j][k].type == const_M) {\n                            for (m = 0; m < worldP->grid[i][j][k].Mids.size(); m++) {\n                                if (flag2 == 0) {\n                                    if ((worldP->grid[i][j][k].Mids[m]->FIL != NONE) && (worldP->grid[i][j][k].Mids[m]->Cell == Cell)) {\n                                        ///only passes one token as called in VEGFR response when only one new one has been allocated\n                                        worldP->grid[i][j][k].Mids[m]->filTokens++; \n                                        filTokens--;\n                                        flag2 = 1;\n\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n}\n//---------------------------------------------------------------------------------------------\n\n/**\n * \n * checks if agent has a face (not vertice) exposed to the environment, so that if membrane is densely ruffled and amemAgent is blocked in it wont be ableot activate its receptors via just a corner exposure to the environment. \n * thus function is important for alterations in coarseness of the grid and different geometries for intialising cells on - to match same receptor activity behaviour incase the voxelisation of the mesh happens to be more ruffled. \n * !WORTH BUG TESTING! is this bit robust, especially when switching between config template CELL_SETUPS. test output of receptors overall with and without it. clarify in documentation\n * @return true/false\n */\nbool MemAgent::checkNeighsVonForEnv(void) {\n    //von neumann neighbourhood used\n\n    int x = 0;\n    int flag = 0;\n    int m, n, p;\n    float sumV = 0;\n    int i, j, k;\n    i = Mx;\n    j = My;\n    k = Mz;\n    //same layer\n    do {\n        if (x == 0) {\n            m = i;\n            n = j + 1;\n            p = k;\n        } else if (x == 1) {\n            m = i;\n            n = j - 1;\n            p = k;\n        } else if (x == 2) {\n            m = i + 1;\n            n = j;\n            p = k;\n        } else if (x == 3) {\n            m = i;\n            n = j;\n            p = k + 1;\n        } else if (x == 4) {\n            m = i;\n            n = j;\n            p = k - 1;\n        } else if (x == 5) {\n            m = i - 1;\n            n = j;\n            p = k;\n        }\n\n\n        //-------------------------------\n        //toroidal only X\n        if(TOROIDAL_X_env==true){\n        \tif (m >= this->worldP->gridXDimensions)\n        \t\tm = 0;\n        \tif (m < 0)\n        \t\tm = this->worldP->gridXDimensions - 1;\n        }\n        if (worldP->insideWorld(m, n, p) == true) {\n            if (worldP->grid[m][n][p].type == const_E) {\n                \n                flag = 1;\n            } else if ((worldP->grid[m][n][p].type == const_E)&&(worldP->grid[m][n][p].Eid->Astro==true)) {\n                flag = 1;\n            }\n        }\n        \n        x++;\n    } while ((x < 6) && (flag == 0));\n\n    if (flag == 1) return true;\n    else {\n       \n        return false;\n\n    }\n   \n\n}\n//-----------------------------------\n//------------------------------------------------------------------------------\n/**\n * \n * main VEGFR activation function (applies VEGFR-1 as a simple sink parameter taking away VEGF from VEGFR-2\n */\nvoid MemAgent::VEGFRresponse(void) {\n\n    float Prob, chance;\n\n    int upto = Cell->VonNeighs; \n    float VEGFRactiveProp;\n    int i, j, k;\n    i = (int) Mx;\n    j = (int) My;\n    k = (int) Mz;\n    bool moved = false;\n   \n    //calculate the active VEGFR level as a function of VEGFR-2, VEGFR1 level and vEGF.. \n    VEGFRactiveProp = (VEGFR / ((float) VEGFRNORM / (float) upto));\n    VEGFRactive = (SumVEGF / Cell->Vsink) * VEGFRactiveProp;\n\n    //done exceed max level\n    if (VEGFRactive > VEGFR) {\n        VEGFRactive = VEGFR;\n    }\n\n    //calculate probability of extending a filopdium as a function of VEGFR activity, if no filopodia needed set to 0\n    if (FILOPODIA == true){\n    \t//***** RANDFIL here\n    \tif (randFilExtend >= 0 && randFilExtend <= 1) {\n\t\t\tProb = randFilExtend; //0-1 continuous value input at runtime. if randFil!=-1 - token Strength forced to 0, and epsilon forced to 0.0 (fully random direction and extension, no bias from VR->actin or VR gradient to direction.\n\t\t} else {\n\t\t\tProb = ((float) VEGFRactive / ((float) Cell->VEGFRnorm / (float) upto)) * Cell->filCONST;\n\t\t}\n        //else Prob = ((float) VEGFRactive / (((float) VEGFRnorm/2.0f) / (float) upto)) * Cell->filCONST;\n    } else {\n\t\tProb = 0;\n\t}\n\n    //chance = (float) rand() / (float) RAND_MAX;\n    chance = (float) new_rand() / (float) NEW_RAND_MAX;\n\n    //-----------------------------------------------------------------------\n    if (chance < Prob) {\n    \n        //award actin tokens\n\n        filTokens++;\n\n        if (FIL == NONE)\n        \ttryActinPassRadiusN((int) Mx, (int) My, (int) Mz, FIL_SPACING);\n\n        if (oldVersion == true) {\n            if (FIL == STALK) {\n                //passes its filExtend token to Magent in its plusSite\n                plusSite->filTokens++;\n                filTokens--;\n            }\n        }\n\n        //--------------------------------------------------------------------------------------------\n        //filopodia extension\n        if (((FIL == TIP) || (FIL == NONE)) && (filTokens >= tokenStrength)) {\n            if (deleteFlag == false)\n            \tmoved = extendFil();\n        }\n        //--------------------------------------------------------------------------------------------\n\n        //reset VRinactive counter as now activated\n        VRinactiveCounter = 0;\n\n    } else VRinactiveCounter++;\n\n    if (moved == false)\n    \tfilTipTimer++;\n    else filTipTimer = 0;\n\n\n}\n//----------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------------\n\nvoid MemAgent::calcForce(void) {\n\n    int i, k, T;\n    float denom, length;\n    float sumDN[3];\n    int upto = meshNeighs + 5;\n    int DONE = 0;\n    float newX, newY, newZ;\n    float SL = 0;\n    float sConst = 0;\n\n    int flagFil = 0;\n    float oldDist, newDist;\n    float PN[upto][3];\n    float SN[upto][3];\n    float DN[upto][3];\n\n\n    for (k = 0; k < 3; k++) Force[k] = 0;\n    for (k = 0; k < 3; k++) sumDN[k] = 0.0f;\n\n    //have different lengths and constants for different types of spring\n    if ((FIL == TIP)&&(FA==false)) {\n\n        sConst = filSpringConstant;\n        SL = filSpringLength;\n    }\n    //calculate new force by summing neighbour vectors minused from current point PN1, PN2... then calculate the projection of S onto spring direction and get the difference, then \t\t  sum the elongated regions of each and times by k constant.n\n\n    SL = springLength;\n    i = 0;\n    do {\n        if (neigh[i] != NULL) {\n            PN[i][0] = Mx - neigh[i]->Mx;\n            PN[i][1] = My - neigh[i]->My;\n            PN[i][2] = Mz - neigh[i]->Mz;\n            length = worldP->getDist(Mx, My, Mz, neigh[i]->Mx, neigh[i]->My, neigh[i]->Mz);\n\n            /*if(surgeSpringConst==true){\n             * sConst = surgeConstant;\n             * SL =  surgeSpringLength;\n             * surgeSpringConst = false;\n             * }*/\n            if (neigh[i]->FA == true) {\n                sConst = FAspringConstant; //filBaseConstant;\n                SL = springLength;\n            }\n            if (((FIL == BASE) || (FIL == STALK)) && (veilAdvancing == true) && ((neigh[i]->FIL == STALK) || (neigh[i]->FIL == TIP))) {\n                sConst = filBaseConstant;\n                SL = filSpringLength;\n            } else if (neigh[i]->Cell != Cell) {\n                sConst = junctionConstant;\n                SL = JunctionSpringLength;\n            } else {\n                sConst = springConstant;\n                SL = springLength;\n            }\n\n\n        } else if ((FIL == TIP) && (flagFil == 0)) {\n            flagFil = 1;\n            PN[i][0] = Mx - filNeigh->Mx;\n            PN[i][1] = My - filNeigh->My;\n            PN[i][2] = Mz - filNeigh->Mz;\n            length = worldP->getDist(Mx, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n\n        } else {\n            DONE = 1;\n        }\n\n        if (DONE == 0) {\n\n            if (sqrt(PN[i][0] * PN[i][0]) >= (float) xMAX / 2.0f) {\n\n                if (PN[i][0] > 0) PN[i][0] = -((float) xMAX - PN[i][0]);\n                else PN[i][0] = (float) xMAX - fabs(PN[i][0]);\n                length = fabs(xMAX - PN[i][0]);\n\n            }\n            denom = sqrt((PN[i][0] * PN[i][0])+(PN[i][1] * PN[i][1])+(PN[i][2] * PN[i][2]));\n\n            //only apply force when spring is longer than it should be, not smaller -as membranes dont ping outwards, they ruffle - should avoid 'sagging of membrane'\n            if (length > SL) {\n                for (k = 0; k < 3; k++) {\n                    SN[i][k] = SL * (PN[i][k] / denom);\n                }\n\n                for (k = 0; k < 3; k++) {\n                    DN[i][k] = PN[i][k] - SN[i][k];\n                }\n\n                for (k = 0; k < 3; k++) sumDN[k] += (sConst * DN[i][k]);\n            }\n        }\n        i++;\n    } while ((i < upto) && (DONE == 0));\n\n\n    for (k = 0; k < 3; k++) {\n        Force[k] = sumDN[k];\n\n    }\n\n\n    newX = Mx - (Force[0] / 2.0f);\n    newY = My - (Force[1] / 2.0f);\n    newZ = Mz - (Force[2] / 2.0f);\n\n    //toroidal on x axis\n    if(TOROIDAL_X==true){\n    if(newX<0){\n        newX =  (float)xMAX+newX;\n    }\n    if(newX>=(float)xMAX){\n        \n        newX = newX - (float)xMAX;\n    }\n    }\n    if(TOROIDAL_Y==true){\n    \n    //roof on y ans z axis\n    if(newY<0) newY = 0;\n    else if(newY>yMAX-1) newY = yMAX-1;\n    \n    if(newZ<0) newZ=0;\n    else if(newZ>zMAX-1) newZ = zMAX-1;\n    }\n    //----------------------------------------------------------------\n\n    moveAgent(newX, newY, newZ, false);\n    \n\n\n    \n\n}\n//----------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvoid MemAgent::moveAgent(float newX, float newY, float newZ, bool FAset) {\n\n    int newMx = (int) newX;\n    int newMy = (int) newY;\n    int newMz = (int) newZ;\n    int X, Y, Z;\n    X = (int) Mx;\n    Y = (int) My;\n    Z = (int) Mz;\n\n\n    //only bother to move grid version if its moving to another grid site - this is the int version of the float model for ease of local rule look up\n    if ((newMx == X) && (newMy == Y) && (newMz == Z)) {\n        //do nothing its in the same place;\n\n        //move agent in continuous space\n        Mx = newX;\n        My = newY;\n        Mz = newZ;\n    } else {\n\n        //--------------------------------------------------------------------------------------------------------------------------\n        //non filopodia agents change grid state to M\n        if ((FIL == BASE) || (FIL == NONE)) {\n            if ((worldP->grid[newMx][newMy][newMz].type == const_M) || (worldP->grid[newMx][newMy][newMz].type == const_E) || (worldP->grid[newMx][newMy][newMz].type == BLOOD)) {\n\n                worldP->deleteOldGridRef(this, false);\n\n                worldP->setMLocation(newMx, newMy, newMz, this);\n\n\n                //move agent in continuous space\n                Mx = newX;\n                My = newY;\n                Mz = newZ;\n            }\n        }            //------------------------------------------------------------------------------------------------------------------------------\n            //------------------------------------------------------------------------------------------------------------------------------\n            //filopodia agents exist in either M or E state grid sites as they are thin.. only end up in M state if the veil somhow pulls up over them\n        else if ((FIL == TIP) || (FIL == STALK)) {\n\n            worldP->deleteOldGridRef(this, true);\n\n            worldP->grid[newMx][newMy][newMz].Fids.push_back(this);\n\n            //move agent in continuous space\n            Mx = newX;\n            My = newY;\n            Mz = newZ;\n        }\n        //------------------------------------------------------------------------------------------------------------------------------\n    }\n\n    FA = FAset;\n\n}\n//-----------------------------------------------------------------------------------------------------------------------\n//anastamosis new junction\n\nvoid MemAgent::anastomosis(MemAgent* other) {\n\n    int S, z;\n    int flag, flagN, flagE, flagA;\n\n    flagA = 1;\n    flag = 0;\n    flagN = 0;\n    flagE = 0;\n    S = 0;\n    MemAgent* node1;\n    MemAgent* node2;\n    bool allow = true;\n\n\n    if ((other->Cell->tipCellTest() == true) && (Cell->tipCellTest() == true)) {\n        //if (((other->Cell == worldP->ECagents[1]) && (Cell == worldP->ECagents[3])) || ((other->Cell == worldP->ECagents[3]) && (Cell == worldP->ECagents[1]))) {\n            if (node == true) node1 = this;\n            else {\n                if (triangle.size() == 2)\n                    node1 = find_nearest_triangle_node();\n                else\n                    allow = false;\n            }\n\n\n            if (other->node == true) {\n                node2 = other;\n\n            } else {\n                if (triangle.size() == 2)\n                    node2 = find_nearest_triangle_node();\n                else\n                    allow = false;\n            }\n\n            if (allow == true) {\n                //dont create a new spring if this node already has a junction spring to that cell\n                do {\n                    if (node1->neigh[S]->Cell == node2->Cell) {\n                        flagN = 1;\n                    }\n                    S++;\n                } while ((S < node1->neighs) && (flagN == 0));\n\n                S = 0;\n                if (flagN == 0) {\n                    //dont create a new spring if the other node already has a junction spring to this cell\n                    do {\n                        if (node2->neigh[S]->Cell == node1->Cell) {\n                            flagE = 1;\n                        }\n                        S++;\n                    } while ((S < node2->neighs) && (flagE == 0));\n                }\n                //-----------------------------------------------------------------------------------\n                //dont connect up if no fused loops and this node has a neigh node who's connected to the other cell, as it means its\n                //not a real fusion event but just nodes at the corners of three cell junctions (when ECcross =2) trying to form a diagonal junction\n                //spring to the third cell\n                if ((flagN == 0) && (flagE == 0)) {\n                    S = 0;\n                    if (worldP->fusedCells.size() == 0) {\n                        //cout<<\"target \"<<node2->Cell<<endl;\n                        do {\n                            for (z = 0; z < node1->neigh[S]->neighs; z++) {\n                                //cout<<node1->neigh[S]->neigh[z]->Cell<<endl;\n                                if (node1->neigh[S]->neigh[z]->Cell == node2->Cell) flagE = 1;\n                            }\n                            S++;\n                        } while ((S < node1->neighs) && (flagE == 0));\n                    }\n                }\n                //-----------------------------------------------------------------------------------\n                if ((flagE == 1) || (flagN == 1)) flag = 1;\n\n                if (flag == 0) {\n\n                    //has no spring already to this cell so create one\n\n                    //only if its right next to it, not on diagonal - to preclude bunching of three way junctions..tho may prehibit anast..\n\n                    node1->neigh[neighs] = other;\n                    other->neigh[other->neighs] = node1;\n                    node1->Cell->createSpringTokenObject(node1, other, node1->neighs);\n                    other->Cell->createSpringTokenObject(other, node1, other->neighs);\n                    node1->springJunction = true;\n                    other->springJunction = true;\n                    worldP->store_new_fusion_events(node1->Cell, other->Cell);\n\n\t\t\t\t\tstd::cout << \"creating new spring \" << node1 << \" \" << other << \" \" << \" \" << SpringNeigh[neighs] << std::endl;\n                    node1->neighs++;\n                    other->neighs++;\n\n                    Cell->newJunction++;\n                    node1->triggeredAnastSurge(other);\n\n                }\n            }\n       // }\n    }\n\n}\n//-------------------------------------------------------------------------------------------------------------\n\nvoid World::store_new_fusion_events(EC* cell1, EC* cell2) {//store which cells have fused\n\n    int j;\n    bool allow = false;\n    bool found = false;\n\n\n    if (fusedCells.size() > 0) {\n        for (j = 0; j < fusedCells.size() / 2; j++) {\n\n            //check this is a new fusion event, and the two cells havent already formed a new junction\n            if ((fusedCells[(j * 2)] == cell1) && (fusedCells[(j * 2) + 1] == cell2)) found = true;\n            else if ((fusedCells[(j * 2)] == cell2) && (fusedCells[(j * 2) + 1] == cell1)) found = true;\n\n        }\n        if (found == true) allow = false;\n        else allow = true;\n    } else allow = true;\n\n    if (allow == true) {\n        fusedCells.push_back(cell1);\n        fusedCells.push_back(cell2);\n        fusedCells_times.push_back(timeStep);\n\n    }\n\n}\n//----------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------\n\nvoid MemAgent::JunctionTest( bool StoreInJunctionList) {\n    int x, m, n, p, y, S, z, a, b, c;\n    int i, j, k;\n    int flagA = 0;\n    int flag = 0;\n\tstd::vector<EC*> cellNeighs;\n\tstd::vector<float> smallestDist;\n\tstd::vector<MemAgent*> nearestNode;\n\tstd::vector <EC*> CellsConnected;\n    float distance;\n    int pos;\n    int flag2 = 0;\n\n    int flag3;\n\n    bool previousJunction = junction;\n\n\n    i = (int) Mx;\n    j = (int) My;\n    k = (int) Mz;\n    //cout<<this<<endl;\n\n    if ((FIL == NONE) || (FIL == BASE)) {\n        //same layer\n        for (x = 0; x < 27; x++) {\n            if (x == 0) {\n                m = i + 1;\n                n = j - 1;\n                p = k;\n            } else if (x == 1) {\n                m = i + 1;\n                n = j;\n                p = k;\n            } else if (x == 2) {\n                m = i + 1;\n                n = j + 1;\n                p = k;\n            } else if (x == 3) {\n                m = i;\n                n = j - 1;\n                p = k;\n            } else if (x == 4) {\n                m = i;\n                n = j + 1;\n                p = k;\n            } else if (x == 5) {\n                m = i - 1;\n                n = j - 1;\n                p = k;\n            } else if (x == 6) {\n                m = i - 1;\n                n = j;\n                p = k;\n            } else if (x == 7) {\n                m = i - 1;\n                n = j + 1;\n                p = k;\n            }                //layer below\n            else if (x == 8) {\n                m = i + 1;\n                n = j - 1;\n                p = k - 1;\n            } else if (x == 9) {\n                m = i + 1;\n                n = j;\n                p = k - 1;\n            } else if (x == 10) {\n                m = i + 1;\n                n = j + 1;\n                p = k - 1;\n            } else if (x == 11) {\n                m = i;\n                n = j - 1;\n                p = k - 1;\n            } else if (x == 12) {\n                m = i;\n                n = j + 1;\n                p = k - 1;\n            } else if (x == 13) {\n                m = i - 1;\n                n = j - 1;\n                p = k - 1;\n            } else if (x == 14) {\n                m = i - 1;\n                n = j;\n                p = k - 1;\n            } else if (x == 15) {\n                m = i - 1;\n                n = j + 1;\n                p = k - 1;\n            } else if (x == 16) {\n                m = i;\n                n = j;\n                p = k - 1;\n            }                //layer above\n            else if (x == 17) {\n                m = i + 1;\n                n = j - 1;\n                p = k + 1;\n            } else if (x == 18) {\n                m = i + 1;\n                n = j;\n                p = k + 1;\n            } else if (x == 19) {\n                m = i + 1;\n                n = j + 1;\n                p = k + 1;\n            } else if (x == 20) {\n                m = i;\n                n = j - 1;\n                p = k + 1;\n            } else if (x == 21) {\n                m = i;\n                n = j + 1;\n                p = k + 1;\n            } else if (x == 22) {\n                m = i - 1;\n                n = j - 1;\n                p = k + 1;\n            } else if (x == 23) {\n                m = i - 1;\n                n = j;\n                p = k + 1;\n            } else if (x == 24) {\n                m = i - 1;\n                n = j + 1;\n                p = k + 1;\n            } else if (x == 25) {\n                m = i;\n                n = j;\n                p = k;\n            } else {\n                m = i;\n                n = j;\n                p = k + 1;\n            }\n\n\n            //-------------------------------\n            //toroidal only X\n            if (m >= xMAX) {\n\t\t\t\tm = 0;\n            }\n            if (m < 0) {\n\t\t\t\tm = xMAX - 1;\n            }\n            if (n >= yMAX) {\n\t\t\t\tn = 0;\n            }\n            if (n < 0) {\n\t\t\t\tn = yMAX - 1;\n            }\n\n            //-------------------------------\n\n            if (worldP->insideWorld(m, n, p)) {\n                if (worldP->grid[m][n][p].type == const_M) {\n                    for (y = 0; y < (int) worldP->grid[m][n][p].Mids.size(); y++) {\n                    \t// Check if the adjacent memAgent belongs to a different cell and is not currently in a filopodia.\n                        if ((worldP->grid[m][n][p].Mids[y]->Cell != Cell) && (worldP->grid[m][n][p].Mids[y]->FIL != STALK) && (worldP->grid[m][n][p].Mids[y]->FIL != TIP)) {\n                            junction = true;\n                            flagA = 1;\n\n                            worldP->grid[m][n][p].Mids[y]->junction = true;\n                            if (worldP->timeStep == 0) {\n\n                            }\n\n                            if (worldP->timeStep > 0) {\n\n                                //-------------------------------------------------------------------------------------------------------------\n                                //Anastamosis: create new spring junction to allow fusion, only on two tip cells\n                                if(StoreInJunctionList!=true){\n                                    if(ANASTOMOSIS==true)\n                                anastomosis(worldP->grid[m][n][p].Mids[y]);\n                                }\n                                //-------------------------------------------------------------------------------------------------------------\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (flagA == 0) junction = false;\n    //StoreInJunctionList=false;\n    if ((StoreInJunctionList) && (node) && (FIL == NONE)) {//&&(previousJunction!=junction)){\n        //vector<MemAgent*>::iterator L;\n        //L = worldP->JunctionAgents.begin();\n        //flag=0;\n        //add to list\n        //m=0;\n        //if(worldP->JunctionAgents.size()>0){\n        if ((junction) && (addedJunctionList)) {\n            //  do{\n            //      if(worldP->JunctionAgents[m]==this) flag=1;\n            //      m++;\n            //  }while((flag==0)&&(m<worldP->JunctionAgents.size()));\n            //if(flag==1) cout<<\"even without adding here it seems to be already in here:)\"<<endl;\n            // if(flag==0)\n            worldP->JunctionAgents.push_back(this);\n            addedJunctionList = true;\n        }\n\n        //remove from list\n\n        /*else{\n            m=0;\n        flag=0;\n           do{\n               if(worldP->JunctionAgents[m]==this){ worldP->JunctionAgents.erase(L+m); flag=1;}\n               m++;\n           }while((flag==0)&&(m<worldP->JunctionAgents.size()));\n        }\n    }\n    else{\n        if(junction==true){\n            worldP->JunctionAgents.push_back(this);\n        }\n    }*/\n    }\n    //-------------------------------------------------------------------------------------------------------------\n}\n//-------------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------------------------------------------\n\nvoid MemAgent::triggeredAnastSurge(MemAgent* junctionedAgent) {\n\n    //when a memAgent forms a junction with another cell, it should cause a local surge of the body that way\n\n    int i;\n    int flag = 0;\n    MemAgent* current;\n    MemAgent* Jcurrent;\n    int flagN = 0;\n    int S = 0;\n    int flagE = 0;\n    int flagDo = 0;\n    //first version+ just increase spring constant of the neigh nodes--------------------------------------------------\n    /*for(i=0;i<neighs;i++){\n     * neigh[i]->surgeSpringConst=true;\n     * }\n     * for(i=0;i<junctionedAgent->neighs;i++){\n     * junctionedAgent->neigh[i]->surgeSpringConst=true;\n     * }*/\n    //---------------------------------------------------------------\n\n    //second version+ move niegh nodes to nearest high VEGF conc - like a local actin lamella podia surge--------------------------------------------------\n    for (i = 0; i < neighs; i++) {\n\n        if ((mesh3SpringsOnly == true) && (i == 3)) flag = 1;\n\n        if (flag == 0) {\n            current = neigh[i];\n            Jcurrent = junctionedAgent->neigh[i];\n\n            if (((current->FIL == BASE) || (current->FIL == NONE)) && ((Jcurrent->FIL == NONE) || (Jcurrent->FIL == BASE))) {\n\n                //limit junction springs to one per node for a given cell\n                S = 0;\n                do {\n                    if (current->neigh[S]->Cell == Jcurrent->Cell) {\n                        flagN = 1;\n                    }\n                    S++;\n                } while ((S < current->neighs) && (flagN == 0));\n\n                S = 0;\n                //dont create a new spring if the other node already has a junction spring to this cell\n                do {\n                    if (Jcurrent->neigh[S]->Cell == current->Cell) {\n                        flagE = 1;\n                    }\n                    S++;\n                } while ((S < Jcurrent->neighs) && (flagE == 0));\n\n                if ((flagE == 1) || (flagN == 1)) flagDo = 1;\n\n                if (flagDo == 0) {\n                    current->neigh[current->neighs] = Jcurrent;\n                    Jcurrent->neigh[Jcurrent->neighs] = current;\n\n                    Cell->createSpringTokenObject(current, Jcurrent, current->neighs);\n                    Jcurrent->Cell->createSpringTokenObject(Jcurrent, current, Jcurrent->neighs);\n\t\t\t\t\tstd::cout << \"creating new surge spring \" << current << \" \" << Jcurrent << \" \" << \" \" << std::endl;\n\n                    current->neighs++;\n                    Jcurrent->neighs++;\n\n                    Cell->newJunction++;\n                }\n\n            }\n\n        }\n        //neigh[i]->surgeSpringConst=true;\n        //if(neigh[i]->EnvNeighs.size()!=0) highest=neigh[i]->findHighestConc();\n        //neigh[i]->moveAgent(highest->Ex, highest->Ey, highest->Ez,false);\n\n    }\n    //for(i=0;i<junctionedAgent->neighs;i++){\n    //junctionedAgent->neigh[i]->surgeSpringConst=true;\n    //if(junctionedAgent->neigh[i]->EnvNeighs.size()!=0) highest=junctionedAgent->neigh[i]->findHighestConc();\n    //junctionedAgent->neigh[i]->moveAgent(highest->Ex, highest->Ey, highest->Ez,false);\n    //}\n    //---------------------------------------------------------------\n\n\n}\n//-------------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------------------------------------------\n\nbool MemAgent::form_filopodia_contact(void) {\n    int x, y;\n    int i, j, k;\n    i = (int) Mx;\n    j = (int) My;\n    k = (int) Mz;\n    int flagA = 0;\n\n    //check if the memAgent is on a junction with another filopodia-at any point in the fil\n    for (x = 0; x < 26; x++) {\n        for (y = 0; y < (int) worldP->neigh[x].Fids.size(); y++) {\n            if ((worldP->neigh[x].Fids[y]->Cell != Cell)) {\n                flagA = 1;\n            }\n\n        }\n    }\n\n    if (flagA == 0) return (false);\n    else return (true);\n\n}\n//------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------\n\nbool testFilMax(EC* cell) {\n\n    /*int i;\n     * int count=0;\n     * int springAgentsMax;\n     * springAgentsMax = cell->springAgents.size();\n     *\n     *\n     * for(i=0;i<cell->nodeAgents.size();i++){\n     * if((cell->nodeAgents[i]->FIL==STALK)||(cell->nodeAgents[i]->FIL==TIP)) count++;\n     * }\n     * if(count+springAgentsMax+cell->no_of_filExtensions_this_timestep>=512)\n     *\n     * */\n    if (actinMax - cell->actinUsed >= 1.0f)return (false);\n    else return (true);\n}\n//---------------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------------------------------\n\nbool MemAgent::extendFil(void) {\n\n    //cout<<\"extending!\"<<endl;\n    MemAgent* mp;\n    Env * highest;\n    bool ans = false;\n    Filopodia* fp;\n    float distNeeded;\n    float newDist, oldDist;\n    int i;\n    bool allow;\n    if (node == true) {\n\n        //only extend if enough membrane - not limiting individual filopodia size, but overall cell stretch\n        //if((int)(Cell->nodeAgents.size()+Cell->springAgents.size()+Cell->surfaceAgents.size())<memMax){\n\n        //find new position----------------------------------------------\n        if (EnvNeighs.size() != 0) {\n            if (Cell->actinUsed < actinMax) {\n                //if(LUMEN_BM){ for(i=0;i<EnvNeighs.size();i++){\n                 //   allow = false;\n                 //   if((EnvNeighs[i]->inside==false)&&(EnvNeighs[i]->BM!=true)) allow = true;\n                //}\n                //}\n                //else{\n                    allow = true;\n                //}\n                if(allow==true){\n                highest = findHighestConc();\n                if ((highest != NULL) && (highest->VEGF != 0)) {\n\n                    //-----------------------------------------------------------------------\n                    if (FIL == NONE) {\n                        //if(testFilMax(Cell)==false){\n                        //basal focal adhesion - inhibits veil and all cell body advance\n\n\n                        if (sqrt((highest->Ex - Mx)*(highest->Ex - Mx)) > xMAX / 2.0f) {\n                            if (highest->Ex > Mx)\n                                distNeeded = worldP->getDist(highest->Ex - xMAX, highest->Ey, highest->Ez, Mx, My, Mz);\n                            else\n                                distNeeded = worldP->getDist(highest->Ex, highest->Ey, highest->Ez, Mx - xMAX, My, Mz);\n\n                        } else\n                            distNeeded = worldP->getDist(highest->Ex, highest->Ey, highest->Ez, Mx, My, Mz);\n\n\n                        if ((actinMax - Cell->actinUsed) >= distNeeded) {\n\n                            //cout<<distNeeded<<\" B \"<<Cell;\n                            Cell->actinUsed += distNeeded;\n                            FA=true;\n                            //Cell->fil = true;\n                            //create new node, only attached to the current guy. create it in highest VEGF site.\n                            mp = new MemAgent(Cell, worldP);\n                            \n                            mp->Mx = highest->Ex;\n                            mp->My = highest->Ey;\n                            mp->Mz = highest->Ez;\n\n\t\t\t\t\t\t\tif (DSL_TESTING) {\n\t\t\t\t\t\t\t\tthis->worldP->set_focal_adhesion(mp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmp->FA = true;\n\t\t\t\t\t\t\t}\n\n                            mp->previous.x = mp->Mx;\n                            mp->previous.y = mp->My;\n                            mp->previous.z = mp->Mz;\n\n                            mp->FIL = TIP;\n                            FIL = BASE;\n\n\n                            Cell->nodeAgents.push_back(mp);\n\n                            worldP->setFilLocation((int) mp->Mx, (int) mp->My, (int) mp->Mz, mp);\n\n                            //connect the two nodes\n\n                            neigh[neighs] = mp;\n                            Cell->createSpringTokenObject(this, mp, neighs);\n                            neighs++;\n\n                            //this is so the tip knows which node it is connected to, rather than having a full spring as we dont want the tip to be pulled back down.\n                            mp->filNeigh = this;\n\n                            //link the two for polarity for passing of tokens up filopodia (always passes up to plus site)\n                            plusSite = mp;\n                            mp->minusSite = this;\n\n                            //confirms the extension has succeeded\n                            ans = true;\n\n                            //spend the actin tokens\n                            filTokens -= tokenStrength;\n                            this->Cell->filopodiaExtensions.push_back(std::array<int,3>{(int)mp->Mx, (int)mp->My, (int)mp->Mz});\n                            //mp->filTokens=filTokens;\n                            //focalAdhesions();\n\n                            //for testing filopodia contacts (giovanni data comparison from PLoS CB paper)------------\n                            if (ANALYSIS_contactsTest == true) {\n\n                                Filopodia* fp = new Filopodia(worldP);\n\n                                worldP->filopodia.push_back(fp);\n\n                                base_fil_belong = fp;\n                                fp->time_created = worldP->timeStep;\n                                fp->base = this;\n                                fp->Cell = this->Cell;\n                            }\n                            //------------------------------------------\n                            \n\n                        }\n\n                    } else {\n\n                        if (highest->Ex - filNeigh->Mx > xMAX / 2.0f)\n                            newDist = worldP->getDist(highest->Ex - xMAX, highest->Ey, highest->Ez, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n                        else if (filNeigh->Mx - highest->Ex > xMAX / 2.0f)\n                            newDist = worldP->getDist(highest->Ex, highest->Ey, highest->Ez, filNeigh->Mx - xMAX, filNeigh->My, filNeigh->Mz);\n                        else\n                            newDist = worldP->getDist(highest->Ex, highest->Ey, highest->Ez, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n\n                        if (Mx - filNeigh->Mx > xMAX / 2.0f)\n                            oldDist = worldP->getDist(Mx - xMAX, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n                        else if (filNeigh->Mx - Mx > xMAX / 2.0f)\n                            oldDist = worldP->getDist(Mx, My, Mz, filNeigh->Mx - xMAX, filNeigh->My, filNeigh->Mz);\n                        else\n                            oldDist = worldP->getDist(Mx, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n                        distNeeded = newDist - oldDist;\n\n\n                        if ((actinMax - Cell->actinUsed) >= distNeeded) {\n                            \n                            Cell->actinUsed += distNeeded;\n\n                            moveAgent(highest->Ex, highest->Ey, highest->Ez, true);\n                            this->Cell->filopodiaExtensions.push_back(std::array<int,3>{(int)Mx, (int)My, (int)Mz});\n                            ans = true;\n                            filTokens -= tokenStrength;\n                            \n\n                            //filTokens=0;\n                        }\n                    }\n                }\n            }\n            }\n\n\n        }\n\n    }\n    return (ans);\n\n}\n//----------------------------------------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nvoid MemAgent::checkNeighs(bool called_fron_differentialAdhesion) {\n    int x, m, n, p, zed;\n    int i, j, k, mleb;\n    i = (int) Mx;\n    j = (int) My;\n    k = (int) Mz;\n    Env* Eagent;\n    bool connected;\n\n    MneighCount = 0;\n\n    EnvNeighs.clear();\n    SumVEGF = 0.0f;\n\n    mediumNeighs = 0;\n    //--------------\n    DiffAd_neighs.clear();\n    mediumNeighs = 0;\n    //--------------\n\n    //same layer\n    for (x = 0; x < 26; x++) {\n        if (x == 0) {\n            m = i + 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 1) {\n            m = i + 1;\n            n = j;\n            p = k;\n        } else if (x == 2) {\n            m = i + 1;\n            n = j + 1;\n            p = k;\n        } else if (x == 3) {\n            m = i;\n            n = j - 1;\n            p = k;\n        } else if (x == 4) {\n            m = i;\n            n = j + 1;\n            p = k;\n        } else if (x == 5) {\n            m = i - 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 6) {\n            m = i - 1;\n            n = j;\n            p = k;\n        } else if (x == 7) {\n            m = i - 1;\n            n = j + 1;\n            p = k;\n        }            //layer below\n        else if (x == 8) {\n            m = i + 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 9) {\n            m = i + 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 10) {\n            m = i + 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 11) {\n            m = i;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 12) {\n            m = i;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 13) {\n            m = i - 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 14) {\n            m = i - 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 15) {\n            m = i - 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 16) {\n            m = i;\n            n = j;\n            p = k - 1;\n        }            //layer above\n        else if (x == 17) {\n            m = i + 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 18) {\n            m = i + 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 19) {\n            m = i + 1;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 20) {\n            m = i;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 21) {\n            m = i;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 22) {\n            m = i - 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 23) {\n            m = i - 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 24) {\n            m = i - 1;\n            n = j + 1;\n            p = k + 1;\n        } else {\n            m = i;\n            n = j;\n            p = k + 1;\n        }\n\n\n        //-------------------------------\n        //toroidal only X\n        if(TOROIDAL_X==true){\n        if (m >= xMAX) m = 0;\n        if (m < 0) m = xMAX - 1;\n        }\n\n        if(TOROIDAL_Y==true){\n        if (n >= yMAX) n = 0;\n        if (n < 0) n = yMAX - 1;\n        }\n\n\n        if (worldP->insideWorld(m, n, p)) {\n            worldP->neigh[x].Mids = worldP->grid[m][n][p].Mids;\n            worldP->neigh[x].Eid = worldP->grid[m][n][p].Eid;\n\n            worldP->neigh[x].type = worldP->grid[m][n][p].type;\n            worldP->neigh[x].Fids = worldP->grid[m][n][p].Fids;\n\n            if (worldP->neigh[x].type == const_M) {\n                MneighCount++;\n            }\n\n\n            else if (worldP->neigh[x].type == const_E) {\n                Eagent = worldP->neigh[x].Eid;\n                SumVEGF += Eagent->VEGF;\n                EnvNeighs.push_back(Eagent);\n            }\n            \n            /*else if((node==true)&&(worldP->neigh[x].type==AS)){\n             *\n             * if(FATimer>=0) FA=true;\n             *\n             * }*/\n            //-----------NEW BIT!\n\n            //for differential adhesion..\n            //will need to add a lot to make sure dont think filagents are neighbours here for vessel version etc...!!!!\n            if (called_fron_differentialAdhesion == true) {\n                if (worldP->grid[m][n][p].type == const_M) {\n                    if (diffAd_replaced_cell != NULL) {\n                        for (zed = 0; zed < worldP->grid[m][n][p].Mids.size(); zed++) {\n                            if ((worldP->grid[m][n][p].Mids[zed]->FIL != TIP) && (worldP->grid[m][n][p].Mids[zed]->FIL != STALK)) {\n                                connected = meshConnected(worldP->grid[m][n][p].Mids[zed]);\n                                if (connected == true) {\n\n                                    if ((worldP->grid[m][n][p].Mids[zed]->Cell != this->diffAd_replaced_cell)) {\n                                        DiffAd_neighs.push_back(worldP->grid[m][n][p].Mids[zed]);\n                                        //worldP->grid[m][n][p].Mids[zed]->labelled2 = true;\n                                    }\n                                }\n                            }\n                        }\n                    } else if (diffAd_replaced_med != NULL) {\n                        for (zed = 0; zed < worldP->grid[m][n][p].Mids.size(); zed++) {\n                            DiffAd_neighs.push_back(worldP->grid[m][n][p].Mids[zed]);\n                        }\n\n                    } else {\n                        for (zed = 0; zed < worldP->grid[m][n][p].Mids.size(); zed++) {\n                            if ((worldP->grid[m][n][p].Mids[zed]->FIL != TIP) && (worldP->grid[m][n][p].Mids[zed]->FIL != STALK)) {\n                                connected = meshConnected(worldP->grid[m][n][p].Mids[zed]);\n                                if (connected == true) {\n                                    //cout<<\"*\"<<endl;\n                                    if (worldP->grid[m][n][p].Mids[zed]->diffAd_replaced_cell != NULL) {\n                                        if ((worldP->grid[m][n][p].Mids[zed]->diffAd_replaced_cell != this->Cell)) {\n                                            DiffAd_neighs.push_back(worldP->grid[m][n][p].Mids[zed]);\n                                            //worldP->grid[m][n][p].Mids[zed]->labelled2 = true;\n                                        }\n                                    } else {\n                                        if ((worldP->grid[m][n][p].Mids[zed]->Cell != this->Cell)) {\n                                            DiffAd_neighs.push_back(worldP->grid[m][n][p].Mids[zed]);\n                                            //worldP->grid[m][n][p].Mids[zed]->labelled2 = true;\n                                        }\n\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else if ((worldP->grid[m][n][p].type == MED) && (diffAd_replaced_med == NULL) && (worldP->grid[m][n][p].med->diffAd_replaced == NULL)) {\n\n\n                    mediumNeighs++;\n\n                } else if ((worldP->grid[m][n][p].type == MED) && (diffAd_replaced_med == NULL) && (worldP->grid[m][n][p].med->diffAd_replaced != NULL)) {\n                    if (worldP->grid[m][n][p].med->diffAd_replaced->Cell != this->Cell) DiffAd_neighs.push_back(worldP->grid[m][n][p].med->diffAd_replaced);\n\n                }\n\n            }\n\n\n\n            //_____________________\n        } else {\n\n            worldP->neigh[x].Eid = NULL;\n            worldP->neigh[x].type = -1;\n            worldP->neigh[x].Fids.clear();\n            worldP->neigh[x].Mids.clear();\n        }\n        //-------------------------------\n\n    }\n\n    /*if(diffAd_replaced!=NULL){\n            //out<<\"D:\";\n            for(i=0;i<DiffAd_neighs.size();i++){\n                    //cout<<DiffAd_neighs[i]->Cell->VEGFRtot<<endl;\n            }\n            //cout<<endl;\n    }*/\n\n}\n//-------------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------------\nEnv * MemAgent::findHighestConc(void){\n\n    int i, direction;\n    int start, picked;\n    int upto;\n    Env * highest;\n    Env * chosen;\n    float chance, prob;\n    Env* furthest;\n    float dist;\n    float furthestDist=0;\n    Env* straight=NULL;\n    float currLength;\n    \n   /* if(BAHTI_ANALYSIS==true){\n        \n        //memagent ID\n        worldP->dataFile2<<this<<\"\\t\";\n        \n        //env neighbour coords and vegf level.\n        for(i=0;i<EnvNeighs.size();i++)\n        {\n            worldP->dataFile2<<EnvNeighs[i]->Ex<<\"\\t\"<<EnvNeighs[i]->Ey<<\"\\t\"<<EnvNeighs[i]->Ez<<\"\\t\"<<EnvNeighs[i]->VEGF<<\"\\t\";\n            \n        }\n        \n        worldP->dataFile2<<endl;\n    }*/\n\n    //if(FIL==TIP){\n    //   currLength = worldP->getDist(Mx, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n    //}\n    //start=(int)((double)rand()*(double)EnvNeighs.size()/(double)RAND_MAX);\n\n    //direction=((double)rand()*2.00/(double)RAND_MAX);\n    //random_shuffle(EnvNeighs.begin(), EnvNeighs.end());\n    new_random_shuffle(EnvNeighs.begin(), EnvNeighs.end());\n    highest=EnvNeighs[0];\n    \n    if (EnvNeighs[0]->VEGF > 0)\n    {\n        furthest = EnvNeighs[0];\n        if (FIL == NONE)\n            furthestDist = worldP->getDist(furthest->Ex, furthest->Ey, furthest->Ez, (int)Mx, (int)My, (int)Mz);\n        else\n            furthestDist = worldP->getDist(furthest->Ex, furthest->Ey, furthest->Ez, (int)filNeigh->Mx, (int)filNeigh->My, (int)filNeigh->Mz);\n    }\n    \n    else furthest=NULL;\n    \n    upto=EnvNeighs.size();\n    \n    //direction = (int)((double)rand()*(double)2/(double)RAND_MAX);\n    \n    //if(direction==0) picked = start++;\n    //else picked = start--;\n    \n    //cout<<\" D= \"<<direction<<\" S= \"<<start;\n    \n    for(i=1;i<upto;i++){\n        //if(picked==upto)picked=0;\n        //else if(picked<0)picked=upto-1;\n        //if((EnvNeighs[i]->Ex==Mx)&&(EnvNeighs[i]->Ey==My+1)&&(EnvNeighs[i]->Ez==Mz)) straight = EnvNeighs[i];\n        //if(FIL==TIP)\n        //   if((EnvNeighs[i]->VEGF>=highest->VEGF)&&(worldP->getDist(EnvNeighs[i]->Ex, EnvNeighs[i]->Ey, EnvNeighs[i]->Ez, filNeigh->Mx, filNeigh->My, filNeigh->Mz)>currLength))\n        //       highest=EnvNeighs[i];\n        //  else\n\n        if(EnvNeighs[i]->VEGF>=highest->VEGF)\n            highest=EnvNeighs[i];\n        if(EnvNeighs[i]->VEGF>0){\n            if(FIL==NONE)\n                dist = worldP->getDist(EnvNeighs[i]->Ex, EnvNeighs[i]->Ey, EnvNeighs[i]->Ez, (int)Mx, (int)My, (int)Mz);\n            else\n                dist = worldP->getDist(EnvNeighs[i]->Ex, EnvNeighs[i]->Ey, EnvNeighs[i]->Ez, (int)filNeigh->Mx, (int)filNeigh->My, (int)filNeigh->Mz);\n            \n            if(dist>=furthestDist){\n                furthestDist = dist;\n                furthest = EnvNeighs[i];\n            }\n        }\n        \n        //if(direction==0)\n        \n        //else picked--;\n        \n    }\n    //chance = (float)rand()/(float)RAND_MAX;\n    chance = (float)new_rand()/(float)NEW_RAND_MAX;\n    prob = EPSILON; //epsilon high (1) = greedy, always choses highest otherwise random.\n    if(chance<prob){\n        chosen = highest;\n        //cout<<\"highest\"<<endl;\n    }\n    \n    //picking one that extends length, not necessarily the furthest one tho..\n    \n    //if((FIL==TIP)&&(worldP->getDist(highest->Ex, highest->Ey, highest->Ez, filNeigh->Mx, filNeigh->My, filNeigh->Mz)>currLength))\n    //chosen=highest;\n    //else if(FIL==NONE)\n    //chosen = highest;\n    else{\n        //pick a random direction to extend fil in -more realistic than always picking correct direction\n        //could randomly pick the correct one of course..\n        \n        //chosen  = EnvNeighs[(int)(((float)rand()*(float)EnvNeighs.size()/(float)RAND_MAX))];\n        chosen  = EnvNeighs[(int)(((float)new_rand()*(float)EnvNeighs.size()/(float)NEW_RAND_MAX))];\n        //chosen = furthest;\n        //if(straight!=NULL){\n        //cout<<\"found straight!\"<<endl;\n        //chosen = straight;\n        //}\n        //else\n        //chosen = furthest;\n        \n        //cout<<furthestDist<<endl;\n    }\n\n    //stats\n    /*if((chosen->Ex==Mx+1)&&(chosen->Ey==My+1)) right1++;\n     * if((chosen->Ex==Mx)&&(chosen->Ey==My+1)) middle++;\n     * if((chosen->Ex==Mx-1)&&(chosen->Ey==My+1)) left1++;\n     * if((chosen->Ex==Mx-1)&&(chosen->Ey==My)) left2++;\n     * if((chosen->Ex==Mx+1)&&(chosen->Ey==My)) right2++;\n     * count3++;*/\n\n    if(BAHTI_ANALYSIS==true){ //worldP->dataFile2<<\"chose \"<<chosen->Ex<<\"\\t\"<<chosen->Ey<<\"\\t\"<<chosen->Ez<<endl;\n        \n    }\n    \n    return(chosen);\n\n}\n\nvoid World::displayStats(void) {\n\tstd::cout << \"Dir right: \" << 100 * ((float) right2 / ((float) count3));\n\tstd::cout << \"Dir left: \" << 100 * ((float) left2 / ((float) count3));\n\tstd::cout << \"right: \" << 100 * ((float) right1 / ((float) count3));\n\tstd::cout << \" middle: \" << 100 * ((float) middle / ((float) count3));\n\tstd::cout << \" left: \" << 100 * ((float) left1 / ((float) count3)) << std::endl;\n\n}\n\n//------------------------------------------------------------------------------------------\n\nvoid MemAgent::calcRetractDist(void) {\n\n    int i, k;\n    float denom, length;\n    float sumDN[3];\n    int upto = meshNeighs + 5;\n    int DONE = 0;\n    float newX, newY, newZ;\n    float SL;\n    float sConst;\n\n    int flagFil = 0;\n    float ForceTemp[3];\n    float oldDist;\n\n\n    if (Mx - filNeigh->Mx >= xMAX / 2.0f)\n        oldDist = worldP->getDist(Mx - xMAX, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n    else if (filNeigh->Mx - Mx >= xMAX / 2.0f)\n        oldDist = worldP->getDist(Mx, My, Mz, filNeigh->Mx - xMAX, filNeigh->My, filNeigh->Mz);\n    else\n        oldDist = worldP->getDist(Mx, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n    float newDist;\n    float PN[upto][3];\n    float SN[upto][3];\n    float DN[upto][3];\n\n\n   \n    for (k = 0; k < 3; k++) sumDN[k] = 0.0f;\n\n    //have different lengths and constants for different types of spring\n    if (FIL == TIP) {\n\n        sConst = filSpringConstant;\n        SL = filSpringLength;\n    }\n    //calculate new force by summing neighbour vectors minused from current point PN1, PN2... then calculate the projection of S onto spring direction and get the difference, then \t\t  sum the elongated regions of each and times by k constant.n\n\n    i = 0;\n    do {\n        if (neigh[i] != NULL) {\n            PN[i][0] = Mx - neigh[i]->Mx;\n            PN[i][1] = My - neigh[i]->My;\n            PN[i][2] = Mz - neigh[i]->Mz;\n            length = worldP->getDist(Mx, My, Mz, neigh[i]->Mx, neigh[i]->My, neigh[i]->Mz);\n\n            /*if(surgeSpringConst==true){\n             * sConst = surgeConstant;\n             * SL =  surgeSpringLength;\n             * surgeSpringConst = false;\n             * }*/\n            if (neigh[i]->FA == true) {\n                sConst = FAspringConstant; //filBaseConstant;\n                SL = springLength;\n            }\n            if (((FIL == BASE) || (FIL == STALK)) && (veilAdvancing == true) && ((neigh[i]->FIL == STALK) || (neigh[i]->FIL == TIP))) {\n                sConst = filBaseConstant;\n                SL = filSpringLength;\n            } else if (neigh[i]->Cell != Cell) {\n                sConst = junctionConstant;\n                SL = JunctionSpringLength;\n            } else {\n                sConst = springConstant;\n                SL = springLength;\n            }\n\n\n        } else if ((FIL == TIP) && (flagFil == 0)) {\n            flagFil = 1;\n            PN[i][0] = Mx - filNeigh->Mx;\n            PN[i][1] = My - filNeigh->My;\n            PN[i][2] = Mz - filNeigh->Mz;\n            length = worldP->getDist(Mx, My, Mz, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n\n        } else {\n            DONE = 1;\n        }\n\n        if (DONE == 0) {\n\n            if (sqrt(PN[i][0] * PN[i][0]) >= (float) xMAX / 2.0f) {\n\n                if (PN[i][0] > 0) PN[i][0] = -((float) xMAX - PN[i][0]);\n                else PN[i][0] = (float) xMAX - fabs(PN[i][0]);\n                length = fabs(xMAX - PN[i][0]);\n\n            }\n            denom = sqrt((PN[i][0] * PN[i][0])+(PN[i][1] * PN[i][1])+(PN[i][2] * PN[i][2]));\n\n            //only apply force when spring is longer than it should be, not smaller -as membranes dont ping outwards, they ruffle - should avoid 'sagging of membrane'\n            if (length > SL) {\n                for (k = 0; k < 3; k++) {\n                    SN[i][k] = SL * (PN[i][k] / denom);\n                }\n\n                for (k = 0; k < 3; k++) {\n                    DN[i][k] = PN[i][k] - SN[i][k];\n                }\n\n                for (k = 0; k < 3; k++) sumDN[k] += (sConst * DN[i][k]);\n            }\n        }\n        i++;\n    } while ((i < upto) && (DONE == 0));\n\n\n    for (k = 0; k < 3; k++) {\n        ForceTemp[k] = sumDN[k];\n\n    }\n\n\n    newX = Mx - (ForceTemp[0] / 2.0f);\n    newY = My - (ForceTemp[1] / 2.0f);\n    newZ = Mz - (ForceTemp[2] / 2.0f);\n\n\n    if (newX - filNeigh->Mx >= xMAX / 2.0f)\n        newDist = worldP->getDist(newX - xMAX, newY, newZ, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n    else if (filNeigh->Mx - newX >= xMAX / 2.0f)\n        newDist = worldP->getDist(newX, newY, newZ, filNeigh->Mx - xMAX, filNeigh->My, filNeigh->Mz);\n    else\n        newDist = worldP->getDist(newX, newY, newZ, filNeigh->Mx, filNeigh->My, filNeigh->Mz);\n\n\n\n    Cell->actinUsed -= (oldDist - newDist);\n    //cout<<(oldDist-worldP->getDist(newX, newY, newZ, filNeigh->Mx, filNeigh->My, filNeigh->Mz))<<endl;\n}\n//----------------------------------------------------------------------------------\n\n\nbool MemAgent::meshConnected(MemAgent* tocheck) {\n\n     int i = 0;\n    int j = 0;\n    int k=0;\n    int flag = 0;\n    MemAgent* tp;\n    MemAgent* np;\n\tbool returnType = false;\n    bool flagDont=false;\n    //check if the neighbour agent is either,\n    //a node agent and has a spring connecting to this one,\n    //or a surface agent and belongs to any neigh node triangle..\n    //cout<<\"|\";\n\n\n    if(((node==false)&&((triangle[0]->neighs>500)||(triangle[1]->neighs>500)||(triangle[2]->neighs>500)))||((tocheck->node==false)&&((tocheck->triangle[0]->neighs>500)||(tocheck->triangle[1]->neighs>5000)||(tocheck->triangle[2]->neighs>5000)))){\n\t\tstd::cout<<\"hmmm\"<<this<<\" \"<<tocheck<<std::endl;\n        flagDont = true;\n    }\n\n    if (node == true) {\n        if (tocheck->node == true) {\n            //is it in direct 4 neighhs list?\n            do {\n\n                if (neigh[i] == tocheck) flag = 1;\n                i++;\n            } while ((i < neighs) && (flag == 0));\n\n            //check 2nd level out neighs, are they connected?\n            if (flag == 0) {\n                i = 0;\n                j = 0;\n\n                do {\n                    tp = neigh[i];\n                    j=0;\n                    do {\n\n                        if (tp->neigh[j] == tocheck) flag = 1;\n                        j++;\n                    } while ((j < tp->neighs) && (flag == 0));\n                    i++;\n                } while ((i < neighs) && (flag == 0));\n\n                if(flag==0)\n\t\t\t\t\treturnType= false;\n                else returnType =true;\n            } else returnType = true;\n        } else {\n\n\n\t\t\t//  return(false);\n\t\t\t// }\n\t\t\t// }\n            if(flagDont==false){\n\n\t\t\t\tdo {\n\t\t\t\t\ttp = tocheck->triangle[i];\n\t\t\t\t\tif (tp == this) flag = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tif (tp->neigh[j] == this) flag = 1;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} while ((j < tp->neighs) && (flag == 0));\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\n\t\t\t\t} while ((i < 3) && (flag == 0));\n\t\t\t\t//check if its in 2nd level of connected neighs, this gives moore neighbourhood - if a little extra, tho if they are in grid sites nearby this is ok...\n\t\t\t\tif (flag == 0) {\n\n\t\t\t\t\ti=0;\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\ttp = tocheck->triangle[i];\n\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tk=0;\n\t\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\t\tif(tp->neigh[j]->neigh[k] == this) flag = 1;\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}while((k<tp->neigh[j]->neighs)&&(flag==0));\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} while ((j < tp->neighs) && (flag == 0));\n\n\t\t\t\t\t\ti++;\n\n\t\t\t\t\t} while ((i < 3) && (flag == 0));\n\n\t\t\t\t\tif(flag==0)returnType = false;\n\t\t\t\t\telse returnType = true;\n\t\t\t\t}\n\n\t\t\t\telse returnType = true;\n            }\n        }\n    }//if this guy is a surface agent...\n    else {\n        //need to test if any of this guys triangle nodes are a) mesh connected to the tocheck node, if its a node, or mesh connected to any of the other guys triangle nodes\n\n        if(flagDont==false){\n\t\t\tif (tocheck->node == true) {\n\n\t\t\t\ti = 0;\n\t\t\t\tdo {\n\t\t\t\t\ttp = triangle[i];\n\t\t\t\t\tif (tp == tocheck) flag = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tif (tp->neigh[j] == tocheck) flag = 1;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} while ((j < tp->neighs) && (flag == 0));\n\n\n\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} while ((i < 3) && (flag == 0));\n\n\t\t\t\t//check 2nd level out neighs...\n\t\t\t\tif (flag == 0) {\n\n\t\t\t\t\ti = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\ttp = triangle[i];\n\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tif (tp->neigh[j]->neigh[k] == tocheck) flag = 1;\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t} while ((k < tp->neigh[j]->neighs) && (flag == 0));\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} while ((j < tp->neighs) && (flag == 0));\n\n\n\n\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} while ((i < 3) && (flag == 0));\n\n\n\t\t\t\t\tif (flag == 0)returnType = false;\n\t\t\t\t\telse returnType = true;\n\t\t\t\t} else returnType = true;\n\t\t\t}\n        }\n\t\telse {\n\n            if(flagDont==false){\n\t\t\t\t//only allowing if it shares a triangle node in common - but could add or triangle node is connected to the other node in its neighs...\n\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\ttp = triangle[i];\n\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\tnp = tocheck->triangle[j];\n\n\t\t\t\t\t\tif (tp == np) flag = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\tif (flag == 0) {\n\t\t\t\t\t//check 2nd level neighs...\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\ttp = triangle[i];\n\t\t\t\t\t\tfor (k = 0; k < tp->neighs; k++) {\n\t\t\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\t\t\tnp = tocheck->triangle[j];\n\n\t\t\t\t\t\t\t\tif (tp->neigh[k] == np) flag = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag == 0) {\n\n\t\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\t\ttp = tocheck->triangle[i];\n\t\t\t\t\t\t\tfor (k = 0; k < tp->neighs; k++) {\n\t\t\t\t\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\t\t\t\t\tnp = triangle[j];\n\n\t\t\t\t\t\t\t\t\tif (tp->neigh[k] == np) flag = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == 0)returnType = false;\n\t\t\t\t\t\telse returnType = true;\n\t\t\t\t\t} else returnType = true;\n\t\t\t\t} else returnType = true;\n\n\t\t\t}\n\t\t}\n\t}\n\t\n    if(flagDont==true) return(true);\n\telse return(returnType);\n\t//return (true);\n\n\n\n\n}\n\nMemAgent::MemAgent(EC* belongsTo, World* world){\n\n\tint i;\n\tdiffAd_replaced_cell = NULL;\n\tdiffAd_replaced_med = NULL;\n\n\tMEDIUM = false;\n\tmediumNeighs = 0;\n\tlabelled = false;\n\tlabelledBlindended = false;\n\tlabelled2=false;\n\tmesh3SpringsOnly=false;\n\tCell = belongsTo;\n\tcreated = 0;\n\tFA = false;\n\tFIL=NONE;\n\n\tworldP=world;\n\tretracted = false;\n\tjunction = false;\n\tneighs=0;\n\tnode = true;\n\tfilTokens =0;\n\tForce[0]=0;\n\tForce[1]=0;\n\tForce[2]=0;\n\tSumVEGF=0;\n\tMneighCount=0;\n\tdeleteFlag=false;\n\tVRinactiveCounter=0;\n\tfilTipTimer=0;\n\tplusSite=NULL;\n\tminusSite=NULL;\n\tfilPos = 0;\n\tspringJunction=false;\n\tfilNeigh=NULL;\n\tFATimer=0;\n\tactiveNotch = 0.0f;\n\tDll4=0.0f;\n\tVEGFR = 0.0f;\n\tVEGFRactive=0.0f;\n\n\tsurgeSpringConst=false;\n\tveilAdvancing = false;\n\tvonNeu=false;\n\tassessed=false;\n\taddedJunctionList=false;\n\n\n\n\tfor(i=0;i<meshNeighs+NEIGHSMAX;i++){\n\t\tneigh[i]=NULL;\n\t\tSpringNeigh[i]=NULL;\n\n\t}\n\tSpringBelong=NULL;\n\n\n\n}//-----------------------------------------------------------------------------\n\nMemAgent::~MemAgent(void){\n\tfor (auto protein : this->owned_proteins) {\n\t\tdelete protein;\n\t}\n\tEnvNeighs.clear();\n}\n\n/*****************************************************************************************\n*  Name:\t\tadd_cell_proteins\n*  Description: Checks against the proteins that a cell owns and adds them all to this memAgent.\n*               Should be used with newly created memAgents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid MemAgent::add_cell_proteins() {\n    //TODO: Have filopodia types prevent certain proteins from being allocated.\n    //TODO: Have protein totals be updated after all memAgents have been created.\n\n    for (auto current_protein : this->Cell->m_cell_type->proteins) {\n        // Create new protein\n        auto *new_protein = new protein(current_protein->get_name(), current_protein->get_location(), 0.0, false, current_protein->get_min(), current_protein->get_max());\n        this->owned_proteins.push_back(new_protein);\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\thas_protein\n*  Description: Checks against the proteins that a memAgent has this protein in vector.\n*               If protein has the same name, then return true.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool MemAgent::has_protein(std::string query_name) {\n    for (auto protein : this->owned_proteins) {\n        if (protein->get_name() == query_name) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_protein_level\n*  Description: Sets the level of a protein, if that memAgent possesses that protein.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nvoid MemAgent::set_protein_level(std::string protein_name, float new_level) {\n    assert(this->has_protein(protein_name));\n    for (auto protein : this->owned_proteins) {\n        if (protein->get_name() == protein_name) {\n        \tif (new_level < protein->get_min()) {\n        \t\tprotein->set_level(protein->get_min());\n        \t} else if (new_level > protein->get_max()) {\n\t\t\t\tprotein->set_level(protein->get_max());\n        \t}\n            protein->set_level(new_level);\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tupdate_protein_level\n*  Description: Updates the level of a protein owned by this memAgent.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid MemAgent::update_protein_level(std::string protein_name, float new_level) {\n    // This assert should always pass, as we're checking this in the distribute proteins function.\n   assert(this->has_protein(protein_name));\n   for (auto protein : this->owned_proteins) {\n       if (protein->get_name() == protein_name) {\n           protein->set_level(new_level);\n       }\n   }\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_protein_level\n*  Description: Returns the level of a protein owned by this memAgent.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat MemAgent::get_memAgent_protein_level(std::string protein_name) {\n    // This assert should always pass when calculating cell levels, as we're checking this in the calculate cell protein totals function.\n    // This is also used during ODE running and so has the potential to fail.\n    if (this->has_protein(protein_name)) {\n\t\tfor (auto protein : this->owned_proteins) {\n\t\t\tif (protein->get_name() == protein_name) {\n\t\t\t\treturn protein->get_level();\n\t\t\t}\n\t\t}\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_environment_level\n*  Description: Returns the level of a protein in the nearby environment.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat MemAgent::get_environment_protein_level(std::string protein_name) {\n    Env *ep;\n    int m, n, p;\n    int i = (int) Mx;\n    int j = (int) My;\n    int k = (int) Mz;\n\n    float protein_level = 0;\n\n    for (int x = 0; x < 26; x++) {\n        // Same layer.\n        if (x == 0) {\n            m = i + 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 1) {\n            m = i + 1;\n            n = j;\n            p = k;\n        } else if (x == 2) {\n            m = i + 1;\n            n = j + 1;\n            p = k;\n        } else if (x == 3) {\n            m = i;\n            n = j - 1;\n            p = k;\n        } else if (x == 4) {\n            m = i;\n            n = j + 1;\n            p = k;\n        } else if (x == 5) {\n            m = i - 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 6) {\n            m = i - 1;\n            n = j;\n            p = k;\n        } else if (x == 7) {\n            m = i - 1;\n            n = j + 1;\n            p = k;\n        }\n        // Layer below.\n        else if (x == 8) {\n            m = i + 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 9) {\n            m = i + 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 10) {\n            m = i + 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 11) {\n            m = i;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 12) {\n            m = i;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 13) {\n            m = i - 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 14) {\n            m = i - 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 15) {\n            m = i - 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 16) {\n            m = i;\n            n = j;\n            p = k - 1;\n        }\n        // Layer above.\n        else if (x == 17) {\n            m = i + 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 18) {\n            m = i + 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 19) {\n            m = i + 1;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 20) {\n            m = i;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 21) {\n            m = i;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 22) {\n            m = i - 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 23) {\n            m = i - 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 24) {\n            m = i - 1;\n            n = j + 1;\n            p = k + 1;\n        } else {\n            m = i;\n            n = j;\n            p = k + 1;\n        }\n        // If the environment agent at these coordinates is inside the world, and has the relevant protein,\n        // increase the count by the level at those coordinates.\n        if (worldP->insideWorld(m, n, p)) {\n            if (worldP->grid[m][n][p].type == const_E) {\n                ep = worldP->grid[m][n][p].Eid;\n                if (ep->has_protein(protein_name)) {\n                    protein_level+= ep->get_protein_level(protein_name);\n                }\n            }\n        }\n    }\n    return protein_level;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_local_protein_level\n*  Description: Returns the level of a protein in nearby memAgents belonging to this cell.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat MemAgent::get_local_protein_level(std::string protein_name) {\n    int m, n, p;\n    int i = (int) Mx;\n    int j = (int) My;\n    int k = (int) Mz;\n\n    float protein_level = 0;\n\n    for (int x = 0; x < 26; x++) {\n        // Same layer.\n        if (x == 0) {\n            m = i + 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 1) {\n            m = i + 1;\n            n = j;\n            p = k;\n        } else if (x == 2) {\n            m = i + 1;\n            n = j + 1;\n            p = k;\n        } else if (x == 3) {\n            m = i;\n            n = j - 1;\n            p = k;\n        } else if (x == 4) {\n            m = i;\n            n = j + 1;\n            p = k;\n        } else if (x == 5) {\n            m = i - 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 6) {\n            m = i - 1;\n            n = j;\n            p = k;\n        } else if (x == 7) {\n            m = i - 1;\n            n = j + 1;\n            p = k;\n        }\n            // Layer below.\n        else if (x == 8) {\n            m = i + 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 9) {\n            m = i + 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 10) {\n            m = i + 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 11) {\n            m = i;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 12) {\n            m = i;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 13) {\n            m = i - 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 14) {\n            m = i - 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 15) {\n            m = i - 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 16) {\n            m = i;\n            n = j;\n            p = k - 1;\n        }\n            // Layer above.\n        else if (x == 17) {\n            m = i + 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 18) {\n            m = i + 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 19) {\n            m = i + 1;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 20) {\n            m = i;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 21) {\n            m = i;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 22) {\n            m = i - 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 23) {\n            m = i - 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 24) {\n            m = i - 1;\n            n = j + 1;\n            p = k + 1;\n        } else {\n            m = i;\n            n = j;\n            p = k + 1;\n        }\n        // If the memAgents at these coordinates is inside the world, has the relevant protein and belongs to the same cell,\n        // increase the count by the level at those coordinates.\n\n        // Also handles transfer of proteins along filopodia.\n\n        if (worldP->insideWorld(m, n, p)) {\n            if (worldP->grid[m][n][p].type == const_M) {\n                for (auto memAgent : worldP->grid[m][n][p].Mids) {\n                    if (memAgent->has_protein(protein_name) && memAgent->Cell == this->Cell) {\n                        protein_level+= memAgent->get_memAgent_protein_level(protein_name);\n                    }\n                }\n            } else if (worldP->grid[m][n][p].type == const_E) {\n\t\t\t\tfor (auto memAgent : worldP->grid[m][n][p].Fids) {\n\t\t\t\t\tif (memAgent->has_protein(protein_name) && memAgent->Cell == this->Cell) {\n\t\t\t\t\t\tprotein_level+= memAgent->get_memAgent_protein_level(protein_name);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n    }\n    return protein_level;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_filopodia_protein_level\n*  Description: Returns the level of a protein in nearby memAgents belonging to filopodia,\n *  \t\t\tin other cells.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat MemAgent::get_filopodia_protein_level(std::string protein_name) {\n\tint m, n, p;\n\tint i = (int) Mx;\n\tint j = (int) My;\n\tint k = (int) Mz;\n\n\tfloat protein_level = 0;\n\n\tfor (int x = 0; x < 26; x++) {\n\t\t// Same layer.\n\t\tif (x == 0) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 1) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k;\n\t\t} else if (x == 2) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t} else if (x == 3) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 4) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t} else if (x == 5) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 6) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k;\n\t\t} else if (x == 7) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t}\n\t\t\t// Layer below.\n\t\telse if (x == 8) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 9) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t} else if (x == 10) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 11) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 12) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 13) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 14) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t} else if (x == 15) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 16) {\n\t\t\tm = i;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t}\n\t\t\t// Layer above.\n\t\telse if (x == 17) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 18) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t} else if (x == 19) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 20) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 21) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 22) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 23) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t} else if (x == 24) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else {\n\t\t\tm = i;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t}\n\t\t// If the memAgents at these coordinates is inside the world, has the relevant protein and belongs to the same cell,\n\t\t// increase the count by the level at those coordinates.\n\n\t\tif (worldP->insideWorld(m, n, p)) {\n\t\t\tif (worldP->grid[m][n][p].type == const_E) {\n\t\t\t\tfor (auto memAgent : worldP->grid[m][n][p].Fids) {\n\t\t\t\t\tif (memAgent->has_protein(protein_name) && memAgent->Cell != this->Cell) {\n\t\t\t\t\t\tprotein_level+= memAgent->get_memAgent_protein_level(protein_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn protein_level;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_junction_protein_level\n*  Description: Returns the level of a protein in nearby memAgents belonging to adjacent cells.\n*  \t\t\t\tThis is done only if the memAgents are defined as belonging to the junction.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat MemAgent::get_junction_protein_level(std::string protein_name) {\n    int m, n, p;\n    int i = (int) Mx;\n    int j = (int) My;\n    int k = (int) Mz;\n\n    float protein_level = 0;\n\n    for (int x = 0; x < 26; x++) {\n        // Same layer.\n        if (x == 0) {\n            m = i + 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 1) {\n            m = i + 1;\n            n = j;\n            p = k;\n        } else if (x == 2) {\n            m = i + 1;\n            n = j + 1;\n            p = k;\n        } else if (x == 3) {\n            m = i;\n            n = j - 1;\n            p = k;\n        } else if (x == 4) {\n            m = i;\n            n = j + 1;\n            p = k;\n        } else if (x == 5) {\n            m = i - 1;\n            n = j - 1;\n            p = k;\n        } else if (x == 6) {\n            m = i - 1;\n            n = j;\n            p = k;\n        } else if (x == 7) {\n            m = i - 1;\n            n = j + 1;\n            p = k;\n        }\n            // Layer below.\n        else if (x == 8) {\n            m = i + 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 9) {\n            m = i + 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 10) {\n            m = i + 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 11) {\n            m = i;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 12) {\n            m = i;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 13) {\n            m = i - 1;\n            n = j - 1;\n            p = k - 1;\n        } else if (x == 14) {\n            m = i - 1;\n            n = j;\n            p = k - 1;\n        } else if (x == 15) {\n            m = i - 1;\n            n = j + 1;\n            p = k - 1;\n        } else if (x == 16) {\n            m = i;\n            n = j;\n            p = k - 1;\n        }\n            // Layer above.\n        else if (x == 17) {\n            m = i + 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 18) {\n            m = i + 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 19) {\n            m = i + 1;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 20) {\n            m = i;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 21) {\n            m = i;\n            n = j + 1;\n            p = k + 1;\n        } else if (x == 22) {\n            m = i - 1;\n            n = j - 1;\n            p = k + 1;\n        } else if (x == 23) {\n            m = i - 1;\n            n = j;\n            p = k + 1;\n        } else if (x == 24) {\n            m = i - 1;\n            n = j + 1;\n            p = k + 1;\n        } else {\n            m = i;\n            n = j;\n            p = k + 1;\n        }\n        // If the memAgents at these coordinates is inside the world, has the relevant protein and belongs to different cells,\n        // increase the count by the level at those coordinates.\n\n        if (worldP->insideWorld(m, n, p)) {\n            if (worldP->grid[m][n][p].type == const_M) {\n            \t// Iterates over list of standard memAgents.\n                for (auto memAgent : worldP->grid[m][n][p].Mids) {\n                \t// Check that this memAgent is a junctional memAgent, it has the protein we're looking for, and that it belongs to a different cell.\n                \tif (memAgent->junction) {\n\t\t\t\t\t\tif (memAgent->has_protein(protein_name) && memAgent->Cell != this->Cell) {\n\t\t\t\t\t\t\tprotein_level+= memAgent->get_memAgent_protein_level(protein_name);\n\t\t\t\t\t\t}\n                \t}\n                }\n            }\n        }\n    }\n    return protein_level;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_filopodia_protein_level\n*  Description: Takes in a given protein level, counts the number of memAgents that own\n*\t\t\t\tthat protein then set the new level to that divided by the amount.\n*\t\t\t\tCan either distribute proteins to the same memagents from the same cell or to\n*  Returns:\t\tvoid\n******************************************************************************************/\n\n/*****************************************************************************************\n*  Name:\t\tdistribute_calculated_proteins\n*  Description: Takes in a given protein level, counts the number of memAgents that own\n*\t\t\t\tthat protein then set the new level to that divided by the amount.\n*\t\t\t\tCan either distribute proteins to the same memagents from the same cell or to\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid MemAgent::distribute_calculated_proteins(std::string protein_name, float total_protein_level, bool affects_this_cell) {\n\tint m, n, p;\n\tint i = (int) Mx;\n\tint j = (int) My;\n\tint k = (int) Mz;\n\n\tstd::vector<MemAgent*> relevant_memAgents;\n\n\tfor (int x = 0; x < 26; x++) {\n\t\t// Same layer.\n\t\tif (x == 0) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 1) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k;\n\t\t} else if (x == 2) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t} else if (x == 3) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 4) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t} else if (x == 5) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k;\n\t\t} else if (x == 6) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k;\n\t\t} else if (x == 7) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k;\n\t\t}\n\t\t\t// Layer below.\n\t\telse if (x == 8) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 9) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t} else if (x == 10) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 11) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 12) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 13) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 14) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t} else if (x == 15) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k - 1;\n\t\t} else if (x == 16) {\n\t\t\tm = i;\n\t\t\tn = j;\n\t\t\tp = k - 1;\n\t\t}\n\t\t\t// Layer above.\n\t\telse if (x == 17) {\n\t\t\tm = i + 1;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 18) {\n\t\t\tm = i + 1;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t} else if (x == 19) {\n\t\t\tm = i + 1;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 20) {\n\t\t\tm = i;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 21) {\n\t\t\tm = i;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 22) {\n\t\t\tm = i - 1;\n\t\t\tn = j - 1;\n\t\t\tp = k + 1;\n\t\t} else if (x == 23) {\n\t\t\tm = i - 1;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t} else if (x == 24) {\n\t\t\tm = i - 1;\n\t\t\tn = j + 1;\n\t\t\tp = k + 1;\n\t\t} else {\n\t\t\tm = i;\n\t\t\tn = j;\n\t\t\tp = k + 1;\n\t\t}\n\t\t// TODO: Tidy up these statements!\n\t\tif (worldP->insideWorld(m, n, p)) {\n\t\t\tif (worldP->grid[m][n][p].type == const_M) {\n\t\t\t\tfor (auto memAgent : worldP->grid[m][n][p].Mids) {\n\t\t\t\t\tif (affects_this_cell) {\n\t\t\t\t\t\t// Check for memAgents in this cell that have the protein.\n\t\t\t\t\t\tif (memAgent->has_protein(protein_name) && this->Cell == memAgent->Cell) {\n\t\t\t\t\t\t\trelevant_memAgents.push_back(memAgent);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!affects_this_cell) {\n\t\t\t\t\t\t// Check for memAgents in neighbouring junctions that have the protein.\n\t\t\t\t\t\tif (memAgent->junction) {\n\t\t\t\t\t\t\tif (memAgent->has_protein(protein_name) && this->Cell != memAgent->Cell) {\n\t\t\t\t\t\t\t\trelevant_memAgents.push_back(memAgent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (worldP->grid[m][n][p].type == const_E) {\n\t\t\t\t// Check for memAgents in filopodia.\n\t\t\t\tfor (auto memAgent : worldP->grid[m][n][p].Fids) {\n\t\t\t\t\tif (affects_this_cell) {\n\t\t\t\t\t\t// Check for memAgents in this cell that have the protein and are in a filopodia.\n\t\t\t\t\t\tif (memAgent->has_protein(protein_name) && this->Cell == memAgent->Cell && this->FIL != NONE) {\n\t\t\t\t\t\t\trelevant_memAgents.push_back(memAgent);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!affects_this_cell) {\n\t\t\t\t\t\t// TODO: DOUBLE-CHECK THIS.\n\t\t\t\t\t\t// Check for memAgents in neighbouring cells that have the protein.\n\t\t\t\t\t\tif (memAgent->has_protein(protein_name) && this->Cell != memAgent->Cell && this->FIL != NONE) {\n\t\t\t\t\t\t\trelevant_memAgents.push_back(memAgent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Divide out the protein evenly to all surrounding memAgents.\n\t\tint divisor = relevant_memAgents.size();\n\t\tfloat new_amount = total_protein_level / (float) divisor;\n\t\tfor (auto memAgent : relevant_memAgents) {\n\t\t\tmemAgent->set_protein_level(protein_name, new_amount);\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/memAgents.cpp b/src/memAgents.cpp
--- a/src/memAgents.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/src/memAgents.cpp	(date 1626714681796)
@@ -1203,19 +1203,12 @@
                             flagA = 1;
 
                             worldP->grid[m][n][p].Mids[y]->junction = true;
-                            if (worldP->timeStep == 0) {
-
-                            }
-
                             if (worldP->timeStep > 0) {
-
-                                //-------------------------------------------------------------------------------------------------------------
                                 //Anastamosis: create new spring junction to allow fusion, only on two tip cells
                                 if(StoreInJunctionList!=true){
                                     if(ANASTOMOSIS==true)
                                 anastomosis(worldP->grid[m][n][p].Mids[y]);
                                 }
-                                //-------------------------------------------------------------------------------------------------------------
                             }
                         }
                     }
@@ -1224,7 +1217,9 @@
         }
     }
 
-    if (flagA == 0) junction = false;
+    if (flagA == 0) {
+		junction = false;
+    }
     //StoreInJunctionList=false;
     if ((StoreInJunctionList) && (node) && (FIL == NONE)) {//&&(previousJunction!=junction)){
         //vector<MemAgent*>::iterator L;
@@ -1261,7 +1256,6 @@
         }
     }*/
     }
-    //-------------------------------------------------------------------------------------------------------------
 }
 //-------------------------------------------------------------------------------------------------------------------
 //-------------------------------------------------------------------------------------------------------------------
Index: src/EC.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#include <iostream>\n#include <vector>\n#include \"memAgents.h\"\n#include \"EC.h\"\n\nbool EC::tipCellTest(void){\n    \n    //as the original tip cell test said there had to be 1.2x initmemagents no. which here is 740 which gives 148 left over to be involved in filopodia..\n    //so as there would be slightly less spring agents than fil-memAgents in the previous model, as there are nodes in filopodia too we use 100\n    //this remains the same even if cvell size is smaller with ECcross>1 as the no of filopdia agents should be the same..\n    if((VEGFRtot>(float)VEGFRnorm/2.0f)&&(actinUsed>=257.0))return(true);\n    else return(false);\n    \n}\n//----------------------------------------------------------------------------------\n/**\n * \n * calculates total filopodia lengths on cell to see if overall maximum is reached\n * , if reached it will stop any further filopdia growth until some retract and more actin in available\n */\nvoid EC::calcCurrentActinUsed(void){\n   \n    actinUsed=0;\n\n    int i;\n    for(i=0;i<nodeAgents.size();i++)\n        if(nodeAgents[i]->FIL==TIP){\n           \n            actinUsed += nodeAgents[i]->FilLength(TIP);\n        }\n    \n  \n}\n//------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------------------------------------------------------\nint EC::calcVonNeighs(void){\n    int i;\n    int count=0;\n    for(i=0;i<(int)nodeAgents.size();i++){\n        nodeAgents[i]->vonNeu=false;\n        if(nodeAgents[i]->checkNeighsVonForEnv()){\n            count++;\n            nodeAgents[i]->vonNeu=true;\n            //nodeAgents[i]->labelled = true;\n        }\n    }\n    \n    for(i=0;i<(int)surfaceAgents.size();i++){\n        surfaceAgents[i]->vonNeu=false;\n        if(surfaceAgents[i]->checkNeighsVonForEnv()){\n            count++;\n            surfaceAgents[i]->vonNeu=true;\n            //surfaceAgents[i]->labelled = true;\n            \n        }\n    }\n    VonNeighs = count+springAgents.size();\n    return(count);\n}\n\n//----------------------------------------------------------------------------------------------------------------------------------------------\nvoid EC::allocateProts(void) {\n    \n    int i, j, div;\n    int divJunction=0;\n    int count=0;\n    \n    calcVonNeighs();\n    div = VonNeighs;//nodeAgents.size()+springAgents.size()+surfaceAgents.size();\n\n    //count how many agents are at the junction-----------------------------------------------\n    for (i = 0; i < nodeAgents.size(); i++) {\n        nodeAgents[i]->assessed=false;\n        nodeAgents[i]->JunctionTest(true);\n        if(nodeAgents[i]->junction) {\n\t\t\tdivJunction++;\n\t\t}\n    }\n\n    for (i = 0; i < springAgents.size(); i++){\n        springAgents[i]->assessed=false;\n        springAgents[i]->JunctionTest( true);\n        if(springAgents[i]->junction) {\n\t\t\tdivJunction++;\n\t\t}\n    }\n\n    for (i = 0; i < surfaceAgents.size(); i++) {\n        surfaceAgents[i]->assessed=false;\n        surfaceAgents[i]->JunctionTest( true);\n        if (surfaceAgents[i]->junction) {\n\t\t\tdivJunction++;\n\t\t}\n    }\n    \n    \n    /*int MfilTot = div-count;\n     * int MnotFilTot = count;\n     * float alpha = 1.3;\n     * float left;\n     * left = VEGFRtot-(MfilTot*((float)(VEGFRtot*alpha)/(float)div));*/\n    //-----------------------------------------------------------------------------------------------------\n    //set membrane prot levels for each cell----------------------------------------------------\n    \n    for (j = 0; j < nodeAgents.size(); j++) {\n        if (nodeAgents[j]->vonNeu) {\n\t\t\tnodeAgents[j]->VEGFR = (float)VEGFRtot / (float)div;\n        }\n        \n        if (nodeAgents[j]->junction) {\n            nodeAgents[j]->Notch1 = (float)NotchNorm / (float)divJunction;\n            nodeAgents[j]->Dll4 = (float)Dll4tot / (float)divJunction;\n        } else {\n            nodeAgents[j]->Notch1 = 0.0f;\n            nodeAgents[j]->Dll4 = 0.0f;\n        }\n    }\n\n    for (j = 0; j < springAgents.size(); j++) {\n        springAgents[j]->VEGFR=(float)VEGFRtot/(float)div;\n        //clustered VR-2 to filopodia\n        //if(springAgents[j-nodeAgents.size()]->FIL!=NONE) springAgents[j-nodeAgents.size()]->VEGFR=(float)(VEGFRtot*alpha)/(float)div;\n        //else springAgents[j-nodeAgents.size()]->VEGFR=(float)left/(float)MnotFilTot;\n        \n        if (springAgents[j]->junction) {\n            springAgents[j]->Notch1 = (float)NotchNorm / (float)divJunction;\n            springAgents[j]->Dll4 = (float)Dll4tot / (float)divJunction;\n        } else {\n            springAgents[j]->Notch1 = 0.0f;\n            springAgents[j]->Dll4 = 0.0f;\n        }\n    }\n\n    for (j = 0; j < surfaceAgents.size(); j++) {\n        if (surfaceAgents[j]->vonNeu) {\n\t\t\tsurfaceAgents[j]->VEGFR = (float)VEGFRtot / (float)div;\n        }\n        \n        //clustered VR-2 to filopodia\n        //if(springAgents[j-nodeAgents.size()]->FIL!=NONE) springAgents[j-nodeAgents.size()]->VEGFR=(float)(VEGFRtot*alpha)/(float)div;\n        //else springAgents[j-nodeAgents.size()]->VEGFR=(float)left/(float)MnotFilTot;\n        \n        if (surfaceAgents[j]->junction) {\n            surfaceAgents[j]->Notch1 = (float)NotchNorm / (float)divJunction;\n            surfaceAgents[j]->Dll4 = (float)Dll4tot / (float)divJunction;\n        } else {\n            surfaceAgents[j]->Notch1=0.0f;\n            surfaceAgents[j]->Dll4=0.0f;\n        }\n    }\n    //--------------------------------------------------------------------------------------------------\n}\n//-------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------------------------------------\nvoid EC::NotchDelay(void){\n    \n    int i;\n    std::vector<float>::iterator T=NotchDelayArray.begin();\n    actNotCurrent=0.0f;\n    \n    //add new activeNotch value to delay array\n    NotchDelayArray.push_back(activeNotchtot);\n    \n    //add the first element in the delay vector (has passed its delay time and can now have an effect)\n    //to the end of the lasts vector - where it will have an effect until it leaves the lasts stack.\n    NotchLastsArray.push_back(NotchDelayArray.front());\n    \n    //remove element from delay stack\n    NotchDelayArray.erase(T);\n    \n    //remove frst element in lasts array, it nolonger has an effect on VEGFR levels.\n    T=NotchLastsArray.begin();\n    NotchLastsArray.erase(T);\n    \n    //update current amount of active notch that has an effect on VEGFR levels (the sum of the lasts array)\n    \n    for(i=0;i<actNot_VEGFR_lasts;i++){\n        actNotCurrent=actNotCurrent+NotchLastsArray[i];\n    }\n    \n    \n}\n//-------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------------------------------------\nvoid EC::VEGFRDelay(void){\n    \n    int i;\n    actVEGFRcurrent=0.0f;\n\tstd::vector<float>::iterator T=VEGFRDelayArray.begin();\n    \n    VEGFRDelayArray.push_back(activeVEGFRtot);\n    \n    //add the first element in the delay vector (has passed its delay time and can now have an effect)\n    //to the end of the lasts vector - where it will have an effect until it leaves the lasts stack.\n    VEGFRlastsArray.push_back(VEGFRDelayArray.front());\n    \n    //remove element from delay stack\n    VEGFRDelayArray.erase(T);\n    \n    //remove frst element in lasts array, it nolonger has an effect on VEGFR levels.\n    T=VEGFRlastsArray.begin();\n    VEGFRlastsArray.erase(T);\n    \n    //update current amount of active notch that has an effect on VEGFR levels (the sum of the lasts array)\n    for(i=0;i<VEGFR_dll4_lasts;i++){\n        actVEGFRcurrent=actVEGFRcurrent+VEGFRlastsArray[i];\n    }\n}\n//-------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------------------------------------\nvoid EC::GRN(void){\n    \n    //down-reg VEGFR2 via notch\n    VEGFRtot=(VEGFRnorm)-(actNotCurrent*sigma); //VEGFRnorm is now a EC specific param and scaled at config if mutant\n\n    if(VEGFRtot<VEGFRmin) VEGFRtot=VEGFRmin;\n   \n    if(ANALYSIS_HYSTERESIS==true){\n        if((this != worldP->ECagents[0])&&(this!=worldP->ECagents[ECELLS-1]))\n            Dll4tot+=(actVEGFRcurrent*delta);\n        else{\n        //for the fixed cells at the ends of the row, fix Dll4tot at current increment.\n        Dll4tot = worldP->ECagents[1]->hyst.Current_Dll4_incremented_level;\n        }\n    }\n    else Dll4tot+=(actVEGFRcurrent*delta);\n    \n    if(Dll4tot>MAX_dll4){\n        Dll4tot=MAX_dll4;\n    }\n    \n}\n//---------------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------------\n//get new protein totals from Magents\nvoid EC::updateProteinTotals(void){\n    \n    int m;\n    int uptoN=nodeAgents.size();\n    int uptoS=springAgents.size();\n    int uptoSu=surfaceAgents.size();\n    \n    //VEGFRtot=0.0f;\n    Dll4tot=0.0f;\n    activeNotchtot=0.0f;\n    activeVEGFRtot=0.0f;\n    int junctionAgents=0;\n\n    for(m=0;m<uptoN;m++){\n        \n        activeVEGFRtot=activeVEGFRtot+nodeAgents[m]->VEGFRactive;\n        //if(nodeAgents[m]->junction==true){\n        activeNotchtot=activeNotchtot+nodeAgents[m]->activeNotch;\n        \n        Dll4tot=Dll4tot+nodeAgents[m]->Dll4;\n        //junctionAgents++;\n        //}\n    }\n    for(m=0;m<uptoS;m++){\n        \n        activeVEGFRtot=activeVEGFRtot+springAgents[m]->VEGFRactive;\n        //activeNotchtot=activeNotchtot+springAgents[m]->activeNotch;\n        \n        //Dll4tot=Dll4tot+springAgents[m]->Dll4;\n    }\n    for(m=0;m<uptoSu;m++){\n        \n        activeVEGFRtot=activeVEGFRtot+surfaceAgents[m]->VEGFRactive;\n        //if(surfaceAgents[m]->junction==true){\n        activeNotchtot=activeNotchtot+surfaceAgents[m]->activeNotch;\n\n        Dll4tot=Dll4tot+surfaceAgents[m]->Dll4;\n        //junctionAgents++;\n        //}\n    }\n    \n    //worldP->dataFile<<Dll4tot<<\" \"<<activeNotchtot<<\" \"<<junctionAgents<<endl;\n    NotchDelay();\n    VEGFRDelay();\n    //actNotCurrent = activeNotchtot;\n    //actVEGFRcurrent = activeVEGFRtot;\n}\n//---------------------------------------------------------------------------------\n/*void World::testNotchDll4(void){\n\nint i,j,k,m;\nint uptoN;\n    int uptoS;\n    int uptoSu;\n\n    uptoN=nodeAgents.size();\n    uptoS=springAgents.size();\n    uptoSu=surfaceAgents.size();\n\n    //VEGFRtot=0.0f;\n    Dll4tot=0.0f;\n    activeNotchtot=0.0f;\n    activeVEGFRtot=0.0f;\n    int junctionAgents=0;\n\n    int cells[4][4] = {0};\n\n    for(i=0;i<ECagents.size();i++){\n\n        for(m=0;m<uptoN;m++){\n        if(nodeAgents[m]->junction==true){\n            //need to check if it has aneigh of which cell\n            if()\n        }\n        }\n        for(m=0;m<uptoN;m++){\n        if(surfaceAgents[m]->junction==true){\n\n        }\n        }\n    }\n\n\n\n        activeVEGFRtot=activeVEGFRtot+nodeAgents[m]->VEGFRactive;\n        if(nodeAgents[m]->junction==true){\n        activeNotchtot=activeNotchtot+nodeAgents[m]->activeNotch;\n\n        Dll4tot=Dll4tot+nodeAgents[m]->Dll4;\n        junctionAgents++;\n        }\n    }\n    for(m=0;m<uptoS;m++){\n\n        activeVEGFRtot=activeVEGFRtot+springAgents[m]->VEGFRactive;\n        //activeNotchtot=activeNotchtot+springAgents[m]->activeNotch;\n\n        //Dll4tot=Dll4tot+springAgents[m]->Dll4;\n    }\n    for(m=0;m<uptoSu;m++){\n\n        activeVEGFRtot=activeVEGFRtot+surfaceAgents[m]->VEGFRactive;\n        if(surfaceAgents[m]->junction==true){\n        activeNotchtot=activeNotchtot+surfaceAgents[m]->activeNotch;\n\n        Dll4tot=Dll4tot+surfaceAgents[m]->Dll4;\n        junctionAgents++;\n        }\n    }\n\n    worldP->dataFile<<Dll4tot<<\" \"<<activeNotchtot<<\" \"<<junctionAgents<<endl;\n\n    }*/\n\n\n//------------------------------------------------------------------------------------------------\nvoid EC::characterizeActNotchBoundaries(int which, int other){\n    \n    int i, j, y, n, k, m, p, s, x, t, B, flag;\n    int sum=0;\n    bool allow;\n    int sumJunction=0;\n    MemAgent* np;\n    for(i=0;i<worldP->cellNeighbourhoods[which].size();i++){\n        junctionSizes.push_back(0);\n    }\n\tstd::vector <EC*> neighbours;\n    //hypothesis - why equal boundaries no offset fails more than equal boundaries offset - offset one is fighting on more fronts - or bigger fronts so has distributed its dll4 thinner all over as it were - so is essentially using less to inhibit the ones more likely to become tips - facing the vegf. We know that turing down dll4 helps the pattern to stabilise in high vegf...\n\n    //group agents into which boundary they are in, with which cell,\n    for(s=0;s<nodeAgents.size();s++){\n        // - show how many neighbour cells it has  and how big each bounday is.. in percentage of agents..\n        //and show total level of active notch on each boundary.\n        if(nodeAgents[s]->junction==true){\n             sumJunction++;\n            np = nodeAgents[s];\n            if((np->FIL==NONE)||(np->FIL==BASE)){\n                neighbours.clear();\n               \n                i=np->Mx; j=np->My; k=np->Mz;\n                \n                //same layer\n                for(x=0;x<26;x++){\n                    \n                    if(x==0){ m=i+1;n=j-1;p=k;}\n                    else if(x==1){ m=i+1;n=j;p=k;  }\n                    else if(x==2){ m=i+1;n=j+1;p=k;  }\n                    else if(x==3){ m=i;n=j-1;p=k;  }\n                    else if(x==4){ m=i;n=j+1;p=k;  }\n                    else if(x==5){ m=i-1;n=j-1;p=k; }\n                    else if(x==6){ m=i-1;n=j;p=k;  }\n                    else if(x==7){ m=i-1;n=j+1;p=k;}\n                    \n                    //layer below\n                    else if(x==8){m=i+1;n=j-1;p=k-1;}\n                    else if(x==9) {m=i+1;n=j;p=k-1;}\n                    else if(x==10){m=i+1;n=j+1;p=k-1;}\n                    else if(x==11) {m=i;n=j-1;p=k-1;}\n                    else if(x==12) {m=i;n=j+1;p=k-1;}\n                    else if(x==13) {m=i-1;n=j-1;p=k-1;}\n                    else if(x==14) {m=i-1;n=j;p=k-1;}\n                    else if(x==15) {m=i-1;n=j+1;p=k-1;}\n                    else if(x==16) {m=i;n=j;p=k-1;}\n                    \n                    //layer above\n                    else if(x==17) {m=i+1;n=j-1;p=k+1;}\n                    else if(x==18) {m=i+1;n=j;p=k+1;}\n                    else if(x==19) {m=i+1;n=j+1;p=k+1;}\n                    else if(x==20) {m=i;n=j-1;p=k+1;}\n                    else if(x==21) {m=i;n=j+1;p=k+1;}\n                    else if(x==22) {m=i-1;n=j-1;p=k+1;}\n                    else if(x==23) {m=i-1;n=j;p=k+1;}\n                    else if(x==24) {m=i-1;n=j+1;p=k+1;}\n                    else {m=i;n=j;p=k+1;}\n                    \n                    \n                    //-------------------------------\n                    //toroidal only X\n                    if(m >= worldP->gridXDimensions)\n                    \tm = 0;\n                    if(m < 0)\n                    \tm = worldP->gridXDimensions - 1;\n                    //-------------------------------\n                    \n                    if(worldP->insideWorld(m, n, p)==true){\n                        if(worldP->grid[m][n][p].type == const_M){\n                            for(y=0;y<(int)worldP->grid[m][n][p].Mids.size();y++){\n                                flag=0;\n                                if(worldP->grid[m][n][p].Mids[y]->Cell!=this){\n                                    //-----------------------------------------------------------------------\n                                    if(other==-1){\n                                    for(t=0;t<worldP->cellNeighbourhoods[which].size();t++){\n                                        if(flag==0){\n                                            if(worldP->grid[m][n][p].Mids[y]->Cell==worldP->cellNeighbourhoods[which][t]){\n                                                flag=1;\n                                                allow=true;\n                                                for(B=0;B<neighbours.size();B++){\n                                                    if(neighbours[B]==worldP->grid[m][n][p].Mids[y]->Cell) allow=false;\n                                                }\n                                                if(allow==true){\n                                                    junctionSizes[t]++ ;\n                                                    neighbours.push_back(worldP->grid[m][n][p].Mids[y]->Cell);\n                                                }\n                                                \n                                            }\n                                        }\n                                    }\n                                    if(flag==0) std::cout<<\"new neighbour somehow?!\"<<std::endl;\n                                    }\n                                    //----------------------------------------------------------------------\n                                    //just find against a specific neighbour cell\n                                    else{\n                                        if(worldP->grid[m][n][p].Mids[y]->Cell==worldP->cellNeighbourhoods[which][other]){\n                                                \n                                                allow=true;\n                                                for(B=0;B<neighbours.size();B++){\n                                                    if(neighbours[B]==worldP->grid[m][n][p].Mids[y]->Cell) allow=false;\n                                                }\n                                                if(allow==true){\n                                                    junctionSizes[t]++ ;\n                                                    neighbours.push_back(worldP->grid[m][n][p].Mids[y]->Cell);\n                                                }\n                                            }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    for(i=0;i<worldP->cellNeighbourhoods[which].size();i++){\n\t\tstd::cout<<junctionSizes[i]<<\" \";\n        sum+=junctionSizes[i];\n    }\n\tstd::cout<<std::endl;\n    //cout<<\"total: \"<<sum<<\"actual total(sum can be more tho as some agents are on two boundaries):\"<<sumJunction<<endl;\n    \n}\n//------------------------------------------------------------------------------------------------\n\nEC::EC(World*  world){\n\n\tworldP = world;\n\n\n\tmutant = false;\n\n\tfilCONST = FIL_VARY; //LTK link add user config value link here\n\n\t//wt values FLTK link\n\tVEGFRnorm = VEGFRNORM;\n\tVsink =VsinkNorm;\n\n\tif(VR2_HET==true){\n\t\tVEGFRnorm = VEGFRNORM*0.5;\n\t}\n\tif(VR1_HET==true) Vsink = Vsink*0.5;\n\n\t//add in for Dll4 HET/KO..\n\n\tVEGFRtot=VEGFRnorm;\n\tDll4tot=0.0f;\n\tNotchtot=0.0f;\n\tactiveNotchtot=0.0f;\n\tstableVEGFR=VEGFRnorm;\n\tbase_of_longest_fil= NULL;\n\tlength_of_longest_fil = 0;\n\tnewJunction = 0;\n\n\tactinUsed=0;\n\n\t//check this bit works when switching between setup versions\n\t// if(user_defined_fils_spacing == true) fixed_filopodia_spacing = 0; //FLTK link up needed here to config GUI!\n\t// else{\n\t//     if((CELL_SETUP==1)&&((ENV_SETUP==1)||(ENV_SETUP==4))) fixed_filopodia_spacing=1;//4;\n\t//     else\n\t//     fixed_filopodia_spacing=1;\n\t// }\n\n\tint i;\n\tfor(i=0;i<actNot_VEGFR_delay;i++){\n\t\tNotchDelayArray.push_back(0.0f);\n\t}\n\tfor(i=0;i<actNot_VEGFR_lasts;i++){\n\t\tNotchLastsArray.push_back(0.0f);\n\t}\n\tfor(i=0;i<VEGFR_dll4_delay;i++){\n\t\tVEGFRDelayArray.push_back(0.0f);\n\t}\n\tfor(i=0;i<VEGFR_dll4_lasts;i++){\n\t\tVEGFRlastsArray.push_back(0.0f);\n\t}\n\n\n\n\tVonNeighs = 0;\n\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_initial_proteins\n*  Description: Iterates over all cell proteins and allocates those proteins to all agents,\n *              assuming no filopodia exist yet.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::set_initial_proteins() {\n    // Create a vector containing the number of all memAgents that have a particular protein.\n    std::vector<int> protein_counts;\n    for (int i = 0; i <this->m_cell_type->proteins.size(); i++) {\n        protein_counts.push_back(0);\n    }\n\n    // Go over all the memAgents - if they use any protein that the cell has, increase the relevant count by one.\n    // TODO: We need to iterate over agents twice, because we don't know the count beforehand. Find a better way to do this.\n    // TODO: Have some sort of filter preventing proteins being allocated to filopodia, thus adjusting the count.\n    for (auto nodeAgent : this->nodeAgents) {\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n        \t// IF THE PROTEIN IS A JUNCTION PROTEIN, ONLY ADD IT TO JUNCTION AGENTS.\n        \tif (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_JUNCTION && nodeAgent->junction) {\n\t\t\t\tprotein_counts[i]++;\n        \t}\n\t\t\t// OTHERWISE, CHECK THAT IT IS EITHER A CELL OR MEMBRANE PROTEIN AND THAT THE AGENT IS NOT A JUNCTION AGENT.\n            if ((this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_MEMBRANE && !nodeAgent->junction)\n            \t\t|| (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_CELL && !nodeAgent->junction)) {\n\t\t\t\tprotein_counts[i]++;\n            }\n        }\n    }\n\n    // TODO: CHECK THAT WE'RE ONLY DISTRIBUTING PROTEINS TO NODE AGENTS.\n//    for (auto surfaceAgent : this->surfaceAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein_counts[i]++;\n//        }\n//    }\n//\n//    for (auto springAgent : this->springAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein_counts[i]++;\n//        }\n//    }\n\n    // Once counts have been determined, calculate the amount of each protein per memAgent.\n    std::vector<float> protein_totals_per_memAgent;\n\n    for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n        float current_protein_level = this->m_cell_type->proteins[i]->get_level();\n        float total_per_agent = current_protein_level / protein_counts[i];\n        protein_totals_per_memAgent.push_back(current_protein_level / protein_counts[i]);\n    }\n\n    // Now, create proteins for each memAgent and set the level at each agent to be equal to the calculated amount.\n    for (auto nodeAgent : this->nodeAgents) {\n        nodeAgent->add_cell_proteins();\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n\t\t\tif (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_JUNCTION && nodeAgent->junction) {\n\t\t\t\tprotein *current_protein = this->m_cell_type->proteins[i];\n\t\t\t\tnodeAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n\t\t\t}\n\t\t\tif ((this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_MEMBRANE && !nodeAgent->junction)\n\t\t\t\t|| (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_CELL && !nodeAgent->junction)) {\n\t\t\t\tprotein *current_protein = this->m_cell_type->proteins[i];\n\t\t\t\tnodeAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n\t\t\t}\n        }\n    }\n\n//    for (auto surfaceAgent : this->surfaceAgents) {\n//        surfaceAgent->add_cell_proteins();\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            surfaceAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n//        }\n//    }\n//\n//    for (auto springAgent : this->springAgents) {\n//        springAgent->add_cell_proteins();\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            springAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n//        }\n//    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tdistribute_proteins\n*  Description: Iterates over all cell proteins, counts the number of agents in the cell agent\n*               and distributes them out evenly\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::distribute_proteins() {\n    // Create a vector containing the number of all memAgents that have a particular protein.\n\tstd::vector<int> protein_counts;\n    for (int i = 0; i <this->m_cell_type->proteins.size(); i++) {\n        protein_counts.push_back(0);\n    }\n\n    // Go over all the memAgents - if they use any protein that the cell has, increase the relevant count by one.\n    // TODO: We need to iterate over agents twice, because we don't know the count beforehand. Find a better way to do this.\n    // TODO: Have some sort of filter preventing proteins being allocated to filopodia, thus adjusting the count.\n    for (auto nodeAgent : this->nodeAgents) {\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n            protein *current_protein = this->m_cell_type->proteins[i];\n\t\t\tif (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_JUNCTION && nodeAgent->junction) {\n\t\t\t\tif (nodeAgent->has_protein(current_protein->get_name())) {\n\t\t\t\t\tprotein_counts[i]++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif ((this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_MEMBRANE && !nodeAgent->junction)\n\t\t\t\t|| (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_CELL && !nodeAgent->junction)) {\n\t\t\t\tif (nodeAgent->has_protein(current_protein->get_name())) {\n\t\t\t\t\tprotein_counts[i]++;\n\t\t\t\t}\n\t\t\t}\n        }\n    }\n\n//    for (auto surfaceAgent : this->surfaceAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            if (surfaceAgent->has_protein(current_protein->get_name())) {\n//                protein_counts[i]++;\n//            }\n//        }\n//    }\n\n//    for (auto springAgent : this->springAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            if (springAgent->has_protein(current_protein->get_name())) {\n//                protein_counts[i]++;\n//            }\n//        }\n//    }\n\n    // Once counts have been determined, calculate the amount of each protein per memAgent.\n\tstd::vector<int> protein_totals_per_memAgent;\n\n    for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n        float current_protein_level = this->m_cell_type->proteins[i]->get_level();\n        protein_totals_per_memAgent.push_back(current_protein_level / protein_counts[i]);\n    }\n\n    // Now, set the memAgents level to be equal to the calculated amount.\n    for (auto nodeAgent : this->nodeAgents) {\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n            protein *current_protein = this->m_cell_type->proteins[i];\n\t\t\tif (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_JUNCTION && nodeAgent->junction) {\n\t\t\t\tif (nodeAgent->has_protein(current_protein->get_name())) {\n\t\t\t\t\tnodeAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_MEMBRANE && !nodeAgent->junction)\n\t\t\t\t|| (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_CELL && !nodeAgent->junction)) {\n\t\t\t\tif (nodeAgent->has_protein(current_protein->get_name())) {\n\t\t\t\t\tnodeAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n\t\t\t\t}\n\t\t\t}\n        }\n    }\n\n//    for (auto surfaceAgent : this->surfaceAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            if (surfaceAgent->has_protein(current_protein->get_name())) {\n//                surfaceAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n//            }\n//        }\n//    }\n//\n//    for (auto springAgent : this->springAgents) {\n//        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n//            protein *current_protein = this->m_cell_type->proteins[i];\n//            if (springAgent->has_protein(current_protein->get_name())) {\n//                springAgent->update_protein_level(current_protein->get_name(), protein_totals_per_memAgent[i]);\n//            }\n//        }\n//    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcalculate_cell_protein_levels\n*  Description: Calculates the protein levels across all memAgents and passes the total to\n*               the cell.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::calculate_cell_protein_levels() {\n    std::vector<float> protein_counts;\n    for (auto protein : this->m_cell_type->proteins) {\n        protein_counts.push_back(0);\n    }\n\n    //TODO: ADD A CALL TO THE FUNCTION THAT RUNS THE ODES AT EACH MEMAGENT.\n\n    // Determine the new totals for each protein in the cell, by checking the levels at all memAgents that have that protein.\n    for (auto nodeAgent : this->nodeAgents) {\n        //Attempt to run ODEs at this memagent.\n        this->worldP->run_ODEs(this->m_cell_type->m_name, nodeAgent);\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n            protein *current_protein = this->m_cell_type->proteins[i];\n            if (nodeAgent->has_protein(current_protein->get_name())) {\n                //Determine the amount for the current protein at this memAgent and update the total for that\n                float current_protein_level = nodeAgent->get_memAgent_protein_level(current_protein->get_name());\n                protein_counts[i] += current_protein_level;\n            }\n        }\n    }\n\n    for (auto surfaceAgent : this->surfaceAgents) {\n        //Attempt to run ODEs at this memagent.\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n            protein *current_protein = this->m_cell_type->proteins[i];\n            if (surfaceAgent->has_protein(current_protein->get_name())) {\n                float current_protein_level = surfaceAgent->get_memAgent_protein_level(current_protein->get_name());\n                protein_counts[i] += current_protein_level;\n            }\n        }\n    }\n\n    for (auto springAgent : this->springAgents) {\n        //Attempt to run ODEs at this memagent.\n        for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n            protein *current_protein = this->m_cell_type->proteins[i];\n            if (springAgent->has_protein(current_protein->get_name())) {\n                float current_protein_level = springAgent->get_memAgent_protein_level(current_protein->get_name());\n                protein_counts[i] += current_protein_level;\n            }\n        }\n    }\n\n    // Now, set the protein levels for the cell.\n    for (int i = 0; i < this->m_cell_type->proteins.size(); i++) {\n        this->m_cell_type->proteins[i]->set_level(protein_counts[i]);\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_cell_type\n*  Description: Sets the cell type of a cell agent.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::set_cell_type(Cell_Type *cell_type) {\n    this->m_cell_type = cell_type;\n}\n\n/*****************************************************************************************\n*  Name:\t\thas_protein\n*  Description: Returns true if the protein is owned by the cell.\n*  Returns:\t\tbool\n******************************************************************************************/\n\nbool EC::has_protein(std::string protein_name) {\n    for (auto protein : this->m_cell_type->proteins) {\n        if (protein->get_name() == protein_name) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tprint_protein_levels\n*  Description: Prints protein totals of a cell\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::print_protein_levels(int timestep_interval) {\n\tif (this->worldP->timeStep % timestep_interval == 0) {\n\t\tfor (auto protein : this->m_cell_type->proteins) {\n\t\t\tstd::cout << \"Protein: \" << protein->get_name()\n\t\t\t\t\t  << \" Level at timestep \" << this->worldP->timeStep\n\t\t\t\t\t  << \": \" << protein->get_level() << std::endl;\n\t\t}\n\t}\n}\n\n/*****************************************************************************************\n*  Name:\t\tadd_to_neighbour_list\n*  Description: If a queried cell is not already included in this cell's list of neighbours,\n*  \t\t\t\tthen add it. This should only be called when a cell is attempting to form\n*  \t\t\t\tjunction agents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid EC::add_to_neighbour_list(EC* query_ec) {\n\tbool cell_found = false;\n\tfor (auto current_ec : this->neigh_cells) {\n\t\tif (current_ec != query_ec) {\n\t\t\tcell_found = true;\n\t\t}\n\t}\n\t// Cell not found in neighbour list, so add it.\n\tif (!cell_found) {\n\t\tthis->neigh_cells.push_back(query_ec);\n\t}\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_cell_protein_level\n*  Description: If a cell possesses a protein, then return the amount that cell has of that protein.\n*  Returns:\t\tfloat\n******************************************************************************************/\n\nfloat EC::get_cell_protein_level(std::string protein_name) {\n\t// This assert should always pass when calculating cell levels, as we're checking this in the calculate cell protein totals function.\n\t// This is also used during ODE running and so has the potential to fail.\n\tif (this->has_protein(protein_name)) {\n\t\tfor (auto protein : this->m_cell_type->proteins) {\n\t\t\tif (protein->get_name() == protein_name) {\n\t\t\t\treturn protein->get_level();\n\t\t\t}\n\t\t}\n\t}\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/EC.cpp b/src/EC.cpp
--- a/src/EC.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/src/EC.cpp	(date 1626715945412)
@@ -648,7 +648,6 @@
 				if (nodeAgent->has_protein(current_protein->get_name())) {
 					protein_counts[i]++;
 				}
-
 			}
 			if ((this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_MEMBRANE && !nodeAgent->junction)
 				|| (this->m_cell_type->proteins[i]->get_location() == PROTEIN_LOCATION_CELL && !nodeAgent->junction)) {
Index: src/Tissue.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Thomas Mead on 30/09/2020.\n//\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <cassert>\n\n#include \"Tissue.h\"\n#include \"memAgents.h\"\n#include \"EC.h\"\n#include \"logger.h\"\n\n//********************************************************************************************************************//\n\n// Tissue Container\n\n//********************************************************************************************************************//\n\n/*****************************************************************************************\n*  Name:\t\tdefine_cell_type\n*  Description: Reads in cell information (i.e. geometry) from dsl_tissue.cpp and creates a\n*               new cell type object to store that information.\n*  Returns:\t\t*Cell_Type\n******************************************************************************************/\n\nCell_Type *Tissue_Container::define_cell_type(std::string name, int cell_shape_type, int height, int width) {\n    Cell_Type *cell_type;\n    Shape_Square *square_pointer;\n    try {\n        if (cell_shape_type == CELL_SHAPE_SQUARE) {\n            assert(height > 0);\n            assert(width > 0);\n            square_pointer = new Shape_Square(cell_shape_type, height, width);\n        } else {\n            throw 1;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid shape definition called (square) for specified shape type: \"\n                  << cell_shape_type << \". Exception type: \" << e;\n    }\n    cell_type = new Cell_Type(this, std::move(name), square_pointer);\n    store_cell_type(cell_type);\n    return cell_type;\n}\n\n/************************************************************ *****************************\n*  Name:\t\tdefine_tissue_type (cylindrical)\n*  Description: Reads in tissue information (i.e. arrangement) from dsl_tissue.cpp and\n*               creates a new cylindrical tissue_type object to store that information.\n*  Returns:\t\t*Tissue_Type_Cylindrical\n******************************************************************************************/\n\nTissue_Type_Cylindrical *Tissue_Container::define_tissue_type(std::string name,\n                                                              Cell_Type *cell_type,\n                                                              int tissue_configuration,\n                                                              int cross_section_cells,\n                                                              int length_in_cells,\n                                                              int total_radius) {\n    Tissue_Type_Cylindrical *tissue_type;\n    try {\n        if (tissue_configuration == CELL_CONFIGURATION_CYLINDRICAL) {\n            assert(cross_section_cells > 0);\n            assert(length_in_cells > 0);\n            assert(total_radius > 0);\n            tissue_type = new Tissue_Type_Cylindrical(this,\n                                                      name,\n                                                      cell_type,\n                                                      tissue_configuration,\n                                                      cross_section_cells,\n                                                      length_in_cells,\n                                                      total_radius);\n            store_tissue_type(tissue_type);\n        } else {\n            throw 2;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid tissue definition called (CYLINDRICAL) for specified shape type: \"\n                  << tissue_configuration << \". Exception type: \" << e;\n    }\n    return tissue_type;\n}\n\n/*****************************************************************************************\n*  Name:\t\tdefine_tissue_type (flat)\n*  Description: Reads in tissue information (i.e. arrangement) from dsl_tissue.cpp and\n*               creates a new flat tissue_type object to store that information.\n*  Returns:\t\t*Tissue_Type_Flat\n******************************************************************************************/\n\nTissue_Type_Flat *Tissue_Container::define_tissue_type(std::string name,\n                                                       Cell_Type *cell_type,\n                                                       int tissue_configuration,\n                                                       int height_in_cells,\n                                                       int width_in_cells) {\n    Tissue_Type_Flat *tissue_type;\n    try {\n        if (tissue_configuration == CELL_CONFIGURATION_FLAT) {\n            assert(height_in_cells > 0);\n            assert(width_in_cells > 0);\n            tissue_type = new Tissue_Type_Flat(this,\n                                               name,\n                                               cell_type,\n                                               tissue_configuration,\n                                               height_in_cells,\n                                               width_in_cells);\n            store_tissue_type(tissue_type);\n        } else {\n            throw 3;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid tissue definition called (FLAT) for specified shape type: \"\n                  << tissue_configuration << \". Exception type: \" << e;\n    }\n    return tissue_type;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcreate_cell\n*  Description: Reads in a Cell_Type object and uses the stored information\n*               to create a Cell object, before creating a cell agent object (which is stored\n*               in World) and calling a memAgent creation function based on the cell's shape.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::create_cell(std::string name, Cell_Type *cell_type, Coordinates *position) {\n    Cell *cell;\n    try {\n        assert(cell_type != NULL);\n        assert(position != NULL);\n        if (cell_type->m_shape->get_shape_type() == CELL_SHAPE_SQUARE) {\n\n            cell = new Cell(this, name, m_world, position, cell_type);\n            cell->determine_boundaries();\n            store_cell(cell);\n            EC *ecp = new EC((World*) m_world);\n            //TODO: Have run number logging use a variable.\n\n            // Create a logger for protein levels.\n//            ecp->logger = new cell_logger(1, m_world->time, ecp);\n\n            ecp->belongs_to = BELONGS_TO_SINGLECELL;\n\n\t\t\t//Add the cell to list of the world's known cell agents.\n            m_world->ECagents.push_back(ecp);\n\n            ecp->cell_number = m_world->ECagents.size();\n\n\t\t\t//Add the cell to list of tissue container's known cell agents.\n\t\t\tthis->m_single_cell_agents.push_back(ecp);\n\n\t\t\t//Assign the cell agent to the cell object.\n\t\t\tcell->cell_agent = ecp;\n\t\t\tecp->m_cell = cell;\n\t\t\tecp->m_cell_type = cell->m_cell_type;\n\n            check_position(cell);\n\n            create_2d_square_cell(m_single_cell_agents.size(),\n                                  cell->m_position->get_x_coord(),\n                                  cell->m_position->get_y_coord(),\n                                  cell->m_position->get_z_coord(),\n                                  cell->m_cell_type->m_shape->get_width(),\n                                  cell->m_cell_type->m_shape->get_height());\n\n            connect_2d_square_cell(m_single_cell_agents.size());\n        } else {\n            throw 4;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid tissue creation called (SQUARE) for specified shape type: \"\n                  << cell_type->m_shape->get_shape_type() << \". Exception type: \" << e;\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcreate_tissue (cylindrical)\n*  Description: Reads in a Tissue_Type object and uses the stored information\n*               to create a Tissue_Vessel object, then calls a function to create\n*               memAgents in a cylindrical shape before connecting them with spring agents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::create_tissue(std::string name, Tissue_Type_Cylindrical *tissue_type, Coordinates *position) {\n    Tissue_Vessel *tissue;\n    try {\n        assert(tissue_type != nullptr);\n        assert(position != nullptr);\n        if (tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_CYLINDRICAL) {\n            tissue = new Tissue_Vessel(this, m_world, position, name, tissue_type);\n            tissue->determine_boundaries();\n            check_position(tissue);\n            tissue->create_vessel();\n            tissue->tissue_vessel_connect_mesh();\n            store_tissue(tissue);\n        }\n    } catch (int e) {\n        std::cout <<\"Invalid tissue definition called (FLAT) for specified shape type: \"\n                << tissue_type->get_tissue_configuration() << \". Exception type: \" << e;\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcreate_tissue (flat)\n*  Description: Reads in a Tissue_Type object and uses the stored information\n*               to create a Tissue_Monolayer object, then calls a function to create\n*               memAgents in a flat, planar shape before connecting them with spring agents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::create_tissue(std::string name, Tissue_Type_Flat *tissue_type, Coordinates *position) {\n    Tissue_Monolayer *tissue;\n    try {\n        assert(tissue_type != nullptr);\n        assert(position != nullptr);\n        if (tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_FLAT) {\n            tissue = new Tissue_Monolayer(this, m_world, position, name, tissue_type);\n            tissue->determine_boundaries();\n            check_position(tissue);\n            tissue->create_monolayer();\n            store_tissue(tissue);\n        }\n    } catch (int e) {\n        std::cout <<\"Invalid tissue definition called (FLAT) for specified shape type: \"\n                  << tissue_type->get_tissue_configuration() << \". Exception type: \" << e;\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tstore_cell_type\n*  Description: Adds cell type object to the parent tissue container's list of cell types.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::store_cell_type(Cell_Type *cell_type) {\n    assert(cell_type != nullptr);\n    this->cell_types.push_back(cell_type);\n}\n\n/*****************************************************************************************\n*  Name:\t\tstore_tissue_type\n*  Description: Adds tissue type object to the parent tissue container's list of tissue types.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::store_tissue_type(Tissue_Type *tissue_type) {\n    assert(tissue_type != nullptr);\n    this->tissue_types.push_back(tissue_type);\n}\n\n/*****************************************************************************************\n*  Name:\t\tstore_cell\n*  Description: Adds cell object to the parent tissue container's list of cells.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::store_cell(Cell *cell) {\n    assert(cell != nullptr);\n    this->cells.push_back(cell);\n}\n\n/*****************************************************************************************\n*  Name:\t\tstore_tissue\n*  Description: Adds tissue object to the parent tissue container's list of tissues.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::store_tissue(Tissue *tissue) {\n    assert(tissue != nullptr);\n    this->tissues.push_back(tissue);\n}\n\n/*****************************************************************************************\n*  Name:\t\tcreate_2d_square_cell\n*  Description: Places memAgents in a 2D square shape within the world grid. Used to create\n*   \t\t\tindividual cells in the world.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::create_2d_square_cell(int cell_number,\n                                             int centreX,\n                                             int centreY,\n                                             int centreZ,\n                                             int cell_width,\n                                             int cell_height) {\n\n    //assert(centreX > 0); <- Check the effect of a periodic boundary on this.\n    assert(centreY >= 0);\n    assert(centreZ >= 0);\n    assert(cell_width >= 0);\n    assert(cell_height >= 0);\n\n    // Create node memAgents in a square.\n    int i, j;\n    MemAgent *memp;\n\n    for (i = (int) (centreX - (float) cell_width / 2.0f); i < (int) (centreX + (float) cell_width / 2.0f); i++) {\n        for (j = (int) (centreY - (float) cell_height / 2.0f); j < (int) (centreY + (float) cell_height / 2.0f); j++) {\n            //TODO: HAVE INDIVIDUAL CELLS ADDED TO A NEW VECTOR IN WORLD AND LOOP OVER THESE.\n            memp = new MemAgent(m_single_cell_agents[cell_number-1], (World *) this->m_world);\n            memp->Mx = (float) i;\n            memp->My = (float) j;\n            memp->Mz = (float) centreZ;\n            m_single_cell_agents[cell_number-1]->nodeAgents.push_back(memp);\n            m_world->setMLocation(int(i), int(j), centreZ, memp);\n            memp->node = true;\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tconnect_2d_square_cell\n*  Description: Connects memAgents in a 2D square shape within the world grid.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::connect_2d_square_cell(int cell_number) {\n    int e,i;\n    int uptoM;\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    int kelp;\n\n    uptoM = m_single_cell_agents[cell_number-1]->nodeAgents.size();\n\n    for (i = 0; i < uptoM; i++){\n        mp = m_single_cell_agents[cell_number-1]->nodeAgents[i];\n        N=0;\n\n        if (m_world->insideWorld(mp->Mx-1, mp->My, mp->Mz)) {\n\n            if (m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].type == const_M) {\n\n                for (kelp = 0; kelp < m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids.size(); kelp++) {\n                    nmp = m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids[kelp];\n\n                    if(mp->Cell == nmp->Cell) {\n                        mp->neigh[N] = nmp;\n                        m_single_cell_agents[cell_number-1]->createSpringTokenObject(mp, nmp, N);\n                        mp->SpringNeigh[N]->horizontal = true;\n                        mp->SpringNeigh[N]->right = false;\n                        N++;\n                        mp->neighs++;\n                    }\n                }\n            }\n        }\n        if (m_world->insideWorld(mp->Mx+1, mp->My, mp->Mz)) {\n\n            if (m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].type== const_M) {\n\n                for(kelp=0;kelp<m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids.size();kelp++) {\n                    nmp = m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids[kelp];\n\n                    if(mp->Cell == nmp->Cell) {\n                        mp->neigh[N] = nmp;\n                        m_single_cell_agents[cell_number-1]->createSpringTokenObject(mp, nmp, N);\n                        mp->SpringNeigh[N]->horizontal = true;\n                        mp->SpringNeigh[N]->right = true;\n                        N++;\n                        mp->neighs++;\n                    }\n                }\n            }\n        }\n        if ((m_world->insideWorld(mp->Mx, mp->My-1, mp->Mz))) {\n\n            if (m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)cells[cell_number-1]->m_position->get_z_coord()].type== const_M) {\n\n                for(kelp=0;kelp<m_world->grid[(int)mp->Mx][(int)mp->My-1][0].Mids.size();kelp++) {\n                    nmp = m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids[kelp];\n\n                    if (mp->Cell == nmp->Cell) {\n                        mp->neigh[N] = nmp;\n                        m_single_cell_agents[cell_number-1]->createSpringTokenObject(mp, nmp, N);\n                        mp->SpringNeigh[N]->horizontal = false;\n                        mp->SpringNeigh[N]->right = true;\n                        N++;\n                        mp->neighs++;\n                    }\n                }\n            }\n        }\n        if (m_world->insideWorld(mp->Mx, mp->My + 1, mp->Mz)) {\n\n            if (m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)cells[cell_number-1]->m_position->get_z_coord()].type== const_M) {\n\n                for(kelp = 0; kelp < m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids.size();kelp++) {\n                    nmp = m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids[kelp];\n\n                    if (mp->Cell == nmp->Cell) {\n                        mp->neigh[N]=nmp;\n                        m_single_cell_agents[cell_number-1]->createSpringTokenObject(mp, nmp, N);\n                        mp->SpringNeigh[N]->horizontal = false;\n                        mp->SpringNeigh[N]->right = false;\n                        N++;\n                        mp->neighs++;\n                    }\n                }\n            }\n        }\n        if(m_world->insideWorld(mp->Mx, mp->My, mp->Mz)){\n\n            for(kelp = 0;kelp < m_world->grid[(int)mp->Mx][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids.size(); kelp++) {\n                nmp = m_world->grid[(int)mp->Mx][(int)mp->My][(int)cells[cell_number-1]->m_position->get_z_coord()].Mids[kelp];\n\n                if (mp->Cell != nmp->Cell) {\n                    mp->neigh[N]=nmp;\n                    m_single_cell_agents[cell_number-1]->createSpringTokenObject(mp, nmp, N);\n                    mp->SpringNeigh[N]->horizontal = true;\n                    mp->SpringNeigh[N]->right = false;\n                    N++;\n                    mp->neighs++;\n                }\n            }\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_positions\n*  Description: Checks that objects within the tissue container do not overlap.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::check_positions() {\n    Cell *current_cell;\n    Tissue *current_tissue;\n    for (int i; i < cells.size(); i++) {\n        current_cell = cells[i];\n        assert(current_cell->check_boundaries());\n    }\n\n    for (int i; i < tissues.size(); i++) {\n        current_tissue = tissues[i];\n        assert(current_tissue->check_boundaries());\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_position (Cell)\n*  Description: Checks that a cell object does not overlap with other objects in the world.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\n\nvoid Tissue_Container::check_position(Cell *cell) {\n    assert(cell->check_boundaries());\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_position (Tissue)\n*  Description: Checks that a tissue object does not overlap with other objects in the world.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Container::check_position(Tissue *tissue) {\n    assert(tissue->check_boundaries());\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_cell_cell_overlap\n*  Description: Checks that whether two cells overlap, returns true if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_cell_cell_overlap(Cell *cell_1, Cell *cell_2) {\n    if (cell_1->m_position->get_z_coord() == cell_2->m_position->get_z_coord()) {\n        // TODO: LOOK INTO CLEVERER WAYS TO DO THIS.\n\n        // The following if/else statement checks these conditions:\n        // Is this cell's lower x-boundary value within the x-boundaries of the compared cell?\n        // Is this cell's upper x-boundary value within the x-boundaries of the compared cell?\n\n        // Is this cell's lower y-boundary value within the y-boundaries of the compared cell?\n        // Is this cell's upper y-boundary value within the y-boundaries of the compared cell?\n\n        if ((cell_1->m_boundaries[0].get_x_coord() >= cell_2->m_boundaries[0].get_x_coord()\n             && cell_1->m_boundaries[0].get_x_coord() <= cell_2->m_boundaries[1].get_x_coord())\n            || (cell_1->m_boundaries[1].get_x_coord() >= cell_2->m_boundaries[0].get_x_coord()\n                && cell_1->m_boundaries[1].get_x_coord() <= cell_2->m_boundaries[1].get_x_coord())) {\n\n            if ((cell_1->m_boundaries[0].get_y_coord() >= cell_2->m_boundaries[0].get_y_coord()\n                 && cell_1->m_boundaries[0].get_y_coord() <= cell_2->m_boundaries[1].get_y_coord())\n                || (cell_1->m_boundaries[1].get_y_coord() >= cell_2->m_boundaries[0].get_y_coord()\n                    && cell_1->m_boundaries[1].get_y_coord() <= cell_2->m_boundaries[1].get_y_coord())) {\n                return true; // <- Overlap detected, so return true.\n            }\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_cell_vessel_overlap\n*  Description: Checks that whether a cell and a vessel-like tissue overlap, returns true\n*               if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_cell_vessel_overlap(Cell *cell, Tissue_Vessel *vessel) {\n\n    float vessel_upper_z_bound = float(vessel->get_vessel_total_radius()) + vessel->get_vessel_centre_z_coord();\n    float vessel_lower_z_bound = float(vessel->get_vessel_total_radius()) - vessel->get_vessel_centre_z_coord();\n\n    // If the cell is between the upper and lower z-boundaries of the vessel, work out the Y-coordinate using\n    // Pythagoras' theorem.\n    if ((cell->m_boundaries[0].get_z_coord() >= vessel_lower_z_bound\n         && cell->m_boundaries[0].get_z_coord() <= vessel_upper_z_bound)\n        || (cell->m_boundaries[1].get_z_coord() >= vessel_lower_z_bound\n            && cell->m_boundaries[1].get_z_coord() <= vessel_upper_z_bound)) {\n\n        float cell_z_offset = cell->m_position->get_z_coord() - vessel->get_vessel_centre_z_coord();\n        cell_z_offset = cell_z_offset * cell_z_offset;\n\n        float vessel_radius_squared = float(vessel->get_vessel_total_radius()) * float(vessel->get_vessel_total_radius());\n\n        float vessel_y_boundary_offset = sqrt(vessel_radius_squared - cell_z_offset);\n        float vessel_y_lower_boundary = vessel->get_vessel_centre_y_coord() - vessel_y_boundary_offset;\n        float vessel_y_upper_boundary = vessel->get_vessel_centre_y_coord() + vessel_y_boundary_offset;\n\n        if ((cell->m_boundaries[0].get_y_coord() >= vessel_y_lower_boundary\n             && cell->m_boundaries[0].get_y_coord() <= vessel_y_upper_boundary)\n            || (cell->m_boundaries[1].get_y_coord() >= vessel_y_lower_boundary\n                && cell->m_boundaries[1].get_y_coord() <= vessel_y_upper_boundary)) {\n            return true; // <- Overlap detected, so return false to the assert statement calling this function.\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_cell_monolayer_overlap\n*  Description: Checks that whether a cell and a monolayer-like tissue overlap, returns true\n*               if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_cell_monolayer_overlap(Cell *cell, Tissue_Monolayer *monolayer) {\n    if (cell->m_position->get_z_coord() == monolayer->m_position->get_z_coord()) {\n\n        // The following if statement checks these conditions:\n        // Is this cell's lower x-boundary value within the x-boundaries of the compared monolayer?\n        // Is this cell's upper x-boundary value within the x-boundaries of the compared monolayer?\n\n        // Is this cell's lower y-boundary value within the y-boundaries of the compared monolayer?\n        // Is this cell's upper y-boundary value within the y-boundaries of the compared monolayer?\n\n        if ((cell->m_boundaries[0].get_x_coord() >= monolayer->m_boundaries[0].get_x_coord()\n             && cell->m_boundaries[0].get_x_coord() <= monolayer->m_boundaries[1].get_x_coord())\n            || (cell->m_boundaries[1].get_x_coord() >= monolayer->m_boundaries[0].get_x_coord()\n                && cell->m_boundaries[1].get_x_coord() <= monolayer->m_boundaries[1].get_x_coord())) {\n\n            if ((cell->m_boundaries[0].get_y_coord() >= monolayer->m_boundaries[0].get_y_coord()\n                 && cell->m_boundaries[0].get_y_coord() <= monolayer->m_boundaries[1].get_y_coord())\n                || (cell->m_boundaries[1].get_y_coord() >= monolayer->m_boundaries[0].get_y_coord()\n                    && cell->m_boundaries[1].get_y_coord() <= monolayer->m_boundaries[1].get_y_coord())) {\n                return true; // <- Overlap detected, so return true.\n            }\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_vessel_vessel_overlap\n*  Description: Checks that whether two vessel-like tissues overlap, returns true if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_vessel_vessel_overlap(Tissue_Vessel *vessel_1, Tissue_Vessel *vessel_2) {\n    float min_dist, y_offset, z_offset, y_offset_squared, z_offset_squared;\n\n    auto vessel_1_radius = float(vessel_1->get_vessel_total_radius());\n    auto vessel_2_radius = float(vessel_2->get_vessel_total_radius());\n\n    y_offset = vessel_1->get_vessel_centre_y_coord() - vessel_2->get_vessel_centre_y_coord();\n    z_offset = vessel_1->get_vessel_centre_z_coord() - vessel_2->get_vessel_centre_z_coord();\n    y_offset_squared = y_offset * y_offset;\n    z_offset_squared = z_offset * z_offset;\n\n    min_dist = sqrt(y_offset_squared + z_offset_squared);\n\n    if (vessel_1_radius + vessel_2_radius >= min_dist) {\n        return true;\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_vessel_monolayer_overlap\n*  Description: Checks that whether a vessel-like tissue and a monolayer-like overlap,\n*               returns true if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_vessel_monolayer_overlap(Tissue_Vessel *vessel, Tissue_Monolayer *monolayer) {\n\n    float vessel_upper_z_bound = float(vessel->get_vessel_total_radius()) + vessel->get_vessel_centre_z_coord();\n    float vessel_lower_z_bound = float(vessel->get_vessel_total_radius()) - vessel->get_vessel_centre_z_coord();\n\n    // If the monolayer is between the upper and lower z-boundaries of the vessel, work out the Y-coordinate using\n    // Pythagoras' theorem.\n    if ((monolayer->m_boundaries[0].get_z_coord() >= vessel_lower_z_bound\n         && monolayer->m_boundaries[0].get_z_coord() <= vessel_upper_z_bound)\n        || (monolayer->m_boundaries[1].get_z_coord() >= vessel_lower_z_bound\n            && monolayer->m_boundaries[1].get_z_coord() <= vessel_upper_z_bound)) {\n\n        float monolayer_z_offset = monolayer->m_position->get_z_coord() - vessel->get_vessel_centre_z_coord();\n        monolayer_z_offset = monolayer_z_offset * monolayer_z_offset;\n\n        float vessel_radius_squared = float(vessel->get_vessel_total_radius()) * float(vessel->get_vessel_total_radius());\n\n        float vessel_y_boundary_offset = sqrt(vessel_radius_squared - monolayer_z_offset);\n        float vessel_y_lower_boundary = vessel->get_vessel_centre_y_coord() - vessel_y_boundary_offset;\n        float vessel_y_upper_boundary = vessel->get_vessel_centre_y_coord() + vessel_y_boundary_offset;\n\n        if ((monolayer->m_boundaries[0].get_y_coord() >= vessel_y_lower_boundary\n             && monolayer->m_boundaries[0].get_y_coord() <= vessel_y_upper_boundary)\n            || (monolayer->m_boundaries[1].get_y_coord() >= vessel_y_lower_boundary\n                && monolayer->m_boundaries[1].get_y_coord() <= vessel_y_upper_boundary)) {\n            return true; // <- Overlap detected, so return false to the assert statement calling this function.\n        }\n    }\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_monolayer_monolayer_overlap\n*  Description: Checks that whether two monolayer-like tissues overlap, returns true if so.\n*  Returns:\t\tboolean\n******************************************************************************************/\n\nbool Tissue_Container::check_monolayer_monolayer_overlap(Tissue_Monolayer *monolayer_1, Tissue_Monolayer *monolayer_2) {\n    if (monolayer_1->m_position->get_z_coord() == monolayer_2->m_position->get_z_coord()) {\n\n        // The following if statements checks these conditions:\n        // Is this monolayer's lower x-boundary value within the x-boundaries of the compared monolayer?\n        // Is this monolayer's upper x-boundary value within the x-boundaries of the compared monolayer?\n\n        // Is this monolayer's lower y-boundary value within the y-boundaries of the compared monolayer?\n        // Is this monolayer's upper y-boundary value within the y-boundaries of the compared monolayer?\n\n        if ((monolayer_1->m_boundaries[0].get_x_coord() >= monolayer_2->m_boundaries[0].get_x_coord()\n             && monolayer_1->m_boundaries[0].get_x_coord() <= monolayer_2->m_boundaries[1].get_x_coord())\n            || (monolayer_1->m_boundaries[1].get_x_coord() >= monolayer_2->m_boundaries[0].get_x_coord()\n                && monolayer_1->m_boundaries[1].get_x_coord() <= monolayer_2->m_boundaries[1].get_x_coord())) {\n\n            if ((monolayer_1->m_boundaries[0].get_y_coord() >= monolayer_2->m_boundaries[0].get_y_coord()\n                 && monolayer_1->m_boundaries[0].get_y_coord() <= monolayer_2->m_boundaries[1].get_y_coord())\n                || (monolayer_1->m_boundaries[1].get_y_coord() >= monolayer_2->m_boundaries[0].get_y_coord()\n                    && monolayer_1->m_boundaries[1].get_y_coord() <= monolayer_2->m_boundaries[1].get_y_coord())) {\n                return true; // <- Overlap detected, so return true.\n            }\n        }\n    }\n    return false;\n}\n\n\n// Constructor //\n\nTissue_Container::Tissue_Container(World *world): m_world(world) {\n\n}\n\n//********************************************************************************************************************//\n\n// Cell Type\n\n//********************************************************************************************************************//\n\n// Constructor //\n\nCell_Type::Cell_Type(Tissue_Container *tissue_container, std::string name, Shape *shape) {\n    assert(shape != nullptr);\n    m_tissue_container = tissue_container;\n    m_name = name;\n    m_shape = shape;\n}\n\n/*****************************************************************************************\n*  Name:\t\tadd_protein\n*  Description: Adds protein to the cell type.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Cell_Type::add_protein(protein *new_protein) {\n    this->proteins.push_back(new_protein);\n}\n\n//********************************************************************************************************************//\n\n// Cell\n\n//********************************************************************************************************************//\n\n\n/*****************************************************************************************\n*  Name:\t\tcreate_2d_square_cell\n*  Description: Creates node agents in a square.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nbool Cell::check_boundaries() {\n    Cell *current_cell;\n    Tissue *current_tissue;\n\n    for (int i = 0; i < m_tissue_container->cells.size(); i++) {\n        current_cell = m_tissue_container->cells[i];\n        if (current_cell != this) {\n            if (m_tissue_container->check_cell_cell_overlap(this, current_cell)) {\n                return false; // <- Overlap detected, send false to the assert statement calling this function.\n            }\n        }\n    }\n\n    for (int i = 0; i < m_tissue_container->tissues.size(); i++) {\n        current_tissue = m_tissue_container->tissues[i];\n        if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_FLAT) {\n            auto *current_monolayer = dynamic_cast<Tissue_Monolayer *>(current_tissue);\n            if (m_tissue_container->check_cell_monolayer_overlap(this, current_monolayer)) {\n                return false; // <- Overlap detected, send false to the assert statement calling this function.\n            }\n        }\n        else if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_CYLINDRICAL) {\n            auto *current_vessel = dynamic_cast<Tissue_Vessel *>(current_tissue);\n\n            if (m_tissue_container->check_cell_vessel_overlap(this, current_vessel)) {\n                return false; // <- Overlap detected, send false to the assert statement calling this function.\n            }\n        }\n    }\n    return true;\n}\n\n/*****************************************************************************************\n*  Name:\t\tdetermine_boundaries\n*  Description: Calculates the lowest and highest X and Y-coordinates of an individual cell.\n*               and stores them in the Cell object.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Cell::determine_boundaries() {\n    float x_coord_1, x_coord_2, y_coord_1, y_coord_2;\n    Coordinates cell_end_1, cell_end_2;\n\tstd::vector<Coordinates> boundary_coords;\n\n    float cell_width = float(m_cell_type->m_shape->get_width());\n    float cell_height = float(m_cell_type->m_shape->get_height());\n\n    x_coord_1 = m_position->get_x_coord() - (cell_width/2.0f);\n    y_coord_1 = m_position->get_y_coord() - (cell_height/2.0f);\n\n    cell_end_1 = Coordinates(x_coord_1, y_coord_1, m_position->get_z_coord());\n    boundary_coords.push_back(cell_end_1);\n\n    x_coord_2 = m_position->get_x_coord() + (cell_width /2.0f);\n    y_coord_2 = m_position->get_y_coord() + (cell_height /2.0f);\n\n    cell_end_2 = Coordinates(x_coord_2, y_coord_2, m_position->get_z_coord());\n    boundary_coords.push_back(cell_end_2);\n\n    this->m_boundaries = boundary_coords;\n}\n\n// Constructor //\n\nCell::Cell(Tissue_Container *tissue_container,\n\t\t   std::string name,\n           World *world,\n           Coordinates *position,\n           Cell_Type *cell_type) {\n    assert(world != nullptr);\n    assert(position != nullptr);\n    assert(cell_type != nullptr);\n\n    m_tissue_container = tissue_container;\n    m_name = name;\n    m_world = world;\n    m_position = position;\n    m_cell_type = cell_type;\n}\n\n//********************************************************************************************************************//\n\n// Tissue Type\n\n//********************************************************************************************************************//\n\n// General //\n\n/*****************************************************************************************\n*  Name:\t\tget_name - generic (virtual)\n*  Description: Returns the tissue's name.\n*  Returns:\t\tstring\n******************************************************************************************/\n\nstd::string Tissue_Type::get_name() {\n    return std::string();\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_tissue_configuration - generic (virtual)\n*  Description: Returns the enum value associated with the tissue's arrangement.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type::get_tissue_configuration() {\n    return -1;\n}\n\n// Constructor //\n\nTissue_Type::Tissue_Type(Tissue_Container *tissue_container,\n\t\t\t\t\t\t std::string name,\n                         Cell_Type *cell_type,\n                         int tissue_configuration) {\n    assert(cell_type != nullptr);\n\n    m_tissue_container = tissue_container;\n    m_name = name;\n    m_tissue_configuration = tissue_configuration;\n    m_cell_type = cell_type;\n}\n\n// Cylindrical //\n\n/*****************************************************************************************\n*  Name:\t\tget_name - cylindrical\n*  Description: Returns the tissue's name.\n*  Returns:\t\tstring\n******************************************************************************************/\n\nstd::string Tissue_Type_Cylindrical::get_name() {\n    return this->m_name;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_tissue_configuration - cylindrical\n*  Description: Returns the enum value associated with the tissue's arrangement.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Cylindrical::get_tissue_configuration() {\n    return this->m_tissue_configuration;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_length_in_cells - cylindrical\n*  Description: Returns the length of the tissue in cells.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Cylindrical::get_length_in_cells() {\n    return this->m_cylinder_length_in_cells;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_cells_per_cross_section - cylindrical\n*  Description: Returns the number of cells which form the circumference of the vessel.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Cylindrical::get_cells_per_cross_section() {\n    return this->m_cylinder_cells_per_cross_section;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_cells_per_cross_section - cylindrical\n*  Description: Returns the radius of the tissue in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Cylindrical::get_total_radius() {\n    return this->m_cylinder_total_radius;\n}\n\n// Constructor //\n\nTissue_Type_Cylindrical::Tissue_Type_Cylindrical(Tissue_Container *tissue_container,\n\t\t\t\t\t\t\t\t\t\t\t\t std::string name,\n                                                 Cell_Type *cell_type,\n                                                 int tissue_configuration,\n                                                 int cylinder_cells_per_cross_section,\n                                                 int cylinder_length_in_cells,\n                                                 int cylinder_total_radius)\n        : Tissue_Type(tissue_container, name, cell_type, tissue_configuration) {\n    try {\n        assert(cell_type != nullptr);\n        if (tissue_configuration == CELL_CONFIGURATION_CYLINDRICAL) {\n            assert(cylinder_cells_per_cross_section > 0);\n            assert(cylinder_length_in_cells > 0);\n            assert(cylinder_total_radius > 0);\n\n            this->m_cylinder_cells_per_cross_section = cylinder_cells_per_cross_section;\n            this->m_cylinder_length_in_cells = cylinder_length_in_cells;\n            this->m_cylinder_total_radius = cylinder_total_radius;\n        }\n        else {\n            throw 5;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid tissue configuration called (cylindrical) for specified configuration: \"\n                  << tissue_configuration << \". Exception type: \" << e;\n    }\n}\n\n// Flat //\n\n/*****************************************************************************************\n*  Name:\t\tget_name - flat\n*  Description: Returns the tissue's name.\n*  Returns:\t\tstring\n******************************************************************************************/\n\nstd::string Tissue_Type_Flat::get_name() {\n    return this->m_name;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_tissue_configuration - flat\n*  Description: Returns the enum value associated with the tissue's arrangement.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Flat::get_tissue_configuration() {\n    return this->m_tissue_configuration;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_height_in_cells - flat\n*  Description: Returns the height of the flat tissue in cells.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Flat::get_height_in_cells() {\n    return this->m_flat_height_in_cells;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_width_in_cells - flat\n*  Description: Returns the height of the flat tissue in cells.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Type_Flat::get_width_in_cells() {\n    return this->m_flat_width_in_cells;\n}\n\n// Constructor //\n\nTissue_Type_Flat::Tissue_Type_Flat(Tissue_Container *tissue_container,\n\t\t\t\t\t\t\t\t   std::string name,\n                                   Cell_Type *cell_type,\n                                   int tissue_configuration,\n                                   int flat_height_in_cells,\n                                   int flat_width_in_cells)\n        : Tissue_Type(tissue_container, name, cell_type, tissue_configuration) {\n    try {\n        if (tissue_configuration == CELL_CONFIGURATION_FLAT) {\n            assert(flat_height_in_cells > 0);\n            assert(flat_width_in_cells > 0);\n            this->m_flat_height_in_cells = flat_height_in_cells;\n            this->m_flat_width_in_cells = flat_width_in_cells;\n        }\n        else {\n            throw 5;\n        }\n    } catch (int e) {\n        std::cout << \"Invalid tissue configuration called (flat) for specified configuration: \"\n                  << tissue_configuration << \". Exception type: \" << e;\n    }\n\n}\n\n//********************************************************************************************************************//\n\n// General Tissue\n\n//********************************************************************************************************************//\n\n// Getters //\n\n/*****************************************************************************************\n*  Name:\t\tget_name\n*  Description: Returns the total number of cells in the tissue.\n*  Returns:\t\tstring\n******************************************************************************************/\n\nstd::string Tissue::get_name() {\n    return this->m_name;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_n_cells\n*  Description: Returns the total number of cells in the tissue.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue::get_n_cells() {\n\treturn this->m_cell_number;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_tissue_type\n*  Description: Returns a pointer to a tissue's associated tissue_type object\n*  Returns:\t\t*Tissue_Type\n******************************************************************************************/\n\nTissue_Type* Tissue::get_tissue_type() {\n    return this->m_tissue_type;\n}\n\n// Setters //\n\n/*****************************************************************************************\n*  Name:\t\tget_name\n*  Description: Returns the total number of cells in the tissue.\n*  Returns:\t\tstring\n******************************************************************************************/\n\nvoid Tissue::set_name(std::string name) {\n    this->m_name = name;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_n_cells\n*  Description: Records the total number of cells in the tissue.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue::set_n_cells(int n_cells) {\n\tthis->m_cell_number = n_cells;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_tissue_type\n*  Description: Records a tissue's associated tissue_type object.\n*  Returns:\t\t*Tissue_Type\n******************************************************************************************/\n\nvoid Tissue::set_tissue_type(Tissue_Type *tissue_type) {\n    this->m_tissue_type = tissue_type;\n}\n\n/*****************************************************************************************\n*  Name:\t\tstore_cell_agent\n*  Description: Stores an endothelial cell agent object in a tissue's list of associated\n*               cell agents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue::store_cell_agent(EC *ecp) {\n\tthis->m_cell_agents.push_back(ecp);\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_boundaries (virtual)\n*  Description: Checks that tissue object does not overlap with other objects.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nbool Tissue::check_boundaries() {\n    return false;\n}\n\n/*****************************************************************************************\n*  Name:\t\tdetermine_boundaries (virtual)\n*  Description: Calculates the lowest and highest X, Y coordinates of a tissue.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue::determine_boundaries() {\n\n}\n\n// Constructor //\n\nTissue::Tissue( Tissue_Container *tissue_container,\n                World *world,\n                Coordinates *position,\n\t\t\t\tstd::string name,\n                Tissue_Type *tissue_type )\n\t\t        : m_tissue_container(tissue_container),\n\t\t          m_world(world),\n\t\t          m_position(position),\n\t\t          m_name(name),\n\t\t          m_tissue_type(tissue_type) {\n\ttry {\n        assert(world != nullptr);\n        assert(position != nullptr);\n        assert(tissue_type != nullptr);\n\t\tif (tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_CYLINDRICAL\n\t\t|| tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_FLAT) {\n\t\t\tstd::cout << \"Tissue created successfully.\" << std::endl;\n\t\t} else {\n\t\t\tthrow 6;\n\t\t}\n\t} catch (int e) {\n\t\tstd::cout << \"Exception: Invalid tissue configuration: \"\n\t\t\t\t  << tissue_type->get_tissue_configuration()\n\t\t\t\t  << \". Exception Type: \"\n\t\t\t\t  << e\n\t\t\t\t  << std::endl;\n\t}\n}\n\n//********************************************************************************************************************//\n\n//Tissue Setup Functions\n\n//********************************************************************************************************************//\n\n//TODO: ENABLE CREATION OF 3D CELLS WITH DSL.\n\n//void Tissue::tissue_create_3d_cell() {\n//\tint radius = (float)m_cell_width / 2.0f;\n//\tint height = 8;\n//\tint j, k;\n//\n//\tfor (int i = 0; i < m_cell_number; i++) {\n//\t\t//creates new object dynamically of type EC (ecp is the e cell pointer)\n//\t\tEC * ecp = new EC((World*) this);\n//\n//\t\t//put the address into the vector Ecells\n//\t\tm_world->ECagents.push_back(ecp);\n//\n//\t\tm_world->ECagents[i]->VEGFRtot = 0;\n//\t}\n//\n//\t//create node agents in a square and connect up in a square\n//\n//\tfloat dist;\n//\tbool allow = false;\n//\tMemAgent* memp;\n//\tint centreX = (int)((float)xMAX / 2.0f);\n//\tint centreY = 10;//(int)((float)yMAX/2.0f);\n//\tstd::cout<<centreX<<\" \"<<centreY<<std::endl;\n//\n//\tfor (int i = (int)(centreX- (float)m_cell_width / 2.0f); i <= (int)(centreX + (float)m_cell_width / 2.0f); i++) {\n//\t\tfor (j = (int)(centreY- (float)m_cell_width / 2.0f); j <= (int)(centreY + (float)m_cell_width / 2.0f); j++) {\n//\t\t\tfor(k = 1; k < height; k++) {\n//\t\t\t\tallow=false;\n//\t\t\t\tif((k == 1) || (k == height-1)) {\n//\t\t\t\t\tif(m_world->getDist(i, j, k, centreX, centreY, k)<=radius+0.5) {\n//\t\t\t\t\t\tallow=true;\n//\t\t\t\t\t}\n//\t\t\t\t} else {\n//\t\t\t\t\tdist=m_world->getDist(i, j, k, centreX, centreY, k);\n//\t\t\t\t\tif((dist<=radius+0.5)&&(dist>=radius-0.8f)) {\n//\t\t\t\t\t\tallow = true;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\n//\t\t\t\tif(allow==true){\n//\t\t\t\t\t//lower disc\n//\t\t\t\t\tmemp = new MemAgent(m_world->ECagents[0], (World*) this);\n//\t\t\t\t\tmemp->Mx = (float)i;\n//\t\t\t\t\tmemp->My = (float)j;\n//\t\t\t\t\tmemp->Mz = (float)k;\n//\t\t\t\t\tm_world->ECagents[0]->nodeAgents.push_back(memp);\n//\t\t\t\t\tm_world->setMLocation(int(i), int(j), k, memp);\n//\t\t\t\t\tmemp->node = true;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t}\n//\t//connect mesh\n//\tint uptoM = m_world->ECagents[0]->nodeAgents.size();\n//\tMemAgent* mp;\n//\tMemAgent* nmp;\n//\tint N;\n//\n//\tfor (int i = 0; i < uptoM; i++) {\n//\t\tmp = m_world->ECagents[0]->nodeAgents[i];\n//\t\tN=0;\n//\n//\t\tif(m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].type == M) {\n//\t\t\tnmp = m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = true;\n//\t\t\tmp->SpringNeigh[N]->right = false;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\n//\t\tif(m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].type==M){\n//\t\t\tnmp = m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = true;\n//\t\t\tmp->SpringNeigh[N]->right = true;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\n//\t\tif(m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].type==M){\n//\t\t\tnmp = m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = false;\n//\t\t\tmp->SpringNeigh[N]->right = true;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\n//\t\tif(m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].type==M){\n//\t\t\tnmp = m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = false;\n//\t\t\tmp->SpringNeigh[N]->right = false;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\n//\t\tif(m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz+1].type==M){\n//\t\t\tnmp = m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz+1].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = false;\n//\t\t\tmp->SpringNeigh[N]->right = false;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\n//\t\tif(m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz-1].type==M){\n//\t\t\tnmp = m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz-1].Mids[0];\n//\t\t\tmp->neigh[N]=nmp;\n//\t\t\tm_world->ECagents[0]->createSpringTokenObject(mp, nmp, N);\n//\t\t\tmp->SpringNeigh[N]->horizontal = false;\n//\t\t\tmp->SpringNeigh[N]->right = false;\n//\t\t\tN++;\n//\t\t\tmp->neighs++;\n//\t\t}\n//\t}\n//}\n\n//********************************************************************************************************************//\n\n//Vessel Setup Functions\n\n//********************************************************************************************************************//\n\n// GETTERS //\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_length\n*  Description: Gets a vessel's length in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint  Tissue_Vessel::get_vessel_length() {\n    return this->m_vessel_length;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_length_in_cells\n*  Description: Gets a vessel's length in cells.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Vessel::get_vessel_length_in_cells() {\n    return this->m_vessel_length;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_cells_per_cross_section\n*  Description: Gets the number of cells that make up a vessel's circumference.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Vessel::get_vessel_cells_per_cross_section() {\n    return this->m_vessel_cells_per_cross_section;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_interior_radius\n*  Description: Gets the interior radius of the vessel (i.e. the lumen) in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Vessel::get_vessel_interior_radius() {\n    return this->m_vessel_interior_radius;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_interior_radius\n*  Description: Gets the interior radius of the vessel (i.e. the lumen) in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Vessel::get_vessel_total_radius() {\n    return this->m_vessel_total_radius;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_dist_from_edge\n*  Description: Gets the distance of the vessel from the edge of the simulation world in\n*               memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nint Tissue_Vessel::get_vessel_dist_from_edge() {\n    return this->m_vessel_dist_from_edge;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_centre_y_coord\n*  Description: Gets the y coordinate of the vessel's centre.\n*  Returns:\t\tint\n******************************************************************************************/\n\nfloat Tissue_Vessel::get_vessel_centre_y_coord() {\n    return this->m_vessel_centre_y_coord;\n}\n\n/*****************************************************************************************\n*  Name:\t\tget_vessel_centre_z_coord\n*  Description: Gets the z coordinate of the vessel's centre.\n*  Returns:\t\tint\n******************************************************************************************/\n\nfloat Tissue_Vessel::get_vessel_centre_z_coord() {\n    return this->m_vessel_centre_z_coord;\n}\n\n// SETTERS //\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_length\n*  Description: Records the length of the vessel in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\n\nvoid Tissue_Vessel::set_vessel_length( int vessel_length ) {\n    this->m_vessel_length = vessel_length;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_length_in_cells\n*  Description: Records the length of the vessel in cells.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_length_in_cells( int vessel_length_in_cells ) {\n    this->m_vessel_length_in_cells = vessel_length_in_cells;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_cells_per_cross_section\n*  Description: Records the number of cells that form the circumference of the vessel.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_cells_per_cross_section( int vessel_cells_per_cross_section ) {\n    this->m_vessel_cells_per_cross_section = vessel_cells_per_cross_section;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_interior_radius\n*  Description: Records the radius of the vessel interior (i.e. lumen) in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_interior_radius( int vessel_interior_radius ) {\n    this->m_vessel_interior_radius = vessel_interior_radius;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_interior_radius\n*  Description: Records the total radius of the vessel interior (i.e. lumen and cells) in\n*               memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_total_radius( int vessel_total_radius ) {\n    this->m_vessel_total_radius = vessel_total_radius;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_dist_from_edge\n*  Description: Records the distance of the vessel from the simulation boundary in memAgents.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_dist_from_edge( int vessel_dist_from_edge ) {\n    this->m_vessel_dist_from_edge = vessel_dist_from_edge;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_centre_y_coord\n*  Description: Records the y coordinate of the vessel's centre.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_centre_y_coord( float vessel_centre_y_coord ) {\n    this->m_vessel_centre_y_coord = vessel_centre_y_coord;\n}\n\n/*****************************************************************************************\n*  Name:\t\tset_vessel_centre_y_coord\n*  Description: Records the z coordinate of the vessel's centre.\n*  Returns:\t\tint\n******************************************************************************************/\n\nvoid Tissue_Vessel::set_vessel_centre_z_coord( float vessel_centre_z_coord ) {\n    this->m_vessel_centre_z_coord = vessel_centre_z_coord;\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_boundaries\n*  Description: Checks that tissue object does not overlap with other objects.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nbool Tissue_Vessel::check_boundaries() {\n    Cell *current_cell;\n    Tissue *current_tissue;\n\n    for (int i = 0; i < m_tissue_container->cells.size(); i++) {\n        current_cell = m_tissue_container->cells[i];\n        if (m_tissue_container->check_cell_vessel_overlap(current_cell, this)) {\n            return false; // <- Overlap detected, send false to the assert statement calling this function.\n        }\n    }\n\n    for (int i = 0; i < m_tissue_container->tissues.size(); i++) {\n        current_tissue = m_tissue_container->tissues[i];\n        if (current_tissue != this) {\n            if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_FLAT) {\n                auto *current_monolayer = dynamic_cast<Tissue_Monolayer *>(current_tissue);\n                if (m_tissue_container->check_vessel_monolayer_overlap(this, current_monolayer)) {\n                    return false; // <- Overlap detected, send false to the assert statement calling this function.\n                }\n            } else if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_CYLINDRICAL) {\n                auto *current_vessel = dynamic_cast<Tissue_Vessel *>(current_tissue);\n                if (m_tissue_container->check_vessel_vessel_overlap(this, current_vessel)) {\n                    return false; // <- Overlap detected, send false to the assert statement calling this function.\n                }\n            }\n        }\n    }\n    return true;\n}\n\n/*****************************************************************************************\n*  Name:\t\tdetermine_boundaries (vessel)\n*  Description: Calculates the lowest and highest X, Y coordinates of a vessel-like tissue.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Vessel::determine_boundaries() {\n    float x_coord_1, x_coord_2;\n    Coordinates vessel_end_1, vessel_end_2;\n\tstd::vector<Coordinates> boundary_coords;\n\n    x_coord_1 = m_position->get_x_coord() - (float(m_vessel_length)/2.0f);\n    vessel_end_1 = Coordinates(x_coord_1, m_position->get_y_coord(), m_position->get_z_coord());\n    boundary_coords.push_back(vessel_end_1);\n\n    x_coord_2 = m_position->get_x_coord() + (float(m_vessel_length)/2.0f);\n    vessel_end_2 = Coordinates(x_coord_2, m_position->get_y_coord(), m_position->get_z_coord());\n    boundary_coords.push_back(vessel_end_2);\n\n    this->m_boundaries = boundary_coords;\n}\n\n// CONSTRUCTOR //\n\nTissue_Vessel::Tissue_Vessel(  Tissue_Container *tissue_container,\n                               World *world,\n                               Coordinates *position,\n\t\t\t\t\t\t\t   std::string name,\n                               Tissue_Type_Cylindrical *tissue_type)\n        : Tissue( tissue_container,\n                  world,\n                  position,\n                  name,\n                  tissue_type ),\n                  m_vessel_cells_per_cross_section(tissue_type->m_cylinder_cells_per_cross_section),\n                  m_vessel_length_in_cells(tissue_type->m_cylinder_length_in_cells),\n                  m_vessel_total_radius(tissue_type->m_cylinder_total_radius) {\n    try {\n        assert(world != nullptr);\n        assert(position != nullptr);\n        assert(tissue_type != nullptr);\n        if (tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_CYLINDRICAL ) {\n            set_n_cells(tissue_type->get_length_in_cells() * tissue_type->get_cells_per_cross_section());\n            set_vessel_length(tissue_type->get_length_in_cells() * tissue_type->m_cell_type->m_shape->get_width());\n            set_vessel_interior_radius(tissue_type->get_total_radius() - 2 );\n            set_vessel_centre_y_coord(position->get_y_coord());\n            set_vessel_centre_z_coord(position->get_z_coord());\n            std::cout << \"Tissue: Vessel created successfully!\" << std::endl;\n\n        } else {\n            throw 7;\n        }\n    } catch (int e) {\n        std::cout << \"Exception: Incorrect tissue constructor (vessel) called for specified configuration: \"\n                  << tissue_type->get_tissue_configuration()\n                  << \". Exception Type: \"\n                  << e\n                  << std::endl;\n    }\n}\n\n//  FUNCTIONS //\n\n/*****************************************************************************************\n*  Name:\t\tcreate_vessel\n*  Description: Instantiates a cell agent, stores it in the world and parent tissue object,\n*               sets the colour of cell (for graphical purposes) before entering the\n*               cylindrical memAgent creation function.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Vessel::create_vessel() {\n    for (int i = 0; i < m_cell_number ; i++) {\n        int cell_width = this->m_tissue_type->m_cell_type->m_shape->get_width();\n\n        // Creates new cell agent and returns a pointer to it.\n        EC *ecp = new EC((World*) m_world);\n\n        ecp->set_cell_type(this->m_tissue_type->m_cell_type);\n\n        // Put the address into the world vector Ecells\n        m_world->ECagents.push_back(ecp);\n\n        // Add this agent to the relevant tissue.\n        store_cell_agent(ecp);\n        // Create a logger for protein levels.\n//        ecp->logger = new cell_logger(1, m_world->time, ecp);\n\n        ecp->belongs_to = BELONGS_TO_CYLINDER;\n\n        ecp->cell_number = i;\n\n        // Set the cell agents' VEGFR level to 0.\n\t\tthis->m_cell_agents[i]->VEGFRtot = 0;\n\n\t\t// Set the cell's colour in the graphical interface.\n        this->m_cell_agents[i]->red = ((float)rand()/(float)RAND_MAX);\n\t\tthis->m_cell_agents[i]->green = ((float)rand()/(float)RAND_MAX);\n\t\tthis->m_cell_agents[i]->blue = ((float)rand()/(float)RAND_MAX);\n\n\t\t// For each memAgent along the cell's width, create enough memAgents vertically to\n\t\t// complete the cell.\n        for (int j = 0; j < cell_width; j++) {\n            this->tissue_vessel_draw_mesh(i, j, ecp);\n        }\n\n        if (ANALYSIS_HYSTERESIS==true){\n            m_world->ECagents[i]->hyst.Cell = m_world->ECagents[i];\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\ttissue_vessel_draw_mesh\n*  Description: Places memAgents in a vessel shape and assigns them to the corresponding cell\n*               agents.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Vessel::tissue_vessel_draw_mesh(int i, int j, EC* ecp) {\n    float theta;\n    int cell_width = this->m_tissue_type->m_cell_type->m_shape->get_width();\n    float delta;\n    float k, l, X, Y, Z;\n    int lx;\n    float thetaStart, deltaSteps;\n    float depth;\n    MemAgent* memp;\n    int circlePosStartAb=0;\n    delta = ((2.0f * (float)Pi) / (float)m_vessel_cells_per_cross_section);\n\n    //Calculate the total number of memAgents that form the vessel circumference, and therefore the number per cell.\n    int totalAbSteps = (int)(2.0f * (float)Pi * (float)m_vessel_total_radius);\n    int ablumenalSteps = (int)((float)totalAbSteps / (float)m_vessel_cells_per_cross_section);\n\n    deltaSteps = delta / float(ablumenalSteps);\n    float offset;\n    float offsetPercentage;\n\n    // Tidy this bit up.\n    float x = (float)i / (float)m_vessel_cells_per_cross_section;\n    lx = (int)x;\n    depth = cell_width * lx;\n    thetaStart = delta * (float)i;\n    circlePosStartAb = ablumenalSteps*i;\n\n    if (lx % 2 != 0) {\n        offset=0.5;\n        thetaStart+=offset*delta;\n        circlePosStartAb+=(int)(offset*ablumenalSteps);\n    }\n\n    circlePosStartAb = circlePosStartAb % int(ablumenalSteps * m_vessel_cells_per_cross_section);\n\n    if( thetaStart >= 2 * Pi ) {\n        thetaStart -= 2 * Pi;\n    }\n\n    int lowerXboundary = this->m_boundaries[0].x;\n\n    X = (float)j; // X-Coordinate is not currently set, will need to think about this when changing the periodic boundary.\n    Y = (float)m_vessel_centre_y_coord;\n    Z = (float)m_vessel_centre_z_coord;\n\n\n    for (int J = 0; J < ablumenalSteps; J++) {\n\n        theta = thetaStart + (deltaSteps * (float)J);\n        k = (float)m_vessel_total_radius * cos(theta);\n        l = (float)m_vessel_total_radius * sin(theta);\n\n    //If within vessel, but not lumen, create a memAgent.\n        if (m_world->insideWorld(j + depth + (float)lowerXboundary, k+Y, l+Z)) {\n\n            memp = new MemAgent(ecp, this->m_world);\n\n            memp->Mx = (float)j + (float)depth + (float)lowerXboundary;\n            memp->My = k+Y;\n            memp->FA = true;\n            //---------------------------------------\n            ///for CELL_SETUP=2 (lars and rearrangement paper models with sewn up front).\n            ///label the front row of nodes so they can be sewn up once gridded\n            if (BLINDENDED_SPROUT==true){\n                if ((i == m_cell_number - 1) || (i == m_cell_number - 2)) {\n                    if(j == cell_width - 1) memp->labelledBlindended =  true;\n                }\n            }\n            //---------------------------------------\n            memp->Mz = l+Z;\n\n            memp->previous.x = memp->Mx;\n            memp->previous.y = memp->My;\n            memp->previous.z = memp->Mz;\n\n            memp->circlePos=(int)(J+circlePosStartAb);\n\n            if(memp->circlePos >= ablumenalSteps * m_vessel_cells_per_cross_section) {\n                memp->circlePos -= ablumenalSteps * m_vessel_cells_per_cross_section;\n            }\n\n            ecp->nodeAgents.push_back(memp);\n\n            m_world->setMLocation(int(j + depth) + lowerXboundary, int(k+Y), int(l+Z), memp);\n\n            memp->JunctionTest( true);\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\ttissue_vessel_connect_mesh\n*  Description: Connects adjacent vascular memAgents with springAgents if they are a part\n*               of the same cell, or junctionAgents if they are not.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Vessel::tissue_vessel_connect_mesh() {\n\n    int m, n;\n    int uptoE, uptoM, uptoM2;\n    EC* ecp;\n    EC* ecp2;\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N, JN;\n    uptoE = this->get_n_cells();\n    int POS, POSplus, POSminus, Xplus, Xminus;\n\n    //Calculate the total number of memAgents that form the vessel circumference, and therefore the number per cell.\n    int totalAbSteps = (int)(2.0f * (float)Pi * (float)m_vessel_total_radius);\n    int ablumenalSteps=(int)((float)totalAbSteps / (float)m_vessel_cells_per_cross_section);\n\n    int k;\n\n    if (meshNeighs == 4) {\n\n        for (int i = 0; i < uptoE; i++) {\n\n            // Look over all memAgents owned by the parent cell.\n            ecp = this->m_cell_agents[i];\n            uptoM = ecp->nodeAgents.size();\n\n            for (int j = 0; j < uptoM; j++) {\n\n                mp = ecp->nodeAgents[j];\n                N = 0;\n                JN = 0;\n                POS = mp->circlePos;\n                POSplus = POS + 1;\n                POSminus = POS - 1;\n                Xplus = (int) mp->Mx + 1;\n                Xminus = (int) mp->Mx - 1;\n\n                if (POS == 0) {\n                    POSminus = ablumenalSteps * m_vessel_cells_per_cross_section - 1;\n                } else if (POS == ablumenalSteps * m_vessel_cells_per_cross_section - 1) {\n                    POSplus = 0;\n                }\n\n                if (Xplus == this->m_world->gridXDimensions) {\n                    Xplus = 0;\n                } else if (Xminus < 0) {\n                    Xminus = this->m_world->gridXDimensions - 1;\n                }\n\n                // Go through all other agents, in each cell and find the ones it should be neighs with\n                for (m = 0; m < uptoE; m++) {\n                    ecp2 = this->m_cell_agents[m];\n                    uptoM2 = ecp2->nodeAgents.size();\n\n                    for(n = 0; n < uptoM2; n++) {\n\n                        nmp = ecp2->nodeAgents[n];\n\n                        if ( (nmp->circlePos == POS) && (((int)nmp->Mx == Xplus) || ( (int)nmp->Mx == Xminus))) {\n                            mp->neigh[N] = nmp;\n\n                            if (mp->Cell != nmp->Cell){\n                                mp->springJunction = true;\n                                nmp->springJunction = true;\n                            }\n\n                            ecp->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = true;\n                            if((int)nmp->Mx==Xplus) mp->SpringNeigh[N]->right = true;\n                            else mp->SpringNeigh[N]->right = false;\n                            N++;\n                        } else if (( (int)nmp->Mx == (int)mp->Mx) &&\n                                   ((nmp->circlePos == POSplus)||(nmp->circlePos == POSminus))) {\n\n                            mp->neigh[N]=nmp;\n\n                            if(mp->Cell!=nmp->Cell){\n                                mp->springJunction=true;\n                                nmp->springJunction = true;\n                            }\n\n                            ecp->createSpringTokenObject(mp, nmp, N);\n\n                            if(nmp->circlePos==POSplus) {\n                                mp->SpringNeigh[N]->right = true;\n                            } else {\n                                mp->SpringNeigh[N]->right=false;\n                            }\n                            N++;\n                        }\n                    }\n                    mp->neighs=N;\n                }\n            }\n        }\n    }\n}\n\n//********************************************************************************************************************//\n\n// Tissue_Monolayer Setup Functions\n\n//********************************************************************************************************************//\n\n// MONOLAYER SET-UP FUNCTIONS //\n\n/*****************************************************************************************\n*  Name:\t\tcreate_monolayer\n*  Description: Creates cell agents which form a monolayer, before invoking a memAgent\n*               creation function which places memAgents in a square shape.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Monolayer::create_monolayer() {\n    int j, I;\n    j=0;\n    I=0;\n    int k;\n    int chose;\n\n    int cell_width = this->m_tissue_type->m_cell_type->m_shape->get_width();\n\tint cell_height = this->m_tissue_type->m_cell_type->m_shape->get_height();\n\n    for (int i = 0; i < m_cell_number; i++) {\n        //creates new object dynamically of type EC (ecp is the e cell pointer)\n        EC *ecp = new EC( this->m_world);\n\n        //TODO: Have run number logging use a variable.\n\n        // Create a logger for protein levels.\n//        ecp->logger = new cell_logger(1, m_world->time, ecp);\n\n        ecp->belongs_to = BELONGS_TO_FLAT;\n\n        ecp->set_cell_type(this->m_tissue_type->m_cell_type);\n\n        ecp->m_tissue = this;\n\n        ecp->cell_number = i;\n\n        //put the address into the vector Ecells\n        m_world->ECagents.push_back(ecp);\n\n        // Add this agent to the relevant tissue.\n        store_cell_agent(ecp);\n    }\n\n\tint start_pos_X = this->m_position->get_x_coord() - ((this->m_width_in_cells * cell_width) / 2);\n\tint start_pos_Y = this->m_position->get_y_coord() - ((this->m_height_in_cells * cell_height) / 2);\n\n\tint count = 0;\n\tint current_pos_Y = start_pos_Y;\n\tfor (int i = 0; i < this->m_height_in_cells; i++) {\n\t\tint current_pos_X = start_pos_X;\n\t\tfor (int j = 0; j < this->m_width_in_cells; j++) {\n\t\t\tint centre_X = (int) (current_pos_X + (cell_width / 2.0f));\n\t\t\tint centre_Y = (int) (current_pos_Y + (cell_height / 2.0f));\n\t\t\ttissue_create_2D_square_cell(count, centre_X, centre_Y,(int) this->m_position->get_z_coord());\n\t\t\tcount++;\n\t\t\tcurrent_pos_X += cell_width;\n\t\t}\n\t\tcurrent_pos_Y += cell_height;\n\t}\n\n    tissue_connect_monolayer();\n\n    //check for junctions to make junction springs\n    for(int i = 0; i < m_cell_agents.size(); i++) {\n        for( j = 0; j < m_cell_agents[i]->nodeAgents.size();j++) {\n            m_cell_agents[i]->nodeAgents[j]->connectJunctions(false);\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tcheck_boundaries (monolayer)\n*  Description: Checks whether a monolayer-like object overlaps with any other object, if so,\n*               returns true.\n*  Returns:\t\tbool\n******************************************************************************************/\n\nbool Tissue_Monolayer::check_boundaries() {\n    Cell *current_cell;\n    Tissue *current_tissue;\n\n    for (int i = 0; i < m_tissue_container->cells.size(); i++) {\n        current_cell = m_tissue_container->cells[i];\n        if (m_tissue_container->check_cell_monolayer_overlap(current_cell, this)) {\n            return false; // <- Overlap detected, send false to the assert statement calling this function.\n        }\n    }\n\n    for (int i = 0; i < m_tissue_container->tissues.size(); i++) {\n        current_tissue = m_tissue_container->tissues[i];\n        if (current_tissue != this) {\n            if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_FLAT) {\n                auto *current_monolayer = dynamic_cast<Tissue_Monolayer *>(current_tissue);\n                if (m_tissue_container->check_monolayer_monolayer_overlap(this, current_monolayer)) {\n                    return false; // <- Overlap detected, send false to the assert statement calling this function.\n                }\n            } else if (current_tissue->m_tissue_type->m_tissue_configuration == CELL_CONFIGURATION_CYLINDRICAL) {\n                auto *current_vessel = dynamic_cast<Tissue_Vessel *>(current_tissue);\n                if (m_tissue_container->check_vessel_monolayer_overlap(current_vessel, this)) {\n                    return false; // <- Overlap detected, send false to the assert statement calling this function.\n                }\n            }\n        }\n    }\n    return true;\n}\n\n/*****************************************************************************************\n*  Name:\t\ttissue_create_2D_square_cell\n*  Description: Places memAgents in a square shape.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Monolayer::tissue_create_2D_square_cell(int cell_number, int centreX, int centreY, int z_coord) {\n    int i, j;\n    MemAgent* memp;\n\n    int cell_width = this->m_tissue_type->m_cell_type->m_shape->get_width();\n    int cell_height = this->m_tissue_type->m_cell_type->m_shape->get_height();\n\n    for (i = (int)(centreX-(float)cell_width/2.0f); i < (int)(centreX+(float)cell_width/2.0f); i++) {\n        for (j = (int)(centreY-(float)cell_height/2.0f); j < (int)(centreY+(float)cell_height/2.0f); j++) {\n\n            memp = new MemAgent(m_cell_agents[cell_number], (World*) this->m_world);\n            memp->Mx = (float)i;\n            memp->My = (float)j;\n            memp->Mz = (float)z_coord;\n            m_cell_agents[cell_number]->nodeAgents.push_back(memp);\n            m_world->setMLocation(int(i), int(j), z_coord, memp);\n            memp->node=true;\n\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\ttissue_create_2D_square_cell\n*  Description: Connects adjacent monolayer memAgents with springAgents if they belong to\n*               the same cell, or junctionAgents if not.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Monolayer::tissue_connect_monolayer() {\n    int e,i;\n    int uptoM;\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    int kelp;\n\n    for (e = 0; e < m_cell_number; e++){\n\n        uptoM = m_cell_agents[e]->nodeAgents.size();\n\n        for (i = 0; i < uptoM; i++){\n            mp = m_cell_agents[e]->nodeAgents[i];\n            N=0;\n\n            if (m_world->insideWorld(mp->Mx-1, mp->My, mp->Mz)) {\n\n                if (m_world->grid[(int)mp->Mx-1][(int)mp->My][0].type == const_M) {\n\n                    for (kelp = 0; kelp < m_world->grid[(int)mp->Mx-1][(int)mp->My][0].Mids.size(); kelp++) {\n                        nmp = m_world->grid[(int)mp->Mx-1][(int)mp->My][0].Mids[kelp];\n\n                        if(mp->Cell == nmp->Cell) {\n                            mp->neigh[N] = nmp;\n                            m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = true;\n                            mp->SpringNeigh[N]->right = false;\n                            N++;\n                            mp->neighs++;\n                        }\n                    }\n                }\n            }\n            if (m_world->insideWorld(mp->Mx+1, mp->My, mp->Mz)) {\n\n                if (m_world->grid[(int)mp->Mx+1][(int)mp->My][0].type == const_M) {\n\n                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx+1][(int)mp->My][0].Mids.size();kelp++) {\n                        nmp = m_world->grid[(int)mp->Mx+1][(int)mp->My][0].Mids[kelp];\n\n                        if(mp->Cell == nmp->Cell) {\n                            mp->neigh[N] = nmp;\n                            m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = true;\n                            mp->SpringNeigh[N]->right = true;\n                            N++;\n                            mp->neighs++;\n                        }\n                    }\n                }\n            }\n            if ((m_world->insideWorld(mp->Mx, mp->My-1, mp->Mz))) {\n\n                if (m_world->grid[(int)mp->Mx][(int)mp->My-1][0].type == const_M) {\n\n                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx][(int)mp->My-1][0].Mids.size();kelp++) {\n                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My-1][0].Mids[kelp];\n\n                        if (mp->Cell == nmp->Cell) {\n                            mp->neigh[N] = nmp;\n                            m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = false;\n                            mp->SpringNeigh[N]->right = true;\n                            N++;\n                            mp->neighs++;\n                        }\n                    }\n                }\n            }\n            if (m_world->insideWorld(mp->Mx, mp->My + 1, mp->Mz)) {\n\n                if (m_world->grid[(int)mp->Mx][(int)mp->My+1][0].type == const_M) {\n                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx][(int)mp->My+1][0].Mids.size();kelp++) {\n                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My+1][0].Mids[kelp];\n                        if (mp->Cell == nmp->Cell) {\n                            mp->neigh[N]=nmp;\n                            m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = false;\n                            mp->SpringNeigh[N]->right = false;\n                            N++;\n                            mp->neighs++;\n                        }\n                    }\n                }\n            }\n            if(m_world->insideWorld(mp->Mx, mp->My, mp->Mz)){\n                for(kelp = 0;kelp < m_world->grid[(int)mp->Mx][(int)mp->My][0].Mids.size(); kelp++) {\n                    nmp = m_world->grid[(int)mp->Mx][(int)mp->My][0].Mids[kelp];\n                    if (mp->Cell != nmp->Cell) {\n                        mp->neigh[N]=nmp;\n                        m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);\n                        mp->SpringNeigh[N]->horizontal = true;\n                        mp->SpringNeigh[N]->right = false;\n                        N++;\n                        mp->neighs++;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/*****************************************************************************************\n*  Name:\t\tdetermine_boundaries (monolayer)\n*  Description: Calculates the lowest and highest X, Y coordinates of a monolayer-like tissue.\n*  Returns:\t\tvoid\n******************************************************************************************/\n\nvoid Tissue_Monolayer::determine_boundaries() {\n\tfloat x_coord_1, x_coord_2, y_coord_1, y_coord_2;\n\tCoordinates monolayer_end_1, monolayer_end_2;\n\tstd::vector<Coordinates> boundary_coords;\n\n\tauto cell_width = float(m_tissue_type->m_cell_type->m_shape->get_width());\n\tauto cell_height = float(m_tissue_type->m_cell_type->m_shape->get_height());\n\n\tx_coord_1 = m_position->get_x_coord() - ((float(m_width_in_cells) * cell_width)/2.0f);\n\ty_coord_1 = m_position->get_y_coord() - ((float(m_height_in_cells) * cell_height)/2.0f);\n\n\tmonolayer_end_1 = Coordinates(x_coord_1, y_coord_1, m_position->get_z_coord());\n\tboundary_coords.push_back(monolayer_end_1);\n\n\tx_coord_2 = m_position->get_x_coord() + ((float(m_width_in_cells) * cell_width)/2.0f);\n\ty_coord_2 = m_position->get_y_coord() + ((float(m_height_in_cells) * cell_height)/2.0f);\n\n\tmonolayer_end_2 = Coordinates(x_coord_2, y_coord_2, m_position->get_z_coord());\n\tboundary_coords.push_back(monolayer_end_2);\n\n\tthis->m_boundaries = boundary_coords;\n}\n\n// CONSTRUCTOR //\n\nTissue_Monolayer::Tissue_Monolayer( Tissue_Container *tissue_container,\n                                    World *world,\n                                    Coordinates *position,\n\t\t\t\t\t\t\t\t\tstd::string name,\n                                    Tissue_Type_Flat *tissue_type)\n        : Tissue(tissue_container,\n                 world,\n                 position,\n                 name,\n                 tissue_type),\n          m_height_in_cells(tissue_type->get_height_in_cells()),\n          m_width_in_cells(tissue_type->get_width_in_cells()){\n    try {\n        assert(world != nullptr);\n        assert(position != nullptr);\n        assert(tissue_type != nullptr);\n        if (tissue_type->get_tissue_configuration() == CELL_CONFIGURATION_FLAT ) {\n            set_n_cells(tissue_type->get_width_in_cells() * tissue_type->get_height_in_cells());\n            std::cout << \" Tissue: Monolayer created successfully! \" << std::endl;\n        } else {\n            throw 8;\n        }\n    } catch ( int e ) {\n        std::cout << \"Exception: Incorrect tissue constructor (monolayer) called for specified configuration: \"\n                  << tissue_type->get_tissue_configuration()\n                  << \". Exception Type: \"\n                  << e\n                  << std::endl;\n    }\n}\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Tissue.cpp b/src/Tissue.cpp
--- a/src/Tissue.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/src/Tissue.cpp	(date 1626715448212)
@@ -1667,7 +1667,6 @@
 ******************************************************************************************/
 
 void Tissue_Vessel::tissue_vessel_connect_mesh() {
-
     int m, n;
     int uptoE, uptoM, uptoM2;
     EC* ecp;
@@ -1813,8 +1812,8 @@
         store_cell_agent(ecp);
     }
 
-	int start_pos_X = this->m_position->get_x_coord() - ((this->m_width_in_cells * cell_width) / 2);
-	int start_pos_Y = this->m_position->get_y_coord() - ((this->m_height_in_cells * cell_height) / 2);
+	int start_pos_X = (int)this->m_position->get_x_coord() - ((this->m_width_in_cells * cell_width) / 2);
+	int start_pos_Y = (int)this->m_position->get_y_coord() - ((this->m_height_in_cells * cell_height) / 2);
 
 	int count = 0;
 	int current_pos_Y = start_pos_Y;
@@ -1900,7 +1899,6 @@
             m_cell_agents[cell_number]->nodeAgents.push_back(memp);
             m_world->setMLocation(int(i), int(j), z_coord, memp);
             memp->node=true;
-
         }
     }
 }
@@ -1921,19 +1919,16 @@
     int kelp;
 
     for (e = 0; e < m_cell_number; e++){
-
         uptoM = m_cell_agents[e]->nodeAgents.size();
 
         for (i = 0; i < uptoM; i++){
             mp = m_cell_agents[e]->nodeAgents[i];
-            N=0;
+            N = 0;
 
             if (m_world->insideWorld(mp->Mx-1, mp->My, mp->Mz)) {
-
-                if (m_world->grid[(int)mp->Mx-1][(int)mp->My][0].type == const_M) {
-
-                    for (kelp = 0; kelp < m_world->grid[(int)mp->Mx-1][(int)mp->My][0].Mids.size(); kelp++) {
-                        nmp = m_world->grid[(int)mp->Mx-1][(int)mp->My][0].Mids[kelp];
+                if (m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].type == const_M) {
+                    for (kelp = 0; kelp < m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].Mids.size(); kelp++) {
+                        nmp = m_world->grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].Mids[kelp];
 
                         if(mp->Cell == nmp->Cell) {
                             mp->neigh[N] = nmp;
@@ -1947,12 +1942,9 @@
                 }
             }
             if (m_world->insideWorld(mp->Mx+1, mp->My, mp->Mz)) {
-
-                if (m_world->grid[(int)mp->Mx+1][(int)mp->My][0].type == const_M) {
-
-                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx+1][(int)mp->My][0].Mids.size();kelp++) {
-                        nmp = m_world->grid[(int)mp->Mx+1][(int)mp->My][0].Mids[kelp];
-
+                if (m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].type == const_M) {
+                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].Mids.size();kelp++) {
+                        nmp = m_world->grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].Mids[kelp];
                         if(mp->Cell == nmp->Cell) {
                             mp->neigh[N] = nmp;
                             m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);
@@ -1965,12 +1957,9 @@
                 }
             }
             if ((m_world->insideWorld(mp->Mx, mp->My-1, mp->Mz))) {
-
-                if (m_world->grid[(int)mp->Mx][(int)mp->My-1][0].type == const_M) {
-
-                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx][(int)mp->My-1][0].Mids.size();kelp++) {
-                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My-1][0].Mids[kelp];
-
+                if (m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].type == const_M) {
+                    for(kelp = 0; kelp < m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].Mids.size(); kelp++) {
+                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].Mids[kelp];
                         if (mp->Cell == nmp->Cell) {
                             mp->neigh[N] = nmp;
                             m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);
@@ -1983,10 +1972,9 @@
                 }
             }
             if (m_world->insideWorld(mp->Mx, mp->My + 1, mp->Mz)) {
-
-                if (m_world->grid[(int)mp->Mx][(int)mp->My+1][0].type == const_M) {
-                    for(kelp=0;kelp<m_world->grid[(int)mp->Mx][(int)mp->My+1][0].Mids.size();kelp++) {
-                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My+1][0].Mids[kelp];
+                if (m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].type == const_M) {
+                    for(kelp = 0; kelp < m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].Mids.size(); kelp++) {
+                        nmp = m_world->grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].Mids[kelp];
                         if (mp->Cell == nmp->Cell) {
                             mp->neigh[N]=nmp;
                             m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);
@@ -1999,8 +1987,8 @@
                 }
             }
             if(m_world->insideWorld(mp->Mx, mp->My, mp->Mz)){
-                for(kelp = 0;kelp < m_world->grid[(int)mp->Mx][(int)mp->My][0].Mids.size(); kelp++) {
-                    nmp = m_world->grid[(int)mp->Mx][(int)mp->My][0].Mids[kelp];
+                for(kelp = 0; kelp < m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz].Mids.size(); kelp++) {
+                    nmp = m_world->grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz].Mids[kelp];
                     if (mp->Cell != nmp->Cell) {
                         mp->neigh[N]=nmp;
                         m_cell_agents[e]->createSpringTokenObject(mp, nmp, N);
Index: src/creation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include \"objects.h\"\n#include <math.h>\n#include \"memAgents.h\"\n#include \"EC.h\"\n#include \"environment.h\"\n#include \"utils.h\"\n\nfloat storedOffset;\n//-------------------------------------------------------------------------\nvoid World::label_env_exposed_von_neu_agents(void){\n\n    //not all memagents can activate their receptors, as membrane gets ruffled, those with diag env neighs only arent avble to \"see enough\" of the env to activate.\n    //- this is in part to match with first version of model which was set up to not have any ruffled bits, all memagents\n    //have to have a face adjacent to env grid site to 'see the vegf ligands' otherwise vertx is not enough... this leaves some vr-2 in reserve\n    //in a sense, until they become exposed... although check because maybe we only allocate vr-2 to the von neu neihbours..in which case all vr2 is\n    //available to be activated...\n    int i,j,k;\n\n for (i = 0; i < this->gridXDimensions; i++) {\n            for (j = 0; j < this->gridYDimensions; j++) {\n                for (k = 0; k < this->gridZDimensions; k++){\n                    if(grid[i][j][k].Eid!=NULL){\n                        grid[i][j][k].Eid->calcInside();\n                    }\n                }\n            }\n        }\n        \n        int count=0;\n        for(j=0;j<(int)ECagents.size();j++){\n            count=0;\n            for(k=0;k<ECagents[j]->nodeAgents.size();k++)\n                if(ECagents[j]->nodeAgents[k]->checkNeighsVonForEnv()==true) count++;\n            for(k=0;k<ECagents[j]->surfaceAgents.size();k++)\n                if(ECagents[j]->surfaceAgents[k]->checkNeighsVonForEnv()==true) count++;\n        }\n}\n        //-------------------------------------------------------------------------\nvoid World::createMonolayer(void){\n\n    int i,j, I;\n\n    j=0;\n    I=0;\n    for(i=0;i<ECELLS;i++){\n\n        //creates new object dynamically of type EC (ecp is the e cell pointer)\n        EC * ecp = new EC((World*) this);\n\n        //put the address into the vector Ecells\n        ECagents.push_back(ecp);\n\t\t\n     }\n\n   \n    int k;\n    int chose;\n\n     for(i=0;i<ECELLS;i++){\n    \n        if(I==MONOLAYERcells){\n            I=0;\n          j++;\n        }\n        k=j%2;\n        \n\n       create_2D_square_cell(i, (int)(Medium_width+(ECwidth/2.0f)+(I*ECwidth)),(int)(Medium_width+(ECwidth/2.0f)+(j*ECwidth)));\n       \n        I++;\n    }\n\n   \n    connectMonolayer();\n\n    //check for junctions to make junction springs\n    for(i=0;i<ECagents.size();i++){\n        for(j=0;j<ECagents[i]->nodeAgents.size();j++){\n            ECagents[i]->nodeAgents[j]->connectJunctions(false);\n        }\n\n        \n    }\n\n\n}\n//-----------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------\nvoid MemAgent::connectJunctions(bool alsoNormalSprings){\n\tint x=0;\n    int flag=0;\n    int m, n, p,s;\n    float sumV=0;\n\n    int i, j, k;\n    i=Mx; j=My; k=Mz;\n\n    //same layer\n    for(x=0;x<6;x++) {\n        if(x==0) {\n            m=i;\n            n=j+1;\n            p=k;\n        } else if(x==1) {\n            m=i;\n            n=j-1;\n            p=k;\n        } else if(x==2) {\n            m=i+1;\n            n=j;\n            p=k;\n        } else if(x==3) {\n            m=i;\n            n=j;\n            p=k+1;\n        } else if(x==4) {\n            m=i;\n            n=j;\n            p=k-1;\n        } else if(x==5) {\n            m=i-1;\n            n=j;\n            p=k;\n        }\n\n        //-------------------------------\n        //toroidal only X\n        if (m >= this->worldP->gridXDimensions)\n        \tm = 0;\n        if (m < 0)\n        \tm = this->worldP->gridXDimensions - 1;\n        if (n >= this->worldP->gridYDimensions)\n        \tn = 0;\n        if (n < 0)\n        \tn = this->worldP->gridXDimensions - 1;\n\n        if(worldP->insideWorld(m, n, p)){\n            if(worldP->grid[m][n][p].type == const_M){\n                for(s=0;s<worldP->grid[m][n][p].Mids.size();s++) {\n                    if(worldP->grid[m][n][p].Mids[s]->Cell!=Cell) {\n                        neigh[neighs]=worldP->grid[m][n][p].Mids[s];\n                        Cell->createSpringTokenObject(this, worldP->grid[m][n][p].Mids[s], neighs);\n\n                        if(x==0) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = false;\n                            Cell->Springs[Cell->Springs.size()-1]->right = false;\n                        } else if(x==1) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = false;\n                            Cell->Springs[Cell->Springs.size()-1]->right = true;\n                        } else if(x==2) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = true;\n                            Cell->Springs[Cell->Springs.size()-1]->right = true;\n                        } else if(x==3) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = false;\n                            Cell->Springs[Cell->Springs.size()-1]->right = false;\n                        } else if(x==4) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = false;\n                            Cell->Springs[Cell->Springs.size()-1]->right = false;\n                        } else if(x==5) {\n                            Cell->Springs[Cell->Springs.size()-1]->horizontal = true;\n                            Cell->Springs[Cell->Springs.size()-1]->right = false;\n                        }\n                        neighs++;\n                    }\n                }\n\n                if (alsoNormalSprings) {\n                    if(worldP->grid[m][n][p].Mids[s]->Cell==Cell) {\n                        neigh[neighs]=worldP->grid[m][n][p].Mids[s];\n                        Cell->createSpringTokenObject(this, worldP->grid[m][n][p].Mids[s] , neighs);\n\n                        if(x==0) {\n                            SpringNeigh[neighs]->horizontal = false;\n                            SpringNeigh[neighs]->right = false;\n                        } else if(x==1) {\n                            SpringNeigh[neighs]->horizontal = false;\n                            SpringNeigh[neighs]->right = true;\n                        } else if(x==2) {\n                            SpringNeigh[neighs]->horizontal = true;\n                            SpringNeigh[neighs]->right = true;\n                        } else if(x==3) {\n                            SpringNeigh[neighs]->horizontal = true;\n                            SpringNeigh[neighs]->right = false;\n                        } else if(x==4) {\n                            SpringNeigh[neighs]->horizontal = false;\n                            SpringNeigh[neighs]->right = false;\n                        } else if(x==5) {\n                            SpringNeigh[neighs]->horizontal =true;\n                            SpringNeigh[neighs]->right = false;\n                        }\n                        neighs++;\n                    }\n                }\n            }\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------\n\nvoid World::createHexagonCell(int cell, int centreX, int centreY){\n\n     int i, j;\n     int I,J;\n\n     I=0;\n    MemAgent* memp;\n\n\tstd::cout<<(int)(centreX-(float)ECwidth/2.0f)+2<<\" \"<<(int)(centreX+(float)ECwidth/2.0f)-2-1<<std::endl;\n\n    for(i=(int)(centreX-(float)ECwidth/2.0f);i<(int)(centreX+(float)ECwidth/2.0f)-1;i++){\n        for(j=(int)(centreY-(float)ECwidth/2.0f);j<(int)(centreY+(float)ECwidth/2.0f);j++){\n\n            if((I==0)||(I==6)) J=2;\n            else if((I==1)||(I==5)) J=1;\n            else J=0;\n\n            if(I==3)std::cout<<j<<\" \"<<J<<\" \"<<I<<(int)(centreX-(float)ECwidth/2.0f)+J<<\" \"<<(int)(centreX+(float)ECwidth/2.0f)-J-1<<std::endl;\n            if((j>=(int)(centreY-(float)ECwidth/2.0f)+J)&&(j<(int)(centreY+(float)ECwidth/2.0f)-J)){\n            //    cout<<i<<\" \"<<J<<\" \"<<I<<endl;\n            memp = new MemAgent(ECagents[cell], (World*) this);\n            memp->Mx = (float)i;\n            memp->My = (float)j;\n            memp->Mz = 0.0f;\n            ECagents[cell]->nodeAgents.push_back(memp);\n            setMLocation(int(i), int(j), 0, memp);\n            memp->node=true;\n            //will need to generalise this if diff sized cells - see VBL book 1 pg 78 for number refs\n            if(((I==0))&&(j==(int)(centreY-(float)ECwidth/2.0f)+2)) memp->labelled=true;\n            if(((I==1))&&(j==(int)(centreY-(float)ECwidth/2.0f)+1)) memp->labelled=true;\n            if(((I==4))&&(j==(int)(centreY-(float)ECwidth/2.0f)+7)) memp->labelled2=true;\n            if(((I==5))&&(j==(int)(centreY-(float)ECwidth/2.0f)+6)) memp->labelled2=true;\n            }\n            \n        }\n        I++;\n\t\tstd::cout<<I<<std::endl;\n    }\n\n    //connect mesh\n    /*int uptoM=ECagents[cell]->nodeAgents.size();\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    int kelp;\n\n    for(i=0;i<uptoM;i++){\n        mp = ECagents[cell]->nodeAgents[i];\n        N=0;\n\n        if(insideWorld(mp->Mx-1, mp->My, mp->Mz)==true){\n        if(grid[(int)mp->Mx-1][(int)mp->My][1].type==M){\n            for(kelp=0;kelp<grid[(int)mp->Mx-1][(int)mp->My][1].Mids.size();kelp++){\n                nmp = grid[(int)mp->Mx-1][(int)mp->My][1].Mids[kelp];\n\n                mp->neigh[N]=nmp;\n                ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n                mp->SpringNeigh[N]->horizontal = true;\n                mp->SpringNeigh[N]->right = false;\n                N++;\n                mp->neighs++;\n            }\n        }\n        }\n        if(insideWorld(mp->Mx+1, mp->My, mp->Mz)==true){\n        if(grid[(int)mp->Mx+1][(int)mp->My][1].type==M){\n            for(kelp=0;kelp<grid[(int)mp->Mx+1][(int)mp->My][1].Mids.size();kelp++){\n            nmp = grid[(int)mp->Mx+1][(int)mp->My][1].Mids[kelp];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = true;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n            }\n        }\n        }\n        if((insideWorld(mp->Mx, mp->My-1, mp->Mz)==true)){\n        if(grid[(int)mp->Mx][(int)mp->My-1][1].type==M){\n            for(kelp=0;kelp<grid[(int)mp->Mx][(int)mp->My-1][1].Mids.size();kelp++){\n            nmp = grid[(int)mp->Mx][(int)mp->My-1][1].Mids[kelp];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n            }\n        }\n        }\n        if((insideWorld(mp->Mx, mp->My+1, mp->Mz)==true)){\n        if(grid[(int)mp->Mx][(int)mp->My+1][1].type==M){\n            for(kelp=0;kelp<grid[(int)mp->Mx][(int)mp->My+1][1].Mids.size();kelp++){\n            nmp = grid[(int)mp->Mx][(int)mp->My+1][1].Mids[kelp];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n            }\n        }\n        }\n    }*/\n}\n\n//-------------------------------------------------------------------------\n//connect mesh\nvoid World::connectMonolayer(void){\n    int e,i;\n    int uptoM;\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    int kelp;\n\n    for(e=0;e<ECELLS;e++){\n\n        uptoM=ECagents[e]->nodeAgents.size();\n\n    for(i=0;i<uptoM;i++){\n        mp = ECagents[e]->nodeAgents[i];\n        N=0;\n\n\n        if(insideWorld(mp->Mx-1, mp->My, mp->Mz)){\n\t\t\tif(grid[(int)mp->Mx-1][(int)mp->My][0].type == const_M){\n\t\t\t\tfor(kelp=0;kelp<grid[(int)mp->Mx-1][(int)mp->My][0].Mids.size();kelp++) {\n\t\t\t\t\tnmp = grid[(int)mp->Mx-1][(int)mp->My][0].Mids[kelp];\n\t\t\t\t\tif(mp->Cell==nmp->Cell){\n\t\t\t\t\t\tmp->neigh[N]=nmp;\n\t\t\t\t\t\tECagents[e]->createSpringTokenObject(mp, nmp, N);\n\t\t\t\t\t\tmp->SpringNeigh[N]->horizontal = true;\n\t\t\t\t\t\tmp->SpringNeigh[N]->right = false;\n\t\t\t\t\t\tN++;\n\t\t\t\t\t\tmp->neighs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n        /*else{\n        \n            if(grid[xMAX-1][(int)mp->My][0].type==M){\n            for(kelp=0;kelp<grid[xMAX][(int)mp->My][0].Mids.size();kelp++){\n\n                nmp = grid[(int)mp->Mx-1][(int)mp->My][0].Mids[kelp];\n                if(mp->Cell==nmp->Cell){\n                mp->neigh[N]=nmp;\n                ECagents[e]->createSpringTokenObject(mp, nmp, N);\n                mp->SpringNeigh[N]->horizontal = true;\n                mp->SpringNeigh[N]->right = false;\n                N++;\n                mp->neighs++;\n                }\n            }\n        }\n        }*/\n        if(insideWorld(mp->Mx+1, mp->My, mp->Mz)){\n\t\t\tif(grid[(int)mp->Mx+1][(int)mp->My][0].type == const_M){\n\t\t\t\tfor(kelp=0;kelp<grid[(int)mp->Mx+1][(int)mp->My][0].Mids.size();kelp++){\n\t\t\t\t\tnmp = grid[(int)mp->Mx+1][(int)mp->My][0].Mids[kelp];\n\t\t\t\t\tif(mp->Cell==nmp->Cell){\n\t\t\t\t\t\tmp->neigh[N]=nmp;\n\t\t\t\t\t\tECagents[e]->createSpringTokenObject(mp, nmp, N);\n\t\t\t\t\t\tmp->SpringNeigh[N]->horizontal = true;\n\t\t\t\t\t\tmp->SpringNeigh[N]->right = true;\n\t\t\t\t\t\tN++;\n\t\t\t\t\t\tmp->neighs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }\n        if((insideWorld(mp->Mx, mp->My-1, mp->Mz))){\n\t\t\tif(grid[(int)mp->Mx][(int)mp->My-1][0].type == const_M){\n\t\t\t\tfor(kelp=0;kelp<grid[(int)mp->Mx][(int)mp->My-1][0].Mids.size();kelp++){\n\t\t\t\t\tnmp = grid[(int)mp->Mx][(int)mp->My-1][0].Mids[kelp];\n\t\t\t\t\tif(mp->Cell==nmp->Cell){\n\t\t\t\t\t\tmp->neigh[N]=nmp;\n\t\t\t\t\t\tECagents[e]->createSpringTokenObject(mp, nmp, N);\n\t\t\t\t\t\tmp->SpringNeigh[N]->horizontal = false;\n\t\t\t\t\t\tmp->SpringNeigh[N]->right = true;\n\t\t\t\t\t\tN++;\n\t\t\t\t\t\tmp->neighs++;\n\t\t\t\t\t}\n\t\t\t\t}\n        \t}\n        }\n        if((insideWorld(mp->Mx, mp->My+1, mp->Mz))) {\n\t\t\tif(grid[(int)mp->Mx][(int)mp->My+1][0].type == const_M) {\n\t\t\t\tfor(kelp=0;kelp<grid[(int)mp->Mx][(int)mp->My+1][0].Mids.size();kelp++){\n\t\t\t\t\tnmp = grid[(int)mp->Mx][(int)mp->My+1][0].Mids[kelp];\n\t\t\t\t\tif(mp->Cell==nmp->Cell) {\n\t\t\t\t\t\tmp->neigh[N]=nmp;\n\t\t\t\t\t\tECagents[e]->createSpringTokenObject(mp, nmp, N);\n\t\t\t\t\t\tmp->SpringNeigh[N]->horizontal = false;\n\t\t\t\t\t\tmp->SpringNeigh[N]->right = false;\n\t\t\t\t\t\tN++;\n\t\t\t\t\t\tmp->neighs++;\n\t\t\t\t\t}\n            \t}\n        \t}\n        }\n        if(insideWorld(mp->Mx, mp->My, mp->Mz)){\n        //if(grid[(int)mp->Mx][(int)mp->My][1].type==M){\n            for(kelp=0;kelp<grid[(int)mp->Mx][(int)mp->My][0].Mids.size();kelp++) {\n                nmp = grid[(int)mp->Mx][(int)mp->My][0].Mids[kelp];\n                if(mp->Cell!=nmp->Cell){\n\t\t\t\t\tmp->neigh[N]=nmp;\n\t\t\t\t\tECagents[e]->createSpringTokenObject(mp, nmp, N);\n\t\t\t\t\tmp->SpringNeigh[N]->horizontal = true;\n\t\t\t\t\tmp->SpringNeigh[N]->right = false;\n\t\t\t\t\tN++;\n\t\t\t\t\tmp->neighs++;\n                \t}\n            \t}\n        \t}\n    \t}\n    }\n}\n//-----------------------------------------------------------------------------------\n//create single cell 2D\nvoid World::create_2D_square_cell(int cell, int centreX, int centreY) {\n    \n//create node agents ina  squareand connect up in a square\n    int i, j;\n\n  \n\n    MemAgent* memp;\n    \n    for(i=(int)(centreX-(float)ECwidth/2.0f);i<(int)(centreX+(float)ECwidth/2.0f);i++){\n        for(j=(int)(centreY-(float)ECwidth/2.0f);j<(int)(centreY+(float)ECwidth/2.0f);j++){\n            \n            memp = new MemAgent(ECagents[cell], (World*) this);\n            memp->Mx = (float)i;\n            memp->My = (float)j;\n            memp->Mz = 0.0f;\n            ECagents[cell]->nodeAgents.push_back(memp);\n            setMLocation(int(i), int(j), 0, memp);\n            memp->node=true;\n            \n        }\n    }\n    \n    //connect mesh\n   /* int uptoM=ECagents[cell]->nodeAgents.size();\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    \n    for(i=0;i<uptoM;i++){\n        mp = ECagents[cell]->nodeAgents[i];\n        N=0;\n        if(insideWorld(mp->Mx-1, mp->My, mp->Mz)==true){\n        if(grid[(int)mp->Mx-1][(int)mp->My][1].type==M){\n            \n            nmp = grid[(int)mp->Mx-1][(int)mp->My][1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = true;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        }\n        if(insideWorld(mp->Mx+1, mp->My, mp->Mz)==true){\n        if(grid[(int)mp->Mx+1][(int)mp->My][1].type==M){\n            nmp = grid[(int)mp->Mx+1][(int)mp->My][1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = true;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n        }\n        }\n        if(insideWorld(mp->Mx, mp->My-1, mp->Mz)==true){\n        if(grid[(int)mp->Mx][(int)mp->My-1][1].type==M){\n            nmp = grid[(int)mp->Mx][(int)mp->My-1][1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n        }\n        }\n        if(insideWorld(mp->Mx, mp->My+1, mp->Mz)==true){\n        if(grid[(int)mp->Mx][(int)mp->My+1][1].type==M){\n            nmp = grid[(int)mp->Mx][(int)mp->My+1][1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[cell]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        }\n    }*/\n}\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n//create single cell 2D\nvoid World::create_3D_round_cell(void){\n    \n    int radius = (float)ECwidth/2.0f;\n    int height = 8;\n    int i, j, k;\n\n     for(i=0;i<ECELLS;i++){\n\n        //creates new object dynamically of type EC (ecp is the e cell pointer)\n        EC * ecp = new EC((World*) this);\n\n        //put the address into the vector Ecells\n        ECagents.push_back(ecp);\n\n         \n\t\t //if(chose%3==0)\n\n\n\n         ECagents[i]->VEGFRtot = 0;\n\n\n     }\n    \n//create node agents ina  squareand connect up in a square\n    \n    float dist;\n    bool allow=false;\n    MemAgent* memp;\n    int centreX = (int)((float)xMAX/2.0f);\n    int centreY = 10;//(int)((float)yMAX/2.0f);\n\tstd::cout<<centreX<<\" \"<<centreY<<std::endl;\n    \n    for(i=(int)(centreX-(float)ECwidth/2.0f);i<=(int)(centreX+(float)ECwidth/2.0f);i++){\n        for(j=(int)(centreY-(float)ECwidth/2.0f);j<=(int)(centreY+(float)ECwidth/2.0f);j++){\n            for(k=1;k<height;k++){\n                allow=false;\n                if((k==1)||(k==height-1)){\n                    if(getDist(i, j, k, centreX, centreY, k)<=radius+0.5)\n                        allow=true;\n                }\n                else{\n                    dist=getDist(i, j, k, centreX, centreY, k);\n                    \n                    if((dist<=radius+0.5)&&(dist>=radius-0.8f))\n                        allow=true;\n                    \n                }\n                \n                if(allow==true){\n                    //lower disc\n                    memp = new MemAgent(ECagents[0], (World*) this);\n                    memp->Mx = (float)i;\n                    memp->My = (float)j;\n                    memp->Mz = (float)k;\n                    ECagents[0]->nodeAgents.push_back(memp);\n                    setMLocation(int(i), int(j), k, memp);\n                    memp->node=true;\n                    \n                }\n            }\n        }\n    }\n    \n    //connect mesh\n    int uptoM=ECagents[0]->nodeAgents.size();\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N;\n    \n    for(i=0;i<uptoM;i++){\n        mp = ECagents[0]->nodeAgents[i];\n        N=0;\n        \n        if(grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].type == const_M){\n            \n            nmp = grid[(int)mp->Mx-1][(int)mp->My][(int)mp->Mz].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = true;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        if(grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].type == const_M) {\n            nmp = grid[(int)mp->Mx+1][(int)mp->My][(int)mp->Mz].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = true;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n        }\n        if(grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].type == const_M) {\n            nmp = grid[(int)mp->Mx][(int)mp->My-1][(int)mp->Mz].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = true;\n            N++;\n            mp->neighs++;\n        }\n        if(grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].type == const_M){\n            nmp = grid[(int)mp->Mx][(int)mp->My+1][(int)mp->Mz].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        if(grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz+1].type == const_M){\n            nmp = grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz+1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        \n        if(grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz-1].type == const_M){\n            nmp = grid[(int)mp->Mx][(int)mp->My][(int)mp->Mz-1].Mids[0];\n            mp->neigh[N]=nmp;\n            ECagents[0]->createSpringTokenObject(mp, nmp, N);\n            mp->SpringNeigh[N]->horizontal = false;\n            mp->SpringNeigh[N]->right = false;\n            N++;\n            mp->neighs++;\n        }\n        \n        \n        \n        \n    }\n}\n//-------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------\nvoid World::createECagents(int Junc_arrang){\n    \n    int i, j;\n    int chose;\n\n    for(i=0;i<ECELLS;i++){\n        \n        //creates new object dynamically of type EC (ecp is the e cell pointer)\n        EC * ecp = new EC((World*) this);\n        \n        //put the address into the vector Ecells\n        ECagents.push_back(ecp);\n\n         //chose = rand();\n         chose = new_rand();\n\t    \n         ECagents[i]->VEGFRtot = 0;\n\n         //ECagents[i]->red = ((float)rand()/(float)RAND_MAX);\n        //ECagents[i]->green = ((float)rand()/(float)RAND_MAX);\n        //ECagents[i]->blue = ((float)rand()/(float)RAND_MAX);\n\n        ECagents[i]->red = ((float)new_rand()/(float)NEW_RAND_MAX);\n        ECagents[i]->green = ((float)new_rand()/(float)NEW_RAND_MAX);\n        ECagents[i]->blue = ((float)new_rand()/(float)NEW_RAND_MAX);\n\n        \n        for(j=0;j<ECwidth;j++){\n          \n            drawMeshFirst(i, j, ecp, Junc_arrang);\n            \n        }\n        \n        if(ANALYSIS_HYSTERESIS==true){\n            ECagents[i]->hyst.Cell = ECagents[i];\n            \n        }\n        \n    }\n    \n    //chooseMutants();\n     \n    \n}\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\nvoid World::createBlood(void){\n    \n    int i, j, k, J, K;\n    \n    //Vessel * vp = new Vessel((World*) this);\n    \n    //Vessels.push_back(vp);\n    \n    //mid points of lumen ends\n    //vp-> Sx = 0 ;\n    //vp-> Sy = vesselCentreY;//+bloodRadius;\n    //vp-> Sz= vesselCentreZ ;\n    \n    \n    /*vp-> EndX = xMAX-1;\n     * vp-> EndY = vesselCentreY+bloodRadius;\n     * vp-> EndZ = vesselCentreZ;*/\n    \n    //vp->LongAxis_Theta = ;\n    \n    for(i=0;i<(ECpack*ECwidth)-1;i++)\n        for(j=0;j<(vesselRadius-1)*2;j++){\n            for(k=0;k<(vesselRadius-1)*2;k++){\n                J=j+vesselCentreY-(vesselRadius-1);\n                K=k+vesselCentreZ-(vesselRadius-1);\n                \n                if(insideWorld(i, J, K)==true){\n                    \n                    //create blood in vessel\n                    if(distTest2D(J, K, vesselCentreY, vesselCentreZ, vesselRadius-1)==true){\n                        //if (grid[j+depth][k+Y][l+Z].Eid!=NULL){\n                        if(grid[i][J][K].type == const_E){\n                        grid[i][J][K].Eid->blood=1.0f;\n                        //grid[i][J][K].Vid=vp\n                        //grid[i][J][K].type = BLOOD;\n                        grid[i][J][K].Eid->VEGF=0.0f;\n                        }\n                        \n                    }\n                    //else if((grid[i][J][K].Mids.size()>0)&&(distTest2D(J,K,vesselCentreY,vesselCentreZ, bloodRadius+1)==true)) grid[i][J][K].Mids[0]->Lumen=true;\n                }\n            }\n        }\n    \n}\n//--------------------------------------------------------------------------------------------------------------------------------------\n//-------------------------------------------------------------------------\nvoid World::replaceBlood(int i, int j, int k){\n    \n    if(insideWorld(i, j, k)==true){\n        \n        //create blood in vessel\n        if(distTest2D(j, k, vesselCentreY, vesselCentreZ, bloodRadius)==true){\n            \n            grid[i][j][k].type = BLOOD;\n            grid[i][j][k].Eid->VEGF=0.0f;\n        }\n        \n    }\n    \n}\n//--------------------------------------------------------------------------------------------------------------------------------------\nvoid World::drawMeshFirst(int i, int j, EC* ecp, int JunctArrangement){\n\n    float theta;\n    int totalAbSteps = (int)(2.0f*(float)Pi*((float)vesselRadius));\n    int ablumenalSteps=(int)((float)totalAbSteps/(float)ECcross);//30.0f/(float)ECcross;\n    float delta;\n    float r, k, l, X, Y, Z, J, rL;\n    int lx;\n    float thetaStart, deltaSteps;\n    float depth;\n    MemAgent* memp;\n    int circlePosStartAb=0;\n\n    r=vesselRadius;\n    rL=bloodRadius;\n\n    delta=((2.0f*(float)Pi)/(float)ECcross);\n    deltaSteps = delta/float(ablumenalSteps);\n    float offset;\n    float offsetPercentage;\n\n    float x=(float)i/(float)ECcross;\n    lx=(int)x;\n    depth= ECwidth*lx;\n    //cout<<\"ab steps\"<<ablumenalSteps<<endl;\n    thetaStart=delta*(float)i;\n    circlePosStartAb=ablumenalSteps*i;\n\n    if(lx%2!=0){\n\n     offset=0.5;\n     /*if((i==0)||(i==1)) offset=0.1f;\n     else if((i==2)||(i==3)) offset=0.5f;\n     else if((i==4)||(i==5)) offset = 0.2f;\n     else if((i==6)||(i==7)) offset = 0.5f;\n     else if((i==8)||(i==9)) offset = 0.7f;*/\n\n     \n      thetaStart+=offset*delta;\n      circlePosStartAb+=(int)(offset*ablumenalSteps);\n    }\n\n    circlePosStartAb=circlePosStartAb%int(ablumenalSteps*ECcross);\n    if(thetaStart>=2*Pi) thetaStart-=2*Pi;\n\n    X=(float)j;Y=(float)vesselCentreY;Z=(float)vesselCentreZ;\n\n\n    for(J=0;J<ablumenalSteps;J++){\n\n        theta=thetaStart+(deltaSteps*(float)J);\n\n        k=((float)r*cos(theta));\n        l=((float)r*sin(theta));\n\n        //if(insideWorld(int(j+depth), int(k+Y), int(l+Z))==true){\n\n        //for(r=0;r<=vesselRadius+1;r++){\n        // k=(int)((float)r*cos(theta));\n        //l=(int)((float)r*sin(theta));\n\n        if(insideWorld(j+depth, k+Y, l+Z)==true){\n\n            //if within vessel but not blood create a cell site here\n            //if((getDist((int)k,(int)l,0,0,0,0)>vesselRadius-1)&&(getDist((int)k,(int)l,0,0,0,0)<vesselRadius+1)){\n            //if(grid[(int)(j+depth)][(int)(k+Y)][(int)(l+Z)].type!=M){\n            memp = new MemAgent(ecp, (World*) this);\n\n            memp->Mx = (float)j+(float)depth;\n            memp->My = k+Y;\n\n            memp->FA = true;\n            //---------------------------------------\n            ///for CELL_SETUP=2 (lars and rearrangement paper models with sewn up front.\n            ///label the front row of nodes so they can be sewn up once gridded\n            if(BLINDENDED_SPROUT==true){\n            if((i==ECELLS-1)||(i==ECELLS-2)){    \n                if(j==ECwidth-1) memp->labelledBlindended =  true;\n                \n            }\n            }\n            //---------------------------------------\n            \n            memp->Mz = l+Z;\n\n            memp->previous.x = memp->Mx;\n            memp->previous.y = memp->My;\n            memp->previous.z = memp->Mz;\n\n            memp->circlePos=(int)(J+circlePosStartAb);\n\n            if(memp->circlePos>=ablumenalSteps*ECcross) {\n                memp->circlePos-=ablumenalSteps*ECcross;\n            }\n\n            ecp->nodeAgents.push_back(memp);\n\n            setMLocation(int(j+depth), int(k+Y), int(l+Z), memp);\n\n            memp->JunctionTest( true);\n        }\n        //}\n        //}\n    }\n\n    //-------------------------------------------------------------------------------------\n\n}\n\n//-------------------------------------------------------------------------//-------------------------------------------------------------------------\nvoid World::connectMesh(void){\n\n    int i, j, m, n;\n    int uptoE, uptoM, uptoM2;\n    EC* ecp;\n    EC* ecp2;\n    MemAgent* mp;\n    MemAgent* nmp;\n    int N, JN;\n    uptoE = ECagents.size();\n    int POS, POSplus, POSminus, Xplus, Xminus;\n    int totalAbSteps = (int)(2.0f*(float)Pi*(float)vesselRadius);\n    int ablumenalSteps=(int)((float)totalAbSteps/(float)ECcross);\n\n    if(meshNeighs==4){\n\n        for(i=0;i<uptoE;i++){\n\n            ecp=ECagents[i];\n            uptoM=ecp->nodeAgents.size();\n\n            for(j=0;j<uptoM;j++){\n\n                mp=ecp->nodeAgents[j];\n                N=0;\n                JN=0;\n                POS = mp->circlePos;\n                POSplus=POS+1;\n                POSminus=POS-1;\n                Xplus = (int)mp->Mx+1;\n                Xminus = (int)mp->Mx-1;\n\n\n                if(POS==0) POSminus=ablumenalSteps*ECcross-1;\n                else if(POS==ablumenalSteps*ECcross-1) POSplus=0;\n                if(Xplus==xMAX) Xplus = 0;\n                else if(Xminus<0) Xminus = xMAX-1;\n\n                //go through all other agents, in each cell and find the ones it should be neighs with\n                for(m=0;m<uptoE; m++){\n                    ecp2=ECagents[m];\n                    uptoM2=ecp2->nodeAgents.size();\n\n                    for(n=0;n<uptoM2;n++){\n\n                        nmp=ecp2->nodeAgents[n];\n\n                        if((nmp->circlePos==POS)&&(((int)nmp->Mx==Xplus)||((int)nmp->Mx==Xminus))){\n                            mp->neigh[N]=nmp;\n                            if(mp->Cell!=nmp->Cell){\n                                //mp->Cell->nodesToRetract.push_back(mp);\n                                mp->springJunction=true;\n                                nmp->springJunction = true;\n                            }\n                            ecp->createSpringTokenObject(mp, nmp, N);\n                            mp->SpringNeigh[N]->horizontal = true;\n                            if((int)nmp->Mx==Xplus) mp->SpringNeigh[N]->right = true;\n                            else mp->SpringNeigh[N]->right = false;\n\n                            N++;\n\n                        }\n                        else if(((int)nmp->Mx==(int)mp->Mx)&&((nmp->circlePos==POSplus)||(nmp->circlePos==POSminus))){\n\n                            mp->neigh[N]=nmp;\n                            if(mp->Cell!=nmp->Cell){\n                                //mp->Cell->nodesToRetract.push_back(mp);\n                                mp->springJunction=true;\n                                nmp->springJunction = true;\n                            }\n\n\n                            ecp->createSpringTokenObject(mp, nmp, N);\n                            if(nmp->circlePos==POSplus) mp->SpringNeigh[N]->right=true;\n                            else mp->SpringNeigh[N]->right=false;\n                            N++;\n\n                        }\n                    }\n                    mp->neighs=N;\n\n                }\n\n\n            }\n\n        }\n\n    }\n    //check all springs are correctly labelled left right and hor/ver\n    int k;\n    int flag1=0; int flag2=0; int flag3=0; int flag4=0;\n\n    for(i=0;i<uptoE;i++){\n        ecp=ECagents[i];\n        uptoM=ecp->nodeAgents.size();\n\n        for(j=0;j<uptoM;j++){\n            flag1 = 0;\n            flag2 = 0;\n            flag3 = 0;\n            flag4 = 0;\n            mp=ecp->nodeAgents[j];\n            for(k=0;k<mp->neighs;k++){\n                if((flag1==0)&&(mp->SpringNeigh[k]->horizontal==true)&&(mp->SpringNeigh[k]->right==true)){\n                    flag1=1;\n                }\n                if((flag2==0)&&(mp->SpringNeigh[k]->horizontal==true)&&(mp->SpringNeigh[k]->right==false)){\n                    flag2=1;\n                }\n                if((flag3==0)&&(mp->SpringNeigh[k]->horizontal==false)&&(mp->SpringNeigh[k]->right==true)){\n                    flag3=1;\n                }\n                if((flag4==0)&&(mp->SpringNeigh[k]->horizontal==false)&&(mp->SpringNeigh[k]->right==false)){\n                    flag4=1;\n                }\n            }\n\n            if(flag4!=1){\n\t\t\t\tstd::cout<<\"cell: \"<<i<<\"cirPos \"<<mp->circlePos<<\" x \"<<(int)mp->Mx<<std::endl;\n            }\n        }\n    }\n\n}\n//-------------------------------------------------------------------------\n//------------------------------------------------------------------------\n//-------------------------------------------------------------------------\nvoid World::createNewEnvAgent(int x, int y, int z){\n    \n\n\n\n        if(grid[x][y][z].Eid!=NULL){\n\t\t\tstd::cout<<\"already got an env agent in createNew\"<<std::endl;\n        }\n        Env * ep = new Env((World*) this);\n        \n        ep->Ex = x;\n        ep->Ey = y;\n        ep->Ez = z;\n        grid[x][y][z].Eid = ep;\n        grid[x][y][z].type = const_E;\n        \n        //if((timeStep>0)&&(y<vesselRadius*2+gap)) replaceBlood(x, y, z);\n        \n//        if(timeStep!=0)calcEnvAgentVEGF(ep);\n        ep->calcInside();\n    \n    \n   \n}\n//-------------------------------------------------------------------------\n\n\n    void World::createAstrocytes(void){\n        \n        \n        int i, j, k, m;\n        int centreX, centreY;\n        \n        int howMany =(int)((float)xMAX/(float)(astroWidth+astroSpacer));\n        \n        int W=(int)((float)astroWidth/2.0f);\n        int V=(int)((float)astroSpacer/2.0f);\n        int p1[howMany];int p2[howMany];\n        int b1[howMany];int b2[howMany];\n        //-------------------------------------------\n        //uniform layer of astrocytes\n        if(ASTRO==UNIFORM){\n            for(i=0;i<xMAX;i++)\n                for(j=0;j<yMAX;j++){\n                    for(m=0;m<Zgap;m++){\n                        grid[i][j][m].Eid->Astro=true;\n                        grid[i][j][m].Eid->OldAstro=true;\n                        //cout<<\"made astrocyte...\"<<endl;\n                    }\n                }\n        }\n        //-------------------------------------------\n        //-------------------------------------------\n        //curved circles\n        if(ASTRO==CURVED_CIRCLES){\n#define Cradius 8\n#define Cgap 4\n            \n            int howManyH = (int)((float)xMAX/(float)((Cradius*2)+Cgap));\n            int howManyV = (int)((float)yMAX/(float)((Cradius*2)+Cgap));\n            \n            for(i=0;i<xMAX;i++)\n                for(j=0;j<yMAX;j++){\n                    //grid[i][j][0].type=AS;\n                }\n            \n            for(i=0;i<howManyH;i++)\n                for(j=0;j<howManyV;j++){\n                    centreX = (int)((float)Cgap/2.0f+Cradius+(i*(Cgap+(Cradius*2))));\n                    //centreX = m*(Cgap+(Cradius*2));\n                    centreY = (int)((float)Cgap/2.0f+(2*vesselRadius)-4+Cgap+Cradius+(j*(Cgap+(Cradius*2))));\n                    for(k=0;k<2*Cradius;k++){\n                        for(m=0;m<2*Cradius;m++){\n                            if(getDist(centreX, centreY, 0, centreX-Cradius+k, centreY-Cradius+m, 0)<Cradius){\n                                if(insideWorld(centreX-Cradius+k, centreY-Cradius+m, 0)==true)\n                                    grid[centreX-Cradius+k][centreY-Cradius+m][0].type = const_E;\n                            }\n                        }\n                    }\n                }\n            \n            \n        }\n        //----------------------------------------------\n        //regular criss-cross network\n        if(ASTRO==DIAG){\n            for(j=0;j<yMAX;j++){\n                \n                \n                for(i=0;i<xMAX;i++){\n                    \n                    for(k=0;k<howMany;k++){\n                        \n                        p1[k]=j+(k*(astroWidth+astroSpacer))-W;\n                        p2[k]=j+astroWidth+(k*(astroWidth+astroSpacer))-W;\n                        \n                        b1[k]=(k*(astroWidth+astroSpacer))-j-W;\n                        b2[k]=astroWidth+(k*(astroWidth+astroSpacer))-j-W;\n                        \n                        if(p1[k]>xMAX)\n                            p1[k] = p1[k]%xMAX;\n                        \n                        if(p2[k]>xMAX)\n                            p2[k] = p2[k]%xMAX;\n                        \n                        if(b1[k]<0)\n                            b1[k] = xMAX+(b1[k]%xMAX);\n                        \n                        if(b2[k]<0)\n                            b2[k] = xMAX+(b2[k]%xMAX);\n                        \n                        if(p1[k]<0)\n                            p1[k] = xMAX+(p1[k]%xMAX);\n                        \n                        if(p2[k]<0)\n                            p2[k] = xMAX+(p2[k]%xMAX);\n                        //-------------------------------\n                        //normal case\n                        if((p2[k]>p1[k])){\n                        //    if((i>=p1[k])&&(i<p2[k])) grid[i][j][0].type=AS;\n                        }\n                        //-------------------------------\n                        //has wrapped around only p2\n                        else{\n                        //    if((i>=p1[k])||(i<p2[k])) grid[i][j][0].type=AS;\n                        }\n                        //-------------------------------\n                        //-------------------------------\n                        //normal case\n                        if((b2[k]>b1[k])){\n                        //    if((i>=b1[k])&&(i<b2[k])) grid[i][j][0].type=AS;\n                        }\n                        //-------------------------------\n                        //has wrapped around only p2\n                        else{\n                        //   if((i>=b1[k])||(i<b2[k])) grid[i][j][0].type=AS;\n                        }\n                        //-------------------------------\n                    }\n                    \n                }\n            }\n        }\n        //-------------------------------------------\n        //-------------------------------------------\n        //regular square network\n        if(ASTRO==SQUARES){\n           \n            for(k=0;k<howMany;k++){\n                \n                /*Coordinates One;\n                 * Coordinates Two;\n                 * Coordinates Anchor;\n                 *\n                 * Anchor.x = 0.0f+k*(astroWidth+astroSpacer)+2*V;\n                 * Anchor.y = 10.0f;\n                 * Anchor.z = 0.0f;\n                 *\n                 * Two.x =  Anchor.x+V+astroWidth/2.0f+2*V;\n                 * Two.y =Vspacer;\n                 * Two.z = 0.0f;\n                 *\n                 * One.x =  Anchor.x-(V+astroWidth/2.0f)+2*V;\n                 * One.y = Vspacer;\n                 * One.z = 0.0f;\n                 *\n                 * curvedAstrocytes(One, Two, Anchor);*/\n                \n                p1[k]=(k*(astroWidth+astroSpacer))+V;\n                p2[k]=astroWidth+(k*(astroWidth+astroSpacer))+V;\n                \n                if(p1[k]>xMAX)\n                    p1[k] = p1[k]%xMAX;\n                \n                if(p2[k]>xMAX)\n                    p2[k] = p2[k]%xMAX;\n                \n                if(p1[k]<0)\n                    p1[k] = xMAX+(p1[k]%xMAX);\n                \n                if(p2[k]<0)\n                    p2[k] = xMAX+(p2[k]%xMAX);\n                \n                \n            }\n            for(j=0;j<yMAX;j++){\n                //for(j=0;j<53;j++){\n                for(i=0;i<xMAX;i++){\n                    for(k=0;k<howMany;k++){\n                        \n                        //-------------------------------\n                        //normal case\n                        if((p2[k]>p1[k])){\n                            if((i>=p1[k])&&(i<p2[k])){\n                                for(m=0;m<4;m++){\n                                    grid[i][j][m].Eid->Astro=true;\n                                    grid[i][j][m].Eid->OldAstro=true;\n                                }\n                            }\n                            \n                        }\n                        //-------------------------------\n                        //has wrapped around only p2\n                        else{\n                            if((i>=p1[k])||(i<p2[k])){\n                                for(m=0;m<4;m++){\n                                    grid[i][j][m].Eid->Astro=true;\n                                    grid[i][j][m].Eid->OldAstro=true;\n                                }\n                            }\n                        }\n                        //-------------------------------\n                    }\n                    /*if((j%Vspacer==-2+6)||(j%Vspacer==-1+6)||(j%Vspacer==0+6)||(j%Vspacer==1+6\n                            )){\n                        for(m=0;m<4;m++){\n                            grid[i][j][m].type=AS;\n                            grid[i][j][m].oldType=AS;\n                        }\n                    }*/\n                }\n            }\n            \n        }\n        //-------------------------------------------\n        //regular square network\n        if(ASTRO==ZEBRAFISH){\n            for(k=0;k<howMany;k++){\n                \n                /*Coordinates One;\n                 * Coordinates Two;\n                 * Coordinates Anchor;\n                 *\n                 * Anchor.x = 0.0f+k*(astroWidth+astroSpacer)+2*V;\n                 * Anchor.y = 10.0f;\n                 * Anchor.z = 0.0f;\n                 *\n                 * Two.x =  Anchor.x+V+astroWidth/2.0f+2*V;\n                 * Two.y =Vspacer;\n                 * Two.z = 0.0f;\n                 *\n                 * One.x =  Anchor.x-(V+astroWidth/2.0f)+2*V;\n                 * One.y = Vspacer;\n                 * One.z = 0.0f;\n                 *\n                 * curvedAstrocytes(One, Two, Anchor);*/\n                \n                p1[k]=(k*(astroWidth+astroSpacer))+V;\n                p2[k]=astroWidth+(k*(astroWidth+astroSpacer))+V;\n                \n                if(p1[k]>xMAX)\n                    p1[k] = p1[k]%xMAX;\n                \n                if(p2[k]>xMAX)\n                    p2[k] = p2[k]%xMAX;\n                \n                if(p1[k]<0)\n                    p1[k] = xMAX+(p1[k]%xMAX);\n                \n                if(p2[k]<0)\n                    p2[k] = xMAX+(p2[k]%xMAX);\n                \n                \n            }\n            //for(j=0;j<yMAX;j++){\n            for(j=0;j<Vspacer+13;j++){\n                for(i=0;i<xMAX;i++){\n                    for(m=0;m<4;m++){\n                        for(k=0;k<howMany;k++){\n                            \n                            //-------------------------------\n                            //normal case\n                            if((p2[k]>p1[k])){\n                            //    if((i>=p1[k])&&(i<p2[k])) grid[i][j][m].type=AS;\n                            }\n                            //-------------------------------\n                            //has wrapped around only p2\n                            else{\n                            //    if((i>=p1[k])||(i<p2[k])) grid[i][j][m].type=AS;\n                            }\n                            //-------------------------------\n                        }\n                        //if((j%Vspacer==-3+10)||(j%Vspacer==-2+10)||(j%Vspacer==-1+10)||(j%Vspacer==0+10)||(j%Vspacer==1+10)||(j%Vspacer==2+10)) grid[i][j][m].type=AS;\n                    }\n                }\n            }\n            \n        }\n        \n\t\t//cout<<\"astros\"<<endl;\n        \n        //-------------------------------------------\n    }\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n    bool World::replaceAstrocytes(int i, int j, bool checkOnly){\n        \n        \n        int k, m, n;\n        bool flag=false;\n#define Cradius 8\n#define Cgap 4\n        int flagA=0;\n        int howMany =(int)((float)xMAX/(float)(astroWidth+astroSpacer));\n        \n        int W=(int)((float)astroWidth/2.0f);\n        int V=(int)((float)astroSpacer/2.0f);\n        int p1[howMany];int p2[howMany];\n        int b1[howMany];int b2[howMany];\n        int centreX, centreY;\n        \n        //-------------------------------------------\n        //uniform layer of astrocytes\n        if(ASTRO==UNIFORM){\n            \n            if(checkOnly==false) grid[i][j][3].Eid->Astro=true;\n            flag=true;\n            \n        }\n        //-------------------------------------------\n        //-------------------------------------------\n        //curved circles\n        if(ASTRO==CURVED_CIRCLES){\n            \n            \n            int howManyH = (int)((float)xMAX/(float)((Cradius*2)+Cgap));\n            int howManyV = (int)((float)yMAX/(float)((Cradius*2)+Cgap));\n            \n            for(m=0;m<howManyH;m++)\n                for(n=0;n<howManyV;n++){\n                    centreX = (int)((float)Cgap/2.0f+Cradius+(m*(Cgap+(Cradius*2))));\n                    //centreY = (float)Cgap/2.0f+(2*vesselRadius)-4+Cgap+Cradius+(n*(Cgap+(Cradius*2)));\n                    //centreX = m*(Cgap+(Cradius*2));\n                    centreY = (int)((float)Cgap/2.0f+(2*vesselRadius)-4+Cgap+Cradius+(n*(Cgap+(Cradius*2))));\n                    \n                    if(getDist(centreX, centreY, 0, (float)i, (float)j, 0)<Cradius){\n                        flagA=1;\n                        break;\n                    }\n                    \n                    \n                }\n            \n            if(flagA==0){\n                if(checkOnly==true) flag=true;\n                else grid[i][j][3].Eid->Astro=true;\n            }\n            \n        }\n        //----------------------------------------------\n        //----------------------------------------------\n        //regular criss-cross network\n        if(ASTRO==DIAG){\n            \n            for(k=0;k<howMany;k++){\n                \n                p1[k]=j+(k*(astroWidth+astroSpacer))-W;\n                p2[k]=j+astroWidth+(k*(astroWidth+astroSpacer))-W;\n                \n                b1[k]=(k*(astroWidth+astroSpacer))-j-W;\n                b2[k]=astroWidth+(k*(astroWidth+astroSpacer))-j-W;\n                \n                if(p1[k]>xMAX)\n                    p1[k] = p1[k]%xMAX;\n                \n                if(p2[k]>xMAX)\n                    p2[k] = p2[k]%xMAX;\n                \n                if(b1[k]<0)\n                    b1[k] = xMAX+(b1[k]%xMAX);\n                \n                if(b2[k]<0)\n                    b2[k] = xMAX+(b2[k]%xMAX);\n                \n                if(p1[k]<0)\n                    p1[k] = xMAX+(p1[k]%xMAX);\n                \n                if(p2[k]<0)\n                    p2[k] = xMAX+(p2[k]%xMAX);\n                //-------------------------------\n                //normal case\n                if((p2[k]>p1[k])){\n                    if((i>=p1[k])&&(i<p2[k])){\n                        if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                        flag=true;\n                    }\n                }\n                //-------------------------------\n                //has wrapped around only p2\n                else{\n                    if((i>=p1[k])||(i<p2[k])){\n                        if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                        flag=true;\n                    }\n                }\n                //-------------------------------\n                //-------------------------------\n                //normal case\n                if((b2[k]>b1[k])){\n                    if((i>=b1[k])&&(i<b2[k])){\n                        if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                        flag=true;\n                    }\n                }\n                //-------------------------------\n                //has wrapped around only p2\n                else{\n                    if((i>=b1[k])||(i<b2[k])){\n                        if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                        flag=true;\n                    }\n                }\n                //-------------------------------\n            }\n            \n        }\n        \n        //-------------------------------------------\n        //-------------------------------------------\n        //regular square network\n        if(ASTRO==SQUARES){\n            for(k=0;k<howMany;k++){\n                \n                p1[k]=(k*(astroWidth+astroSpacer))+V;\n                p2[k]=astroWidth+(k*(astroWidth+astroSpacer))+V;\n                \n                if(p1[k]>xMAX)\n                    p1[k] = p1[k]%xMAX;\n                \n                if(p2[k]>xMAX)\n                    p2[k] = p2[k]%xMAX;\n                \n                if(p1[k]<0)\n                    p1[k] = xMAX+(p1[k]%xMAX);\n                \n                if(p2[k]<0)\n                    p2[k] = xMAX+(p2[k]%xMAX);\n            }\n            //for(j=0;j<yMAX;j++){\n            if(j<yMAX){\n                for(k=0;k<howMany;k++){\n                    \n                    //-------------------------------\n                    //normal case\n                    if((p2[k]>p1[k])){\n                        if((i>=p1[k])&&(i<p2[k])){\n                            if(checkOnly==false)grid[i][j][3].Eid->Astro = true;\n                            flag=true;\n                        }\n                    }\n                    //-------------------------------\n                    //has wrapped around only p2\n                    else{\n                        if((i>=p1[k])||(i<p2[k])){\n                            if(checkOnly==false)grid[i][j][3].Eid->Astro = true;\n                            flag=true;\n                        }\n                    }\n                    //-------------------------------\n                    \n                }\n                /*if((j%Vspacer==-3+10)||(j%Vspacer==-2+10)||(j%Vspacer==-1+10)||(j%Vspacer==0+10)||(j%Vspacer==1+10)||(j%Vspacer==2+10)){\n                    if(checkOnly==false)grid[i][j][3].type=AS;\n                    flag=true;\n                }*/\n            }\n        }\n//-------------------------------------------\n        //regular square network\n        if(ASTRO==ZEBRAFISH){\n            for(k=0;k<howMany;k++){\n                \n                p1[k]=(k*(astroWidth+astroSpacer))+V;\n                p2[k]=astroWidth+(k*(astroWidth+astroSpacer))+V;\n                \n                if(p1[k]>xMAX)\n                    p1[k] = p1[k]%xMAX;\n                \n                if(p2[k]>xMAX)\n                    p2[k] = p2[k]%xMAX;\n                \n                if(p1[k]<0)\n                    p1[k] = xMAX+(p1[k]%xMAX);\n                \n                if(p2[k]<0)\n                    p2[k] = xMAX+(p2[k]%xMAX);\n            }\n            //for(j=0;j<yMAX;j++){\n            if(j<Vspacer+13){\n                for(k=0;k<howMany;k++){\n                    \n                    //-------------------------------\n                    //normal case\n                    if((p2[k]>p1[k])){\n                        if((i>=p1[k])&&(i<p2[k])){\n                            if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                            flag=true;\n                        }\n                    }\n                    //-------------------------------\n                    //has wrapped around only p2\n                    else{\n                        if((i>=p1[k])||(i<p2[k])){\n                            if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                            flag=true;\n                        }\n                    }\n                    //-------------------------------\n                    \n                }\n                if((j%Vspacer==-3+10)||(j%Vspacer==-2+10)||(j%Vspacer==-1+10)||(j%Vspacer==0+10)||(j%Vspacer==1+10)||(j%Vspacer==2+10)){\n                    if(checkOnly==false)grid[i][j][0].Eid->Astro = true;\n                    flag=true;\n                }\n            }\n        }\n        /*if(ASTRO==RETINA){\n    Coordinates start1;\n    Coordinates start2;\n    Coordinates end;\n    //int branch = vesselRadius+gap+30;\n    Coordinates branch;\n    float width =12;\n    int drop = 1;\n    int dropSpacer = 9;\n     vector <float> equ1;\n     vector <float> equ2;\n     vector <float> equ3;\n    int m, n, in;\n    float x, x2;\n     \n    start1.x = ECwidth*0.7;\n    start1.y = 0;\n    start1.z = 0;\n     \n    start2.x = ECwidth*3.5;\n    start2.y = 0;\n    start2.z = 0;\n     \n    end.x = ECwidth*2.5;\n    end.y  = 110;\n    end.z = 0;\n     \n    branch.x = 9;\n    branch.y = 55;\n    branch.z = 0;\n     \n    int diff=25;\n    //get equation of the line through start1 and end\n    equ1 = equation_of_line_through_two_points(start1.x, start1.y, end.x, end.y);\n    equ2 = equation_of_line_through_two_points(start2.x, start2.y, end.x, end.y);\n    equ3 = equation_of_line_through_two_points(branch.x, branch.y, start2.x+5, start2.y+diff-5);\n    //for each y between start1.y and end.y calc x and z and create astro in all width upto width, reduce widtrh by drop spacer..\n    in=0;\n    int count=0;\n     \n            if(j<vesselRadius*2+2){\n                if(checkOnly==false)grid[i][j][0].type=AS;\n                        flag=true;\n            }\n     \n     \n     \n    for(m=start1.y;m<end.y;m++){\n     \n     \n        if(count%dropSpacer==0) width-=drop;\n        if(width<2) width=2;\n        if((m>=end.y-35)&&(m<=end.y-30)) in++;\n        if(m>=end.y-20) in=3;\n        if(m>=end.y-5) in=0;\n        x = ((float)m-equ1[1])/equ1[0];\n     \n        for(n=x-(width);n<=x+(width)+in;n++){\n            if((n==i)&&(m==j)){\n                if(checkOnly==false)grid[i][j][0].type=AS;\n                        flag=true;\n            }\n        }\n        count++;\n    }\n    width =12;\n    count=0;\n    in =0;\n    for(m=start2.y;m<end.y;m++){\n     \n        if(count%dropSpacer==0) width-=drop;\n        if(width<2) width=2;\n        if((m>=end.y-35)&&(m<=end.y-30)) in++;\n        if(m>=end.y-20) in=3;\n        if(m>=end.y-5) in=0;\n        if(in<0) in=0;\n        x2 = ((float)m-equ2[1])/equ2[0];\n     \n        for(n=x2-(width)-in;n<=x2+(width);n++){\n            if((n==i)&&(m==j)){\n                if(checkOnly==false)grid[i][j][0].type=AS;\n                        flag=true;\n            }\n        }\n     \n        //if((i>=branch)&&(i<branch+branchWidth)){\n        //    for(j=10;j<x2;j++){\n        //        grid[j][i][0].type=AS;\n        //    }\n        //}\n     \n         count++;\n    }\n     \n    width =8;\n    count=0;\n    for(m=start2.y+diff; m<branch.y; m++){\n     \n        if(count%dropSpacer==0) width++;\n        //if(width>3) width=4;\n        x2 = ((float)m-equ3[1])/equ3[0];\n     \n        for(n=x2-(width);n<=x2+(width);n++){\n            if((n==i)&&(m==j)){\n                if(checkOnly==false)grid[i][j][0].type=AS;\n                        flag=true;\n            }\n        }\n     \n         count++;\n    }\n    }*/\n        \n        //create branch\n        \n        return(flag);\n        //-------------------------------------------\n    }\n//-------------------------------------------------------------------------\n    void World::createEnvironment(void){\n        \n        int i, j, k;\n        Env* ep;\n        //create environment onjects and place on grid++++++++++++++++++++++++++++++++++++++\n        for(i=0;i<xMAX;i++)\n            for(j=0;j<yMAX;j++){\n                for(k=0;k<zMAX;k++){\n                    if((grid[i][j][k].type == const_E)&&(grid[i][j][k].Eid==NULL)){\n                        createNewEnvAgent(i, j, k);\n                        //ep=grid[i][j][k].Eid;\n                        \n                    }\n                    \n                }\n            }\n        \n        \n        //createBlood();\n        \n        //if(VEGFgradient==FIXED_MACROS) initialise_macrophage_VEGF();\n        \n        //createTumourCells();\n        \n        //createECM();\n        \n        //calcVEGFgradient();    //--does in createEnvAgent now, no need to go through them all again\n        \n        \n    }\n//-------------------------------------------------------------------------\n    void World::setInitialVEGF(void){\n\n        int i, j, k;\n        Env* ep;\n        \n        //create environment onjects and place on grid++++++++++++++++++++++++++++++++++++++\n        for(i=0;i<xMAX;i++)\n            for(j=0;j<yMAX;j++){\n                for(k=0;k<zMAX;k++){\n                    \n                    if((grid[i][j][k].type == const_E)&&(grid[i][j][k].Eid!=NULL)) {\n                        \n                        ep = grid[i][j][k].Eid;\n                        calcEnvAgentVEGF(ep);\n                        //if(ep->VEGF>0)\n                    }\n                }\n            }\n\n    }\n//-------------------------------------------------------------------------------------------------------------\n    void EC::createSpringTokenObject(MemAgent* start, MemAgent* end, int neigh){\n        \n        int flag=0;\n        int i;\n        Spring* stp;\n        int flag2=0;\n        int flag3=0;\n        \n        stp= new Spring();\n        \n        stp->start = start;\n        stp->end = end;\n        \n        if((start->FIL==BASE)&&(end->FIL==TIP)) flag=1;\n        \n        else if((start->FIL==BASE)&&(end->FIL==STALK))flag=1;\n        \n        else if((start->FIL==STALK)||(end->FIL==STALK))flag=1;\n        \n        if(flag==1) stp->filopodia=true;\n        \n        //set nodeagents to know this is the spring object they belong to\n        \n        start->SpringNeigh[neigh]=stp;\n        \n        \n        Springs.push_back(stp);\n        \n        if(start->Cell!=end->Cell){\n            stp->Junction=true;\n            stp->filopodia=false;\n            flag=0;\n            /*i=0;\n            //add start and end to junction agent list if not already in there..\n            if(worldP->JunctionAgents.size()>0){\n            do{\n                if(worldP->JunctionAgents[i]==start) flag2=1;\n                if(worldP->JunctionAgents[i]==end) flag3=1;\n                if((flag2==1)&&(flag3==1)) flag-1;\n                i++;\n\n            }while((flag==0)&&(i<worldP->JunctionAgents.size()));\n\n            if(flag2==0) worldP->JunctionAgents.push_back(start);\n            if(flag3==0) worldP->JunctionAgents.push_back(end);\n            }*/\n        }\n        \n        \n    }\n//-------------------------------------------------------------------------------------------------------------\n    \n//-------------------------------------------------------------------------\n    void World::createTestCase(void){\n        \n        int i, j;\n        int MEMS=2;\n        MemAgent* memp;\n        EC* ecp;\n\n\tstd::cout<<\"creating...\"<<std::endl;\n\tstd::cout.flush();\n        \n        //create EC agents-----------------------\n        for(i=0;i<2;i++){\n            \n            //creates new object dynamically of type EC (ecp is the e cell pointer)\n            EC * ecp = new EC((World*) this);\n            \n            //put the address into the vector Ecells\n            ECagents.push_back(ecp);\n        }\n        //---------------------------------------\n\tstd::cout<<\"created cells\"<<std::endl;\n\tstd::cout.flush();\n        //---------------------------------------\n        //create nodeagents\n        for(i=0;i<MEMS;i++){\n            \n            if(i==0) ecp=ECagents[0];\n            else ecp=ECagents[1];\n            \n            \n            for(j=0;j<MEMS;j++){\n                memp = new MemAgent(ecp, (World*) this);\n\t\t\t\tstd::cout<<memp<<std::endl;\n                \n                memp->Mx = i+(i*10);\n                memp->My = j+(j*10);\n                memp->Mz = 2;\n                \n                memp->neighs=2;\n                \n                ecp->nodeAgents.push_back(memp);\n                \n                setMLocation((int)memp->Mx, (int)memp->My, 2, memp);\n                \n                memp->JunctionTest(true);\n            }\n        }\n        //---------------------------------------\n\tstd::cout<<\"created nodes\"<<std::endl;\n\tstd::cout.flush();\n        \n        //---------------------------------------\n        //connect mesh\n        ECagents[0]->nodeAgents[0]->neigh[0] = ECagents[0]->nodeAgents[1];\n        ECagents[0]->nodeAgents[1]->neigh[0] = ECagents[0]->nodeAgents[0];\n        \n        ECagents[1]->nodeAgents[0]->neigh[0] = ECagents[1]->nodeAgents[1];\n        ECagents[1]->nodeAgents[1]->neigh[0] = ECagents[1]->nodeAgents[0];\n        \n        ECagents[0]->nodeAgents[0]->neigh[1] = ECagents[1]->nodeAgents[0];\n        ECagents[0]->nodeAgents[1]->neigh[1] = ECagents[1]->nodeAgents[1];\n        \n        ECagents[1]->nodeAgents[0]->neigh[1] = ECagents[0]->nodeAgents[0];\n        ECagents[1]->nodeAgents[1]->neigh[1] = ECagents[0]->nodeAgents[1];\n\n\tstd::cout<<\"connected springs\"<<std::endl;\n\tstd::cout.flush();\n        //after connecting, create the springToken objects.\n        ECagents[0]->createSpringTokenObject(ECagents[0]->nodeAgents[0], ECagents[0]->nodeAgents[0]->neigh[0], 0);\n        ECagents[0]->createSpringTokenObject(ECagents[0]->nodeAgents[0], ECagents[0]->nodeAgents[0]->neigh[1], 1);\n        ECagents[0]->createSpringTokenObject(ECagents[0]->nodeAgents[1], ECagents[0]->nodeAgents[1]->neigh[0], 0);\n        ECagents[0]->createSpringTokenObject(ECagents[0]->nodeAgents[1], ECagents[0]->nodeAgents[1]->neigh[1], 1);\n        \n        ECagents[1]->createSpringTokenObject(ECagents[1]->nodeAgents[0], ECagents[1]->nodeAgents[0]->neigh[0], 0);\n        ECagents[1]->createSpringTokenObject(ECagents[1]->nodeAgents[0], ECagents[1]->nodeAgents[0]->neigh[1], 1);\n        ECagents[1]->createSpringTokenObject(ECagents[1]->nodeAgents[1], ECagents[1]->nodeAgents[1]->neigh[0], 0);\n        ECagents[1]->createSpringTokenObject(ECagents[1]->nodeAgents[1], ECagents[1]->nodeAgents[1]->neigh[1], 1);\n\n\tstd::cout<<\"created spring objects\"<<std::endl;\n\tstd::cout.flush();\n        /*for(i=0;i<2;i++){\n         * for(j=0;j<2;j++){\n         * for(k=0;k<2;k++){\n         *\n         * cout<<\"node cell: \"<<ECagents[i]->nodeAgents[j]->Cell<<\" neigh cell \"<<ECagents[i]->nodeAgents[j]->neigh[k]->Cell<<\" junction \"<<ECagents[i]->nodeAgents[j]->SpringNeigh[k]->Junction<<\" start cell \"<<ECagents[i]->nodeAgents[j]->SpringNeigh[k]->start->Cell<<\" end cell \"<<ECagents[i]->nodeAgents[j]->SpringNeigh[k]->end->Cell<<endl;\n         *\n         *\n         * }\n         * }\n         * }*/\n        \n        \n        \n        \n\n\n    }\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n    void World::createHaptoTest(void){\n        \n        int i, j, k;\n        EC* ecp =  new EC((World*) this);\n        ECagents.push_back(ecp);\n        ecp->VEGFRtot = 46000;\n        for(i=0;i<xMAX;i++){\n            for(j=0;j<9;j++){\n                for(k=0;k<zMAX;k++){\n                    //create env objs\n                    if(j<4){\n                        Env * ep = new Env((World*) this);\n                        ep->Ex=i; ep->Ey=j;ep->Ez=0;\n                        grid[i][j][k].Eid=ep;\n                        grid[i][j][k].Eid->Astro = true;\n                    }\n                    //create blood\n                    else{\n                        grid[i][j][0].Eid->Astro = true;\n                    }\n                }\n            }\n        }\n        \n        //create and place memAgent\n        MemAgent* memp = new MemAgent(ecp, (World*) this);\n        ecp->nodeAgents.push_back(memp);\n        \n        memp->Mx = 4.0f;\n        memp->My = 6.0f;\n        memp->Mz = 1.0f;\n        memp->node=true;\n        setMLocation((int)memp->Mx, (int)memp->My, (int)memp->Mz, memp);\n        \n    }\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n    void World::runHapto(void){\n        \n        //set new pos\n        float newPos[3] = {4.0f, 0.0f, 0.0f};\n        grid[(int)newPos[0]][(int)newPos[1]][(int)newPos[2]].type = BLOOD;\n        \n        if(timeStep==1){\n            //ECagents[0]->nodeAgents[0]->haptotaxis(newPos[0], newPos[1], newPos[2], AS, false);\n        }\n    }\n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n    void World:: curvedAstrocytes(Coordinates One, Coordinates Two, Coordinates Anchor){\n        \n        //for test only**************88\n        //createEnvironment();\n        //**************************8\n        \n        float A1, B1, C1;\n        float x, y;\n        \n        std:: vector <Coordinates> points;\n        \n        Coordinates Mid;\n        Coordinates Median;\n        Coordinates D;\n        Coordinates sD;\n        Coordinates horizontal;\n        Coordinates vertical;\n        \n        float denom, curve_x_1, curve_x_2, nearest_curve_x, Anchor_hor_y, curve_y ;\n        int flagY, flagX;\n        \n        //define points\n        \n        /*One.x = 10.0f;\n         * One.y = 40.0f;\n         * One.z = 0.0f;\n         *\n         * Two.x = 30.0f;\n         * Two.y = 40.0f;\n         * Two.z = 0.0f;\n         *\n         * Anchor.x = 20.0f;\n         * Anchor.y = 0.0f;\n         * Anchor.z = 0.0f;*/\n        \n        //calc median\n        \n        Mid.x = (One.x +Two.x)/2.0f;\n        Mid.y = (One.y +Two.y)/2.0f;\n        Mid.z = 0.0f;\n        \n        Median.x = Anchor.x-Mid.x;\n        Median.y = Anchor.y-Mid.y;\n        Median.z= 0.0f;\n        \n        denom = sqrt((Median.x*Median.x)+(Median.y*Median.y)+(Median.z*Median.z));\n        \n        sD.x = astroCurveDepth*(Median.x/denom);\n        sD.y = astroCurveDepth*(Median.y/denom);\n        sD.z = 0.0f;\n        \n        D.x = Anchor.x - sD.x;\n        D.y = Anchor.y - sD.y;\n        D.z = Anchor.z - sD.z;\n        \n        //calc curve equation between pairs of pairs\n        float denom2;\n        denom2 = ((One.x-D.x)*((Two.x*Two.x)-(One.x*One.x)))+((Two.x-One.x)*((D.x*D.x)-(One.x*One.x)));\n        A1 = ((Two.y - One.y)*(One.x-D.x)+(D.y - One.y)*(Two.x-One.x))/denom2;\n        \n        B1 = ((Two.y-One.y)-A1*((Two.x*Two.x)-(One.x*One.x)))/(Two.x-One.x);\n        \n        C1 = One.y - A1*(One.x*One.x)-(B1*One.x);\n        \n        //test - draw line\n        /*for(x = 0;x<100;x+=0.1){\n         * y = (A1*x*x)+(B1*x)+C1;\n         * if((x>=0)&&(x<xMAX)&&(y>=0)&&(y<yMAX))\n         * grid[(int)x][(int)y][0].type = AS;\n         * }*/\n        \n        //for all points defined by a b and c check which are enclosed by line One-D, Two-D and the curve.\n        \n        //check which is most vertical..\n        \n        //if(fabs(Anchor.y-One.y)>=fabs(Anchor.y-Two.y)){\n        vertical = One;\n        horizontal = Two;\n        /*}\n         * else{\n         * vertical = Two;\n         * horizontal = One;\n         * }*/\n        \n        for(x=0;x<xMAX;x+=0.1){\n            for(y=0;y<yMAX;y+=0.1){\n                flagY=0;\n                flagX=0;\n                \n                //Anchor_hor_x = equation_of_line_through_two_points_given_Coord(horizontal.x, horizontal.y, Anchor.x, Anchor.y, y ,1);\n                //Anchor_ver_x = equation_of_line_through_two_points_given_Coord(vertical.x, vertical.y, Anchor.x, Anchor.y, y ,1);\n                \n                Anchor_hor_y = equation_of_line_through_two_points_given_Coord(horizontal.x, horizontal.y, Anchor.x, Anchor.y, x, 0);\n                //two roots always, must choose the correct one\n                curve_x_1 = -(B1/A1)+sqrt((y-C1)/A1); //pg 150 book 3\n                curve_x_2 = -(B1/A1)-sqrt((y-C1)/A1);\n                \n                //find nearest root\n                if(getDist(curve_x_1, y, 0.0f, x, y, 0.0f)<=getDist(curve_x_2, y, 0.0f, x, y, 0.0f)) nearest_curve_x = curve_x_1;\n                else nearest_curve_x = curve_x_2;\n                \n                curve_y = (A1*x*x)+(B1*x)+C1;\n                \n                if(((int)y<=(int)horizontal.y)&&((int)y>=(int)Anchor.y)){\n                    if((y>=Anchor.y)&&(y<=curve_y)){\n                        flagY=1;\n                    }\n                    if((x>=vertical.x)&&(x<=horizontal.x)){\n                        flagX=1;\n                    }\n                    \n                    if((flagY==1)&&(flagX==1)){\n                        if(insideWorld((int)x, (int)y, 0)==true)grid[(int)x][(int)y][0].Eid->Astro = true;\n                    }\n                }\n            }\n        }\n        \n        \n        //grid astro\n        \n        /*grid[(int)One.x][(int)One.y][(int)One.z].type = C;\n         * grid[(int)Two.x][(int)Two.y][(int)Two.z].type = C;\n         * grid[(int)Anchor.x][(int)Anchor.y][(int)Anchor.z].type = C;\n         *\n         * cout<<Mid.x<<\" \"<<Mid.y<<\" \"<<Mid.z<<endl;\n         * cout<<D.x<<\" \"<<D.y<<\" \"<<D.z<<endl;\n         *\n         * grid[(int)Mid.x][(int)Mid.y][(int)Mid.z].type = BLOOD;\n         * grid[(int)D.x][(int)D.y][(int)D.z].type = C;*/\n        \n    }\n    \n//-------------------------------------------------------------------------\n//-------------------------------------------------------------------------\n    void World::createMacrophages(void){\n        \n        int i;\n        Macrophage* macp;\n        float offset;\n        int MACS;\n        \n        if(MACROS!=0)\n            MACS = MACROS;\n        else MACS = 1;\n        \n        offset = ((float)xMAX/((float)MACS))/2.0f+6;\n        \n        for(i=0;i<MACROS;i++){\n            \n            //random\n            \n            //fixed\n            macp = new Macrophage(this);\n            /*if(ECpack>1){\n            if(i==0) macp->coords.x = 30.0f;//offset+(float)xMAX/((float)MACROS)*i;\n            else macp->coords.x = xMAX-30.0f;\n        }\n        else macp->coords.x = 10.0f;\n        macp->coords.y = 70.0f;//40.0f;\n        macp->coords.z = 0.0f;*/\n            \n            //grid[(int)macp->coords.x][(int)macp->coords.y][(int)macp->coords.z].type = Mac;\n            macrophages.push_back(macp);\n            if(i==0){\n                macp->coords.x=50.0f;//((float)xMAX/2.0f)+7;//49.0f\n                macp->coords.y=90.0f;//0.0f;//110.0f;//50.0f;\n                macp->coords.z=0.0f;//{((float)xMAX/2.0f)+7, 110.0f, 0.0f};\n            }\n            else{\n                macp->coords.x=25;\n                macp->coords.y=140.0f;\n                macp->coords.z=0.0f;\n            }\n            \n        }\n    }\n//------------------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------------\n//initialise peaked VEGF concentration\n    void World::initialise_macrophage_VEGF(void){\n        \n        int i, j, m;\n        float Dist[MACROS];\n        float accum;\n        \n        \n        \n        for(i=0; i<xMAX; i++){\n            for(j=0; j<yMAX; j++){\n                \n                accum = 0.0f;\n                \n                for(m=0;m<MACROS;m++){\n                    Dist[m] = getDist(macrophages[m]->coords.x, macrophages[m]->coords.y, macrophages[m]->coords.z, (float)i, (float)j, 1 );\n                    //CD[m] = CentreVEGF-Dist[m];\n                    //if(CD[m]<0) CD[m] = 0;\n                    //accum+=CD[m];\n                }\n                \n                if((checkForAstro(i, j, 1)==1)&&(grid[i][j][1].type == const_E)){\n                    grid[i][j][1].Eid->VEGF=accum*VconcST;\n                }\n            }\n        }\n    }\n//-----------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------\n    void World::create_astro_retina_section(void){\n        \n        Coordinates start1;\n        Coordinates start2;\n        Coordinates end;\n        //int branch = vesselRadius+gap+30;\n        Coordinates branch;\n        float width =12;\n        int drop = 1;\n        int dropSpacer = 20;\n\tstd::vector <float> equ1;\n\tstd::vector <float> equ2;\n\tstd::vector <float> equ3;\n        int i, j, in;\n        float x, x2;\n        \n        start1.x = ECwidth*0.7;\n        start1.y = 0;\n        start1.z = 0;\n        \n        start2.x = ECwidth*3.5;\n        start2.y = 0;\n        start2.z = 0;\n        \n        end.x = ECwidth*2.5;\n        end.y  = 150;\n        end.z = 0;\n        \n        branch.x = 9;\n        branch.y = 65;\n        branch.z = 0;\n        \n        int k,m;\n        \n        \n        int diff=35;\n        //get equation of the line through start1 and end\n        equ1 = equation_of_line_through_two_points(start1.x, start1.y, end.x, end.y);\n        equ2 = equation_of_line_through_two_points(start2.x, start2.y, end.x, end.y);\n        equ3 = equation_of_line_through_two_points(branch.x, branch.y, start2.x+5, start2.y+diff-5);\n        //for each y between start1.y and end.y calc x and z and create astro in all width upto width, reduce widtrh by drop spacer..\n        in=0;\n        int count=0;\n        for(i=0;i<vesselRadius*2+2;i++){\n            for(j=0;j<xMAX;j++){\n                for(m=0;m<4;m++){\n                grid[j][i][m].Eid->Astro = true;\n                grid[j][i][m].Eid->OldAstro = true;\n                }\n            }\n        }\n        for(i=start1.y;i<end.y;i++){\n            \n            \n            if(count%dropSpacer==0) width-=drop;\n            if(width<2) width=2;\n            if((i>=end.y-35)&&(i<=end.y-30)) in++;\n            if(i>=end.y-20) in=3;\n            if(i>=end.y-5) in=0;\n            x = ((float)i-equ1[1])/equ1[0];\n            \n            for(j=x-(width);j<=x+(width)+in;j++){\n                if(insideWorld(j, i, 0)==true){\n                    for(m=0;m<4;m++){\n                    grid[j][i][m].Eid->Astro = true;\n                    grid[j][i][m].Eid->OldAstro = true;\n                    }\n                }\n            }\n            count++;\n        }\n        width =12;\n        count=0;\n        in =0;\n        for(i=start2.y;i<end.y;i++){\n            \n            if(count%dropSpacer==0) width-=drop;\n            if(width<2) width=2;\n            if((i>=end.y-35)&&(i<=end.y-30)) in++;\n            if(i>=end.y-20) in=3;\n            if(i>=end.y-5) in=0;\n            if(in<0) in=0;\n            x2 = ((float)i-equ2[1])/equ2[0];\n            \n            for(j=x2-(width)-in;j<=x2+(width);j++){\n                if(insideWorld(j, i, 0)==true){\n                    for(m=0;m<4;m++){\n                    grid[j][i][m].Eid->Astro = true;\n                    grid[j][i][m].Eid->OldAstro = true;\n                    }\n                }\n            }\n            \n            //if((i>=branch)&&(i<branch+branchWidth)){\n            //    for(j=10;j<x2;j++){\n            //        grid[j][i][0].type=AS;\n            //    }\n            //}\n            \n            count++;\n        }\n        \n        width =10;\n        count=0;\n        for(i=start2.y+diff; i<branch.y; i++){\n            \n            if(count%4==0) width++;\n            //if(width>3) width=4;\n            x2 = ((float)i-equ3[1])/equ3[0];\n            \n            for(j=x2-(width);j<=x2+(width);j++){\n                if(insideWorld(j, i, 0)==true){\n                    for(m=0;m<4;m++){\n                    grid[j][i][m].Eid->Astro = true;\n                    grid[j][i][m].Eid->OldAstro = true;\n                    }\n                }\n            }\n            \n            count++;\n        }\n        \n        //create branch\n        \n        \n    }\n    \n    \n//-----------------------------------------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------------------------------------\n\nvoid World::chooseMutants(void){\n\t\n\t\n    //-----------------------------------\n    //random choice.\n    int i;\n    int* pastNo;\n\tint CHOSE =5;\n    pastNo=(int*)calloc(CHOSE, sizeof(int));\n    time_t t;\n    int a;\n    int tot = 10;\n    int ranNo;\n    int k = 0;\n    float b;\n    float c;\n    //b = ((float)rand()/(float)RAND_MAX);\n    b = ((float)new_rand()/(float)NEW_RAND_MAX);\n\t\n\t\n\t//for(i=0;i<5;i++)\n    //Ecells[i]->mutant=true;\n    bool random = true;\n\t\n    //if (b<=0.0){  //half the time it selects five random numbers as below\n    if(random==true){\n\t\tfor(i=0;i<CHOSE;i++)pastNo[i]=-1;\n\t\t\n\t\t\n\t\tdo\n\t\t{\n            //a = (int)(((float)rand()*tot)/(float)RAND_MAX);\n            a = (int)(((float)new_rand()*tot)/(float)NEW_RAND_MAX);\n\t\t\t\n\t\t\tif(a==0){\n\t\t\t\t\n\t\t\t}\n\t\t\tif (AlreadyPicked(a, pastNo, CHOSE) == 0)//&&(noneAdj(pastNo) == 0))\n\t\t\t{\n\t\t\t\tpastNo[k] = a;\n\t\t\t\tk++;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tECagents[a]->mutant=true;\n\t\t\t}\n\t\t}\n\t\twhile (k < CHOSE);\n    }\n\t\n\telse{   //otherwise selects even spaced. Only two predefined options, so half the time picks one, half other..\n\t\t\n        //pastNo[0]=0;\n\t\t//pastNo[1]=2;\n\t\t//pastNo[2]=4;\n\t\t//pastNo[3]=6;\n\t\t// pastNo[4]=8;\n\t\tECagents[0]->mutant=true;\n\t\tECagents[2]->mutant=true;\n\t\tECagents[4]->mutant=true;\n\t\tECagents[6]->mutant=true;\n\t\tECagents[8]->mutant=true;\n\t}\n\t\n\t\n\t\n\t\n\t\n    free(pastNo);\n    pastNo=NULL;\n\t\n\t\n\t\n    //-----------------------------------\n\t\n    //-----------------------------------\n    //three in a row, 5 cells\n\t\n    //-----------------------------------\n\t\n    //-----------------------------------\n\t\n    //-----------------------------------\n}\n//----------------------------------------------------------------------------------------------\n\nint World::AlreadyPicked(int a, int* pastNo, int chose) {\n\t\n    int i;\n    int flag=0;\n    int answer;\n    //int percent = 70; //70%\n    //int totalCells = ((float)ECagents.size()/100.0f)*percent;\n\t\n    for (i = 0; i < chose ; i++)\n    {   if (pastNo[i] == a)\n\t{ flag=1; } /*If any of the array is the same as the random no. just generated, flag is turned to 1*/\n    }\n\t\n    if (flag==1)\n    {answer=1;}\n    else\n    {answer=0;}\n\t\n    return(answer);\n\t\n}\n//-----------------------------------------------------------------------------------------------------\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/creation.cpp b/src/creation.cpp
--- a/src/creation.cpp	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/src/creation.cpp	(date 1626715363477)
@@ -89,17 +89,19 @@
 }
 //-----------------------------------------------------------------------------------------------------------------------
 //-----------------------------------------------------------------------------------------------------------------------
-void MemAgent::connectJunctions(bool alsoNormalSprings){
-	int x=0;
-    int flag=0;
-    int m, n, p,s;
-    float sumV=0;
+void MemAgent::connectJunctions(bool alsoNormalSprings) {
+	// Tom: This appears to only be used for 2D cells level with the Z-plane.
+	int x = 0;
+    int flag = 0;
+    int m, n, p, s;
+    float sumV = 0;
 
-    int i, j, k;
-    i=Mx; j=My; k=Mz;
+    int i = (int)Mx;
+    int j = (int)My;
+    int k = (int)Mz;
 
     //same layer
-    for(x=0;x<6;x++) {
+    for(x = 0; x < 6; x++) {
         if(x==0) {
             m=i;
             n=j+1;
@@ -128,38 +130,45 @@
 
         //-------------------------------
         //toroidal only X
-        if (m >= this->worldP->gridXDimensions)
-        	m = 0;
-        if (m < 0)
-        	m = this->worldP->gridXDimensions - 1;
-        if (n >= this->worldP->gridYDimensions)
-        	n = 0;
-        if (n < 0)
-        	n = this->worldP->gridXDimensions - 1;
+        if (m >= this->worldP->gridXDimensions) {
+			m = 0;
+        }
+
+        if (m < 0) {
+			m = this->worldP->gridXDimensions - 1;
+        }
+
+        if (n >= this->worldP->gridYDimensions) {
+			n = 0;
+        }
+
+        if (n < 0) {
+			n = this->worldP->gridXDimensions - 1;
+        }
 
-        if(worldP->insideWorld(m, n, p)){
-            if(worldP->grid[m][n][p].type == const_M){
-                for(s=0;s<worldP->grid[m][n][p].Mids.size();s++) {
-                    if(worldP->grid[m][n][p].Mids[s]->Cell!=Cell) {
-                        neigh[neighs]=worldP->grid[m][n][p].Mids[s];
+        if (worldP->insideWorld(m, n, p)){
+            if (worldP->grid[m][n][p].type == const_M) {
+                for (s = 0; s < worldP->grid[m][n][p].Mids.size();s++) {
+                    if (worldP->grid[m][n][p].Mids[s]->Cell!=Cell) {
+                    	neigh[neighs] = worldP->grid[m][n][p].Mids[s];
                         Cell->createSpringTokenObject(this, worldP->grid[m][n][p].Mids[s], neighs);
 
-                        if(x==0) {
+                        if (x == 0) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = false;
                             Cell->Springs[Cell->Springs.size()-1]->right = false;
-                        } else if(x==1) {
+                        } else if (x == 1) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = false;
                             Cell->Springs[Cell->Springs.size()-1]->right = true;
-                        } else if(x==2) {
+                        } else if (x == 2) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = true;
                             Cell->Springs[Cell->Springs.size()-1]->right = true;
-                        } else if(x==3) {
+                        } else if (x == 3) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = false;
                             Cell->Springs[Cell->Springs.size()-1]->right = false;
-                        } else if(x==4) {
+                        } else if (x == 4) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = false;
                             Cell->Springs[Cell->Springs.size()-1]->right = false;
-                        } else if(x==5) {
+                        } else if ( x== 5) {
                             Cell->Springs[Cell->Springs.size()-1]->horizontal = true;
                             Cell->Springs[Cell->Springs.size()-1]->right = false;
                         }
@@ -168,26 +177,26 @@
                 }
 
                 if (alsoNormalSprings) {
-                    if(worldP->grid[m][n][p].Mids[s]->Cell==Cell) {
+                    if (worldP->grid[m][n][p].Mids[s]->Cell==Cell) {
                         neigh[neighs]=worldP->grid[m][n][p].Mids[s];
                         Cell->createSpringTokenObject(this, worldP->grid[m][n][p].Mids[s] , neighs);
 
-                        if(x==0) {
+                        if(x == 0) {
                             SpringNeigh[neighs]->horizontal = false;
                             SpringNeigh[neighs]->right = false;
-                        } else if(x==1) {
+                        } else if (x == 1) {
                             SpringNeigh[neighs]->horizontal = false;
                             SpringNeigh[neighs]->right = true;
-                        } else if(x==2) {
+                        } else if (x == 2) {
                             SpringNeigh[neighs]->horizontal = true;
                             SpringNeigh[neighs]->right = true;
-                        } else if(x==3) {
+                        } else if(x == 3) {
                             SpringNeigh[neighs]->horizontal = true;
                             SpringNeigh[neighs]->right = false;
-                        } else if(x==4) {
+                        } else if (x == 4) {
                             SpringNeigh[neighs]->horizontal = false;
                             SpringNeigh[neighs]->right = false;
-                        } else if(x==5) {
+                        } else if (x == 5) {
                             SpringNeigh[neighs]->horizontal =true;
                             SpringNeigh[neighs]->right = false;
                         }
@@ -1679,56 +1688,55 @@
 
     }
 //-------------------------------------------------------------------------------------------------------------
-    void EC::createSpringTokenObject(MemAgent* start, MemAgent* end, int neigh){
+void EC::createSpringTokenObject(MemAgent* start, MemAgent* end, int neigh){
         
-        int flag=0;
-        int i;
-        Spring* stp;
-        int flag2=0;
-        int flag3=0;
+	int flag=0;
+	int i;
+	Spring* stp;
+	int flag2=0;
+	int flag3=0;
         
-        stp= new Spring();
+	stp= new Spring();
         
-        stp->start = start;
-        stp->end = end;
+	stp->start = start;
+	stp->end = end;
         
-        if((start->FIL==BASE)&&(end->FIL==TIP)) flag=1;
-        
-        else if((start->FIL==BASE)&&(end->FIL==STALK))flag=1;
+	if ((start->FIL==BASE)&&(end->FIL==TIP)) {
+		flag=1;
+	} else if((start->FIL==BASE)&&(end->FIL==STALK)) {
+		flag=1;
+	} else if((start->FIL==STALK)||(end->FIL==STALK)) {
+		flag=1;
+	}
+
+	if (flag==1) {
+		stp->filopodia=true;
+	}
         
-        else if((start->FIL==STALK)||(end->FIL==STALK))flag=1;
-        
-        if(flag==1) stp->filopodia=true;
-        
-        //set nodeagents to know this is the spring object they belong to
-        
-        start->SpringNeigh[neigh]=stp;
+	//set nodeagents to know this is the spring object they belong to
+	start->SpringNeigh[neigh]=stp;
         
-        
-        Springs.push_back(stp);
+	Springs.push_back(stp);
         
-        if(start->Cell!=end->Cell){
-            stp->Junction=true;
-            stp->filopodia=false;
-            flag=0;
-            /*i=0;
-            //add start and end to junction agent list if not already in there..
-            if(worldP->JunctionAgents.size()>0){
-            do{
-                if(worldP->JunctionAgents[i]==start) flag2=1;
-                if(worldP->JunctionAgents[i]==end) flag3=1;
-                if((flag2==1)&&(flag3==1)) flag-1;
-                i++;
-
-            }while((flag==0)&&(i<worldP->JunctionAgents.size()));
+	if(start->Cell!=end->Cell){
+		stp->Junction=true;
+		stp->filopodia=false;
+		flag=0;
+		/*i=0;
+		//add start and end to junction agent list if not already in there..
+		if(worldP->JunctionAgents.size()>0){
+		do{
+		if(worldP->JunctionAgents[i]==start) flag2=1;
+		if(worldP->JunctionAgents[i]==end) flag3=1;
+		if((flag2==1)&&(flag3==1)) flag-1;
+		i++;
+		}while((flag==0)&&(i<worldP->JunctionAgents.size()));
 
-            if(flag2==0) worldP->JunctionAgents.push_back(start);
-            if(flag3==0) worldP->JunctionAgents.push_back(end);
-            }*/
-        }
-        
-        
-    }
+		if(flag2==0) worldP->JunctionAgents.push_back(start);
+		if(flag3==0) worldP->JunctionAgents.push_back(end);
+		}*/
+	}
+}
 //-------------------------------------------------------------------------------------------------------------
     
 //-------------------------------------------------------------------------
Index: cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#IncludeRegexLine: ^[ \t]*[#%][ \t]*(include|import)[ \t]*[<\"]([^\">]+)([\">])\n\n#IncludeRegexScan: ^.*$\n\n#IncludeRegexComplain: ^$\n\n#IncludeRegexTransform: \n\n../src/Tissue.h\nvector\n-\nspace.h\n../src/space.h\nprotein.h\n../src/protein.h\n\n../src/objects.h\npybind11/pybind11.h\n-\npybind11/numpy.h\n-\npybind11/stl.h\n-\nvector\n-\niostream\n-\niomanip\n-\nfstream\n-\narray\n-\nrandom\n-\nalgorithm\n-\nutils.h\n../src/utils.h\n\n../src/protein.h\nstring\n-\n\n../src/space.h\nobjects.h\n../src/objects.h\n\n../src/utils.h\n\n/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/generated/dsl_Tissue.cpp\nTissue.h\n-\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache b/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache
--- a/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache	(revision c23d97dedd1a4ed8b5e3bbc409ac65135c08eb95)
+++ b/cmake-build-debug/CMakeFiles/autoSpringAgent.dir/CXX.includecache	(date 1626715946938)
@@ -6,6 +6,22322 @@
 
 #IncludeRegexTransform: 
 
+../libraries/boost/array.hpp
+boost/detail/workaround.hpp
+-
+cstddef
+-
+iterator
+-
+stdexcept
+-
+boost/assert.hpp
+-
+boost/static_assert.hpp
+-
+boost/swap.hpp
+-
+boost/throw_exception.hpp
+-
+algorithm
+-
+boost/config.hpp
+-
+
+../libraries/boost/assert.hpp
+boost/config.hpp
+-
+boost/current_function.hpp
+-
+assert.h
+-
+
+../libraries/boost/assert/source_location.hpp
+boost/current_function.hpp
+-
+boost/config.hpp
+-
+boost/cstdint.hpp
+-
+iosfwd
+-
+
+../libraries/boost/atomic.hpp
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/atomic.hpp
+-
+boost/atomic/atomic_ref.hpp
+-
+boost/atomic/atomic_flag.hpp
+-
+boost/atomic/ipc_atomic.hpp
+-
+boost/atomic/ipc_atomic_ref.hpp
+-
+boost/atomic/ipc_atomic_flag.hpp
+-
+boost/atomic/fences.hpp
+-
+
+../libraries/boost/atomic/atomic.hpp
+cstddef
+-
+boost/cstdint.hpp
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/classify.hpp
+-
+boost/atomic/detail/atomic_impl.hpp
+-
+boost/atomic/detail/type_traits/is_trivially_copyable.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/atomic_flag.hpp
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/atomic_flag_impl.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/atomic_ref.hpp
+boost/assert.hpp
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/intptr.hpp
+-
+boost/atomic/detail/classify.hpp
+-
+boost/atomic/detail/atomic_ref_impl.hpp
+-
+boost/atomic/detail/type_traits/is_trivially_copyable.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/capabilities.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/capabilities.hpp
+-
+boost/atomic/detail/wait_capabilities.hpp
+-
+
+../libraries/boost/atomic/detail/addressof.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/aligned_variable.hpp
+boost/atomic/detail/config.hpp
+-
+boost/config/helper_macros.hpp
+-
+boost/type_traits/type_with_alignment.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/atomic_flag_impl.hpp
+boost/assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/core_operations.hpp
+-
+boost/atomic/detail/wait_operations.hpp
+-
+boost/atomic/detail/aligned_variable.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/atomic_impl.hpp
+cstddef
+-
+boost/assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/intptr.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/bitwise_cast.hpp
+-
+boost/atomic/detail/integral_conversions.hpp
+-
+boost/atomic/detail/core_operations.hpp
+-
+boost/atomic/detail/wait_operations.hpp
+-
+boost/atomic/detail/extra_operations.hpp
+-
+boost/atomic/detail/memory_order_utils.hpp
+-
+boost/atomic/detail/aligned_variable.hpp
+-
+boost/atomic/detail/type_traits/is_signed.hpp
+-
+boost/atomic/detail/type_traits/is_trivially_default_constructible.hpp
+-
+boost/atomic/detail/type_traits/alignment_of.hpp
+-
+boost/atomic/detail/type_traits/conditional.hpp
+-
+boost/atomic/detail/type_traits/integral_constant.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/fp_operations.hpp
+-
+boost/atomic/detail/extra_fp_operations.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/atomic_ref_impl.hpp
+cstddef
+-
+boost/assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/addressof.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/bitwise_cast.hpp
+-
+boost/atomic/detail/core_operations.hpp
+-
+boost/atomic/detail/wait_operations.hpp
+-
+boost/atomic/detail/extra_operations.hpp
+-
+boost/atomic/detail/core_operations_emulated.hpp
+-
+boost/atomic/detail/memory_order_utils.hpp
+-
+boost/atomic/detail/type_traits/is_signed.hpp
+-
+boost/atomic/detail/type_traits/alignment_of.hpp
+-
+boost/atomic/detail/type_traits/conditional.hpp
+-
+boost/atomic/detail/type_traits/integral_constant.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/fp_operations.hpp
+-
+boost/atomic/detail/extra_fp_operations.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/bitwise_cast.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/addressof.hpp
+-
+boost/atomic/detail/string_ops.hpp
+-
+boost/atomic/detail/type_traits/integral_constant.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/bitwise_fp_cast.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/float_sizes.hpp
+-
+boost/atomic/detail/bitwise_cast.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/capabilities.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/int_sizes.hpp
+-
+boost/atomic/detail/float_sizes.hpp
+-
+
+../libraries/boost/atomic/detail/classify.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/type_traits/is_integral.hpp
+-
+boost/atomic/detail/type_traits/is_function.hpp
+-
+boost/atomic/detail/type_traits/is_floating_point.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/config.hpp
+boost/config.hpp
+-
+
+../libraries/boost/atomic/detail/core_arch_operations.hpp
+boost/atomic/detail/core_arch_operations_fwd.hpp
+-
+boost/atomic/detail/core_operations_emulated.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/core_arch_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/core_operations.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/core_arch_operations.hpp
+-
+boost/atomic/detail/core_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/core_operations_emulated.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/core_operations_emulated_fwd.hpp
+-
+boost/atomic/detail/lock_pool.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/core_operations_emulated_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/core_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_fp_operations.hpp
+boost/atomic/detail/extra_fp_ops_generic.hpp
+-
+boost/atomic/detail/extra_fp_ops_emulated.hpp
+-
+
+../libraries/boost/atomic/detail/extra_fp_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_fp_ops_emulated.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/extra_fp_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_fp_ops_generic.hpp
+cstddef
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/extra_fp_operations_fwd.hpp
+-
+boost/atomic/detail/type_traits/is_iec559.hpp
+-
+boost/atomic/detail/type_traits/is_integral.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_operations.hpp
+boost/atomic/detail/extra_ops_generic.hpp
+-
+boost/atomic/detail/extra_ops_emulated.hpp
+-
+
+../libraries/boost/atomic/detail/extra_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_ops_emulated.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/extra_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/extra_ops_generic.hpp
+cstddef
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/integral_conversions.hpp
+-
+boost/atomic/detail/extra_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/fence_arch_operations.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/fence_operations_emulated.hpp
+-
+
+../libraries/boost/atomic/detail/fence_operations.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/fence_arch_operations.hpp
+-
+
+../libraries/boost/atomic/detail/fence_operations_emulated.hpp
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/lock_pool.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/float_sizes.hpp
+float.h
+-
+boost/atomic/detail/config.hpp
+-
+
+../libraries/boost/atomic/detail/footer.hpp
+
+../libraries/boost/atomic/detail/fp_operations.hpp
+boost/atomic/detail/fp_ops_generic.hpp
+-
+boost/atomic/detail/fp_ops_emulated.hpp
+-
+
+../libraries/boost/atomic/detail/fp_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/fp_ops_emulated.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/fp_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/fp_ops_generic.hpp
+cstddef
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/bitwise_fp_cast.hpp
+-
+boost/atomic/detail/storage_traits.hpp
+-
+boost/atomic/detail/fp_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/futex.hpp
+boost/atomic/detail/config.hpp
+-
+sys/syscall.h
+-
+cstddef
+-
+linux/futex.h
+-
+sys/futex.h
+-
+boost/atomic/detail/intptr.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/header.hpp
+boost/config.hpp
+-
+
+../libraries/boost/atomic/detail/int_sizes.hpp
+boost/atomic/detail/config.hpp
+-
+limits.h
+-
+stdint.h
+-
+boost/cstdint.hpp
+-
+wchar.h
+-
+boost/cstdint.hpp
+-
+
+../libraries/boost/atomic/detail/integral_conversions.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/bitwise_cast.hpp
+-
+boost/atomic/detail/type_traits/integral_constant.hpp
+-
+boost/atomic/detail/type_traits/is_signed.hpp
+-
+boost/atomic/detail/type_traits/make_signed.hpp
+-
+boost/atomic/detail/type_traits/make_unsigned.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/intptr.hpp
+boost/cstdint.hpp
+-
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/link.hpp
+boost/atomic/detail/config.hpp
+-
+boost/config/auto_link.hpp
+-
+
+../libraries/boost/atomic/detail/lock_pool.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/link.hpp
+-
+boost/atomic/detail/intptr.hpp
+-
+boost/winapi/thread.hpp
+-
+time.h
+-
+unistd.h
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/memory_order_utils.hpp
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/pause.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/platform.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/futex.hpp
+-
+sys/param.h
+-
+
+../libraries/boost/atomic/detail/storage_traits.hpp
+cstddef
+-
+boost/cstdint.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/string_ops.hpp
+-
+boost/atomic/detail/aligned_variable.hpp
+-
+boost/atomic/detail/type_traits/alignment_of.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/string_ops.hpp
+boost/atomic/detail/config.hpp
+-
+cstring
+-
+
+../libraries/boost/atomic/detail/type_traits/alignment_of.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/alignment_of.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/conditional.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/integral_constant.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_floating_point.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/is_floating_point.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_function.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/is_function.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_iec559.hpp
+limits
+-
+boost/atomic/detail/config.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_integral.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/is_integral.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_signed.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/is_signed.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/is_trivially_copyable.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+
+../libraries/boost/atomic/detail/type_traits/is_trivially_default_constructible.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/has_trivial_constructor.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/make_signed.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/make_signed.hpp
+-
+
+../libraries/boost/atomic/detail/type_traits/make_unsigned.hpp
+boost/atomic/detail/config.hpp
+-
+type_traits
+-
+boost/type_traits/make_unsigned.hpp
+-
+
+../libraries/boost/atomic/detail/wait_capabilities.hpp
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/platform.hpp
+-
+boost/atomic/detail/int_sizes.hpp
+-
+boost/atomic/detail/float_sizes.hpp
+-
+
+../libraries/boost/atomic/detail/wait_operations.hpp
+boost/atomic/detail/wait_ops_generic.hpp
+-
+boost/atomic/detail/wait_ops_emulated.hpp
+-
+
+../libraries/boost/atomic/detail/wait_operations_fwd.hpp
+cstddef
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/wait_ops_emulated.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/lock_pool.hpp
+-
+boost/atomic/detail/wait_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/detail/wait_ops_generic.hpp
+cstddef
+-
+boost/memory_order.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/pause.hpp
+-
+boost/atomic/detail/lock_pool.hpp
+-
+boost/atomic/detail/wait_operations_fwd.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/fences.hpp
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/fence_operations.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/ipc_atomic.hpp
+cstddef
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/classify.hpp
+-
+boost/atomic/detail/atomic_impl.hpp
+-
+boost/atomic/detail/type_traits/is_trivially_copyable.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/ipc_atomic_flag.hpp
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/atomic_flag_impl.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/atomic/ipc_atomic_ref.hpp
+boost/assert.hpp
+-
+boost/static_assert.hpp
+-
+boost/memory_order.hpp
+-
+boost/atomic/capabilities.hpp
+-
+boost/atomic/detail/config.hpp
+-
+boost/atomic/detail/intptr.hpp
+-
+boost/atomic/detail/classify.hpp
+-
+boost/atomic/detail/atomic_ref_impl.hpp
+-
+boost/atomic/detail/type_traits/is_trivially_copyable.hpp
+-
+boost/atomic/detail/header.hpp
+-
+boost/atomic/detail/footer.hpp
+-
+
+../libraries/boost/bind.hpp
+boost/bind/bind.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/bind/arg.hpp
+boost/config.hpp
+-
+boost/is_placeholder.hpp
+-
+
+../libraries/boost/bind/bind.hpp
+boost/config.hpp
+-
+boost/ref.hpp
+-
+boost/mem_fn.hpp
+-
+boost/type.hpp
+-
+boost/is_placeholder.hpp
+-
+boost/bind/arg.hpp
+-
+boost/bind/detail/result_traits.hpp
+-
+boost/bind/std_placeholders.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/visit_each.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/core/is_same.hpp
+-
+utility
+-
+boost/bind/storage.hpp
+-
+boost/bind/bind_template.hpp
+-
+boost/bind/bind_template.hpp
+-
+boost/bind/bind_template.hpp
+-
+boost/bind/bind_cc.hpp
+-
+boost/bind/bind_cc.hpp
+-
+boost/bind/bind_cc.hpp
+-
+boost/bind/bind_cc.hpp
+-
+boost/bind/bind_cc.hpp
+-
+boost/bind/bind_mf_cc.hpp
+-
+boost/bind/bind_mf2_cc.hpp
+-
+boost/bind/bind_mf_cc.hpp
+-
+boost/bind/bind_mf2_cc.hpp
+-
+boost/bind/bind_mf_cc.hpp
+-
+boost/bind/bind_mf2_cc.hpp
+-
+boost/bind/bind_mf_cc.hpp
+-
+boost/bind/bind_mf2_cc.hpp
+-
+boost/bind/bind_mf_cc.hpp
+-
+boost/bind/bind_mf2_cc.hpp
+-
+boost/bind/placeholders.hpp
+-
+
+../libraries/boost/bind/bind_cc.hpp
+
+../libraries/boost/bind/bind_mf2_cc.hpp
+
+../libraries/boost/bind/bind_mf_cc.hpp
+
+../libraries/boost/bind/bind_template.hpp
+
+../libraries/boost/bind/detail/result_traits.hpp
+functional
+-
+
+../libraries/boost/bind/mem_fn.hpp
+boost/config.hpp
+-
+boost/get_pointer.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_vw.hpp
+-
+boost/bind/mem_fn_vw.hpp
+-
+boost/bind/mem_fn_vw.hpp
+-
+boost/bind/mem_fn_vw.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_template.hpp
+-
+boost/bind/mem_fn_cc.hpp
+-
+boost/bind/mem_fn_cc.hpp
+-
+boost/bind/mem_fn_cc.hpp
+-
+boost/bind/mem_fn_cc.hpp
+-
+boost/bind/mem_fn_cc.hpp
+-
+
+../libraries/boost/bind/mem_fn_cc.hpp
+
+../libraries/boost/bind/mem_fn_template.hpp
+
+../libraries/boost/bind/mem_fn_vw.hpp
+
+../libraries/boost/bind/placeholders.hpp
+boost/bind/arg.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/bind/std_placeholders.hpp
+boost/is_placeholder.hpp
+-
+boost/config.hpp
+-
+functional
+-
+type_traits
+-
+
+../libraries/boost/bind/storage.hpp
+boost/config.hpp
+-
+boost/bind/arg.hpp
+-
+
+../libraries/boost/blank.hpp
+boost/blank_fwd.hpp
+../libraries/boost/boost/blank_fwd.hpp
+iosfwd
+-
+boost/detail/templated_streams.hpp
+../libraries/boost/boost/detail/templated_streams.hpp
+boost/type_traits/integral_constant.hpp
+../libraries/boost/boost/type_traits/integral_constant.hpp
+boost/type_traits/is_empty.hpp
+../libraries/boost/boost/type_traits/is_empty.hpp
+boost/type_traits/is_pod.hpp
+../libraries/boost/boost/type_traits/is_pod.hpp
+boost/type_traits/is_stateless.hpp
+../libraries/boost/boost/type_traits/is_stateless.hpp
+
+../libraries/boost/blank_fwd.hpp
+
+../libraries/boost/call_traits.hpp
+boost/config.hpp
+-
+boost/detail/call_traits.hpp
+-
+
+../libraries/boost/checked_delete.hpp
+boost/core/checked_delete.hpp
+-
+
+../libraries/boost/concept/assert.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/concept/detail/msvc.hpp
+-
+boost/concept/detail/borland.hpp
+-
+boost/concept/detail/general.hpp
+-
+
+../libraries/boost/concept/detail/backward_compatibility.hpp
+
+../libraries/boost/concept/detail/borland.hpp
+boost/preprocessor/cat.hpp
+-
+boost/concept/detail/backward_compatibility.hpp
+-
+
+../libraries/boost/concept/detail/concept_def.hpp
+boost/preprocessor/seq/for_each_i.hpp
+-
+boost/preprocessor/seq/enum.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/concept/detail/concept_undef.hpp
+
+../libraries/boost/concept/detail/general.hpp
+boost/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/concept/detail/backward_compatibility.hpp
+-
+boost/concept/detail/has_constraints.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/concept/detail/has_constraints.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/config/workaround.hpp
+-
+boost/concept/detail/backward_compatibility.hpp
+-
+
+../libraries/boost/concept/detail/msvc.hpp
+boost/preprocessor/cat.hpp
+-
+boost/concept/detail/backward_compatibility.hpp
+-
+boost/config.hpp
+-
+boost/concept/detail/has_constraints.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/concept/usage.hpp
+boost/concept/assert.hpp
+-
+boost/config/workaround.hpp
+-
+boost/concept/detail/backward_compatibility.hpp
+-
+
+../libraries/boost/concept_check.hpp
+boost/concept/assert.hpp
+-
+iterator
+-
+boost/type_traits/conversion_traits.hpp
+-
+utility
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/config/workaround.hpp
+-
+boost/concept/usage.hpp
+-
+boost/concept/detail/concept_def.hpp
+-
+boost/concept/detail/concept_undef.hpp
+-
+
+../libraries/boost/config.hpp
+boost/config/user.hpp
+-
+boost/config/detail/select_compiler_config.hpp
+-
+boost/config/detail/select_stdlib_config.hpp
+-
+boost/config/detail/select_platform_config.hpp
+-
+boost/config/detail/suffix.hpp
+-
+
+../libraries/boost/config/auto_link.hpp
+boost/config.hpp
+-
+boost/version.hpp
+-
+
+../libraries/boost/config/compiler/borland.hpp
+climits
+-
+cwchar
+-
+limits.h
+-
+wchar.h
+-
+cstring
+-
+errno.h
+-
+float.h
+-
+
+../libraries/boost/config/compiler/clang.hpp
+
+../libraries/boost/config/compiler/codegear.hpp
+clang.hpp
+../libraries/boost/config/compiler/clang.hpp
+cstring
+-
+errno.h
+-
+
+../libraries/boost/config/compiler/comeau.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/common_edg.hpp
+
+../libraries/boost/config/compiler/compaq_cxx.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/cray.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/digitalmars.hpp
+cstddef
+-
+
+../libraries/boost/config/compiler/gcc.hpp
+cstddef
+-
+stddef.h
+-
+
+../libraries/boost/config/compiler/gcc_xml.hpp
+
+../libraries/boost/config/compiler/greenhills.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/hp_acc.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/intel.hpp
+boost/config/compiler/visualc.hpp
+-
+boost/config/compiler/gcc.hpp
+-
+boost/config/compiler/common_edg.hpp
+-
+cwchar
+-
+
+../libraries/boost/config/compiler/kai.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/metrowerks.hpp
+
+../libraries/boost/config/compiler/mpw.hpp
+
+../libraries/boost/config/compiler/nvcc.hpp
+
+../libraries/boost/config/compiler/pathscale.hpp
+boost/config/compiler/clang.hpp
+../libraries/boost/config/compiler/boost/config/compiler/clang.hpp
+
+../libraries/boost/config/compiler/pgi.hpp
+boost/config/compiler/gcc.hpp
+-
+
+../libraries/boost/config/compiler/sgi_mipspro.hpp
+boost/config/compiler/common_edg.hpp
+-
+
+../libraries/boost/config/compiler/sunpro_cc.hpp
+
+../libraries/boost/config/compiler/vacpp.hpp
+
+../libraries/boost/config/compiler/visualc.hpp
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/config/compiler/xlcpp.hpp
+
+../libraries/boost/config/compiler/xlcpp_zos.hpp
+features.h
+-
+
+../libraries/boost/config/detail/cxx_composite.hpp
+
+../libraries/boost/config/detail/posix_features.hpp
+unistd.h
+-
+
+../libraries/boost/config/detail/select_compiler_config.hpp
+boost/config/compiler/nvcc.hpp
+../libraries/boost/config/detail/boost/config/compiler/nvcc.hpp
+boost/config/compiler/gcc_xml.hpp
+-
+boost/config/compiler/cray.hpp
+-
+boost/config/compiler/comeau.hpp
+-
+boost/config/compiler/pathscale.hpp
+-
+boost/config/compiler/intel.hpp
+-
+boost/config/compiler/clang.hpp
+-
+boost/config/compiler/digitalmars.hpp
+-
+boost/config/compiler/gcc.hpp
+-
+boost/config/compiler/kai.hpp
+-
+boost/config/compiler/sgi_mipspro.hpp
+-
+boost/config/compiler/compaq_cxx.hpp
+-
+boost/config/compiler/greenhills.hpp
+-
+boost/config/compiler/codegear.hpp
+-
+boost/config/compiler/borland.hpp
+-
+boost/config/compiler/metrowerks.hpp
+-
+boost/config/compiler/sunpro_cc.hpp
+-
+boost/config/compiler/hp_acc.hpp
+-
+boost/config/compiler/mpw.hpp
+-
+boost/config/compiler/xlcpp_zos.hpp
+-
+boost/config/compiler/xlcpp.hpp
+-
+boost/config/compiler/vacpp.hpp
+-
+boost/config/compiler/pgi.hpp
+-
+boost/config/compiler/visualc.hpp
+-
+
+../libraries/boost/config/detail/select_platform_config.hpp
+boost/config/detail/posix_features.hpp
+-
+boost/config/platform/linux.hpp
+../libraries/boost/config/detail/boost/config/platform/linux.hpp
+boost/config/platform/bsd.hpp
+../libraries/boost/config/detail/boost/config/platform/bsd.hpp
+boost/config/platform/solaris.hpp
+../libraries/boost/config/detail/boost/config/platform/solaris.hpp
+boost/config/platform/irix.hpp
+../libraries/boost/config/detail/boost/config/platform/irix.hpp
+boost/config/platform/hpux.hpp
+../libraries/boost/config/detail/boost/config/platform/hpux.hpp
+boost/config/platform/cygwin.hpp
+../libraries/boost/config/detail/boost/config/platform/cygwin.hpp
+boost/config/platform/win32.hpp
+../libraries/boost/config/detail/boost/config/platform/win32.hpp
+boost/config/platform/beos.hpp
+../libraries/boost/config/detail/boost/config/platform/beos.hpp
+boost/config/platform/macos.hpp
+../libraries/boost/config/detail/boost/config/platform/macos.hpp
+boost/config/platform/zos.hpp
+../libraries/boost/config/detail/boost/config/platform/zos.hpp
+boost/config/platform/aix.hpp
+../libraries/boost/config/detail/boost/config/platform/aix.hpp
+boost/config/platform/amigaos.hpp
+../libraries/boost/config/detail/boost/config/platform/amigaos.hpp
+boost/config/platform/qnxnto.hpp
+../libraries/boost/config/detail/boost/config/platform/qnxnto.hpp
+boost/config/platform/vxworks.hpp
+../libraries/boost/config/detail/boost/config/platform/vxworks.hpp
+boost/config/platform/symbian.hpp
+../libraries/boost/config/detail/boost/config/platform/symbian.hpp
+boost/config/platform/cray.hpp
+../libraries/boost/config/detail/boost/config/platform/cray.hpp
+boost/config/platform/vms.hpp
+../libraries/boost/config/detail/boost/config/platform/vms.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/detail/select_stdlib_config.hpp
+version
+-
+cstddef
+-
+cstddef
+-
+stddef.h
+-
+utility
+-
+boost/config/stdlib/stlport.hpp
+../libraries/boost/config/detail/boost/config/stdlib/stlport.hpp
+boost/config/stdlib/libcomo.hpp
+../libraries/boost/config/detail/boost/config/stdlib/libcomo.hpp
+boost/config/stdlib/roguewave.hpp
+../libraries/boost/config/detail/boost/config/stdlib/roguewave.hpp
+boost/config/stdlib/libcpp.hpp
+../libraries/boost/config/detail/boost/config/stdlib/libcpp.hpp
+boost/config/stdlib/libstdcpp3.hpp
+../libraries/boost/config/detail/boost/config/stdlib/libstdcpp3.hpp
+boost/config/stdlib/sgi.hpp
+../libraries/boost/config/detail/boost/config/stdlib/sgi.hpp
+boost/config/stdlib/msl.hpp
+../libraries/boost/config/detail/boost/config/stdlib/msl.hpp
+boost/config/stdlib/xlcpp_zos.hpp
+../libraries/boost/config/detail/boost/config/stdlib/xlcpp_zos.hpp
+boost/config/stdlib/vacpp.hpp
+../libraries/boost/config/detail/boost/config/stdlib/vacpp.hpp
+boost/config/stdlib/modena.hpp
+../libraries/boost/config/detail/boost/config/stdlib/modena.hpp
+boost/config/stdlib/dinkumware.hpp
+../libraries/boost/config/detail/boost/config/stdlib/dinkumware.hpp
+
+../libraries/boost/config/detail/suffix.hpp
+limits.h
+-
+cstddef
+-
+typeinfo
+-
+boost/config/helper_macros.hpp
+-
+boost/config/detail/cxx_composite.hpp
+-
+
+../libraries/boost/config/helper_macros.hpp
+
+../libraries/boost/config/no_tr1/cmath.hpp
+cmath
+-
+
+../libraries/boost/config/no_tr1/complex.hpp
+complex
+-
+
+../libraries/boost/config/no_tr1/functional.hpp
+functional
+-
+
+../libraries/boost/config/no_tr1/memory.hpp
+memory
+-
+
+../libraries/boost/config/no_tr1/utility.hpp
+utility
+-
+
+../libraries/boost/config/platform/aix.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/amigaos.hpp
+
+../libraries/boost/config/platform/beos.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/bsd.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/cray.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/cygwin.hpp
+unistd.h
+-
+sys/types.h
+-
+cygwin/version.h
+-
+pthread.h
+-
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/hpux.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/irix.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/linux.hpp
+cstdlib
+-
+stdlib.h
+-
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/macos.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/qnxnto.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/solaris.hpp
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/symbian.hpp
+cstdlib
+-
+stdlib.h
+-
+boost/config/detail/posix_features.hpp
+-
+sys/endian.h
+-
+
+../libraries/boost/config/platform/vms.hpp
+
+../libraries/boost/config/platform/vxworks.hpp
+version.h
+-
+time.h
+-
+sysLib.h
+-
+cstdint
+-
+sys/time.h
+-
+ioLib.h
+-
+tickLib.h
+-
+signal.h
+-
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/platform/win32.hpp
+_mingw.h
+-
+
+../libraries/boost/config/platform/zos.hpp
+features.h
+-
+
+../libraries/boost/config/pragma_message.hpp
+boost/config/helper_macros.hpp
+-
+
+../libraries/boost/config/stdlib/dinkumware.hpp
+boost/config/no_tr1/utility.hpp
+-
+exception
+-
+typeinfo
+-
+
+../libraries/boost/config/stdlib/libcomo.hpp
+boost/config/no_tr1/utility.hpp
+-
+
+../libraries/boost/config/stdlib/libcpp.hpp
+ciso646
+-
+
+../libraries/boost/config/stdlib/libstdcpp3.hpp
+unistd.h
+-
+
+../libraries/boost/config/stdlib/modena.hpp
+boost/config/no_tr1/utility.hpp
+-
+
+../libraries/boost/config/stdlib/msl.hpp
+boost/config/no_tr1/utility.hpp
+-
+cstddef
+-
+boost/config/detail/posix_features.hpp
+-
+
+../libraries/boost/config/stdlib/roguewave.hpp
+boost/config/no_tr1/utility.hpp
+-
+
+../libraries/boost/config/stdlib/sgi.hpp
+boost/config/no_tr1/utility.hpp
+-
+unistd.h
+-
+string
+-
+
+../libraries/boost/config/stdlib/stlport.hpp
+cstddef
+-
+unistd.h
+-
+stdlib.h
+-
+string.h
+-
+algorithm
+-
+
+../libraries/boost/config/stdlib/vacpp.hpp
+unistd.h
+-
+
+../libraries/boost/config/stdlib/xlcpp_zos.hpp
+
+../libraries/boost/config/user.hpp
+
+../libraries/boost/config/workaround.hpp
+boost/config.hpp
+-
+
+../libraries/boost/container/container_fwd.hpp
+boost/config.hpp
+-
+boost/container/detail/std_fwd.hpp
+-
+cstddef
+-
+
+../libraries/boost/container/detail/std_fwd.hpp
+boost/config.hpp
+-
+boost/move/detail/std_ns_begin.hpp
+-
+boost/move/detail/std_ns_end.hpp
+-
+
+../libraries/boost/container_hash/detail/float_functions.hpp
+boost/config.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/container_hash/detail/hash_float.hpp
+boost/config.hpp
+-
+boost/container_hash/detail/float_functions.hpp
+-
+boost/container_hash/detail/limits.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/integer/static_log2.hpp
+-
+boost/cstdint.hpp
+-
+boost/assert.hpp
+-
+boost/limits.hpp
+-
+cstring
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/container_hash/detail/limits.hpp
+boost/config.hpp
+-
+boost/limits.hpp
+-
+float.h
+-
+
+../libraries/boost/container_hash/extensions.hpp
+boost/config.hpp
+-
+boost/container_hash/hash.hpp
+-
+boost/detail/container_fwd.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/static_assert.hpp
+-
+array
+-
+tuple
+-
+memory
+-
+boost/type_traits/is_array.hpp
+-
+
+../libraries/boost/container_hash/hash.hpp
+boost/container_hash/hash_fwd.hpp
+-
+functional
+-
+iterator
+-
+boost/container_hash/detail/hash_float.hpp
+-
+string
+-
+boost/limits.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/cstdint.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+typeindex
+-
+system_error
+-
+string_view
+-
+optional
+-
+variant
+-
+boost/container_hash/extensions.hpp
+-
+
+../libraries/boost/container_hash/hash_fwd.hpp
+boost/config/workaround.hpp
+-
+cstddef
+-
+
+../libraries/boost/core/addressof.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+cstddef
+-
+
+../libraries/boost/core/alloc_construct.hpp
+boost/core/noinit_adaptor.hpp
+-
+
+../libraries/boost/core/allocator_access.hpp
+boost/config.hpp
+-
+boost/core/pointer_traits.hpp
+-
+limits
+-
+type_traits
+-
+new
+-
+utility
+-
+
+../libraries/boost/core/checked_delete.hpp
+boost/config.hpp
+-
+
+../libraries/boost/core/cmath.hpp
+cmath
+-
+float.h
+-
+
+../libraries/boost/core/demangle.hpp
+boost/config.hpp
+-
+string
+-
+cxxabi.h
+-
+cstdlib
+-
+cstddef
+-
+
+../libraries/boost/core/empty_value.hpp
+boost/config.hpp
+-
+utility
+-
+
+../libraries/boost/core/enable_if.hpp
+boost/config.hpp
+../libraries/boost/core/boost/config.hpp
+
+../libraries/boost/core/ignore_unused.hpp
+boost/config.hpp
+-
+
+../libraries/boost/core/is_same.hpp
+boost/config.hpp
+-
+
+../libraries/boost/core/no_exceptions_support.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+
+../libraries/boost/core/noinit_adaptor.hpp
+boost/core/allocator_access.hpp
+-
+
+../libraries/boost/core/noncopyable.hpp
+boost/config.hpp
+-
+
+../libraries/boost/core/nvp.hpp
+boost/core/addressof.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/core/pointer_traits.hpp
+boost/config.hpp
+-
+memory
+-
+boost/core/addressof.hpp
+-
+cstddef
+-
+
+../libraries/boost/core/ref.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/core/addressof.hpp
+-
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/core/swap.hpp
+boost/core/enable_if.hpp
+-
+boost/config.hpp
+-
+utility
+-
+algorithm
+-
+cstddef
+-
+
+../libraries/boost/core/typeinfo.hpp
+boost/config.hpp
+-
+boost/current_function.hpp
+-
+functional
+-
+cstring
+-
+boost/core/demangle.hpp
+-
+typeinfo
+-
+
+../libraries/boost/core/use_default.hpp
+
+../libraries/boost/cstdint.hpp
+boost/config.hpp
+-
+inttypes.h
+-
+inttypes.h
+-
+stdint.h
+-
+inttypes.h
+-
+boost/limits.hpp
+-
+limits.h
+-
+stddef.h
+-
+limits.h
+-
+
+../libraries/boost/current_function.hpp
+
+../libraries/boost/detail/basic_pointerbuf.hpp
+boost/config.hpp
+../libraries/boost/detail/boost/config.hpp
+streambuf
+-
+
+../libraries/boost/detail/call_traits.hpp
+boost/config.hpp
+-
+cstddef
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/detail/container_fwd.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+deque
+-
+list
+-
+vector
+-
+map
+-
+set
+-
+bitset
+-
+string
+-
+complex
+-
+cstddef
+-
+deque
+-
+bitset
+-
+
+../libraries/boost/detail/fenv.hpp
+boost/config.hpp
+-
+features.h
+-
+bits/fenv.h
+-
+../include/fenv.h
+-
+stdio.h
+-
+fenv.h
+-
+
+../libraries/boost/detail/indirect_traits.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+boost/type_traits/is_member_pointer.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/detail/select_type.hpp
+-
+
+../libraries/boost/detail/lcast_precision.hpp
+climits
+-
+ios
+-
+limits
+-
+boost/config.hpp
+-
+boost/integer_traits.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_abstract.hpp
+-
+boost/assert.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/detail/lightweight_mutex.hpp
+boost/smart_ptr/detail/lightweight_mutex.hpp
+-
+
+../libraries/boost/detail/select_type.hpp
+
+../libraries/boost/detail/templated_streams.hpp
+boost/config.hpp
+../libraries/boost/detail/boost/config.hpp
+
+../libraries/boost/detail/workaround.hpp
+boost/config/workaround.hpp
+-
+
+../libraries/boost/exception/exception.hpp
+boost/config.hpp
+-
+memory
+-
+
+../libraries/boost/function.hpp
+functional
+-
+boost/preprocessor/iterate.hpp
+-
+boost/config/workaround.hpp
+-
+boost/function/detail/prologue.hpp
+-
+boost/function/function0.hpp
+-
+boost/function/function1.hpp
+-
+boost/function/function2.hpp
+-
+boost/function/function3.hpp
+-
+boost/function/function4.hpp
+-
+boost/function/function5.hpp
+-
+boost/function/function6.hpp
+-
+boost/function/function7.hpp
+-
+boost/function/function8.hpp
+-
+boost/function/function9.hpp
+-
+boost/function/function10.hpp
+-
+
+../libraries/boost/function/detail/maybe_include.hpp
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+boost/function/function_template.hpp
+-
+
+../libraries/boost/function/detail/prologue.hpp
+cassert
+-
+algorithm
+-
+boost/config/no_tr1/functional.hpp
+-
+boost/throw_exception.hpp
+-
+boost/config.hpp
+-
+boost/function/function_base.hpp
+-
+boost/mem_fn.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/preprocessor/enum.hpp
+-
+boost/preprocessor/enum_params.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/type_traits/is_void.hpp
+-
+
+../libraries/boost/function/function0.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function1.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function10.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function2.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function3.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function4.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function5.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function6.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function7.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function8.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function9.hpp
+boost/function/detail/maybe_include.hpp
+-
+
+../libraries/boost/function/function_base.hpp
+stdexcept
+-
+string
+-
+memory
+-
+new
+-
+boost/config.hpp
+-
+boost/assert.hpp
+-
+boost/integer.hpp
+-
+boost/type_index.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+boost/type_traits/has_trivial_destructor.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/composite_traits.hpp
+-
+boost/ref.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/alignment_of.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/function_equal.hpp
+-
+boost/function/function_fwd.hpp
+-
+
+../libraries/boost/function/function_fwd.hpp
+boost/config.hpp
+-
+
+../libraries/boost/function/function_template.hpp
+boost/function/detail/prologue.hpp
+-
+boost/core/no_exceptions_support.hpp
+-
+
+../libraries/boost/function_equal.hpp
+
+../libraries/boost/function_types/components.hpp
+cstddef
+-
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/integral_c.hpp
+-
+boost/mpl/vector/vector0.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/bitand.hpp
+-
+boost/mpl/vector/vector10.hpp
+-
+boost/mpl/front.hpp
+-
+boost/mpl/begin.hpp
+-
+boost/mpl/advance.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/joint_view.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/copy.hpp
+-
+boost/mpl/front_inserter.hpp
+-
+boost/function_types/detail/classifier.hpp
+-
+boost/mpl/remove.hpp
+-
+boost/function_types/config/config.hpp
+-
+boost/mpl/vector/vector10.hpp
+-
+boost/mpl/vector/vector20.hpp
+-
+boost/mpl/vector/vector30.hpp
+-
+boost/mpl/vector/vector40.hpp
+-
+boost/mpl/vector/vector50.hpp
+-
+boost/function_types/detail/class_transform.hpp
+-
+boost/function_types/property_tags.hpp
+-
+boost/function_types/detail/pp_loop.hpp
+-
+boost/function_types/detail/components_as_mpl_sequence.hpp
+-
+boost/function_types/detail/retag_default_cc.hpp
+-
+
+../libraries/boost/function_types/config/cc_names.hpp
+
+../libraries/boost/function_types/config/compiler.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/function_types/config/config.hpp
+boost/function_types/config/compiler.hpp
+-
+boost/function_types/config/cc_names.hpp
+-
+
+../libraries/boost/function_types/detail/class_transform.hpp
+boost/mpl/apply.hpp
+-
+boost/mpl/always.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/add_pointer.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+
+../libraries/boost/function_types/detail/classifier.hpp
+boost/type.hpp
+-
+boost/config.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/function_types/config/config.hpp
+-
+boost/function_types/property_tags.hpp
+-
+boost/function_types/detail/pp_loop.hpp
+-
+
+../libraries/boost/function_types/detail/components_as_mpl_sequence.hpp
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/empty_fwd.hpp
+-
+boost/mpl/front_fwd.hpp
+-
+boost/mpl/back_fwd.hpp
+-
+boost/mpl/at_fwd.hpp
+-
+boost/mpl/begin_end_fwd.hpp
+-
+boost/mpl/clear_fwd.hpp
+-
+boost/mpl/push_front_fwd.hpp
+-
+boost/mpl/pop_front_fwd.hpp
+-
+boost/mpl/push_back_fwd.hpp
+-
+boost/mpl/pop_back_fwd.hpp
+-
+
+../libraries/boost/function_types/detail/encoding/aliases_def.hpp
+
+../libraries/boost/function_types/detail/encoding/aliases_undef.hpp
+
+../libraries/boost/function_types/detail/encoding/def.hpp
+
+../libraries/boost/function_types/detail/encoding/undef.hpp
+
+../libraries/boost/function_types/detail/pp_loop.hpp
+boost/preprocessor/facilities/expand.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/punctuation/paren.hpp
+-
+boost/function_types/detail/encoding/def.hpp
+-
+boost/function_types/detail/encoding/aliases_def.hpp
+-
+boost/function_types/detail/encoding/aliases_undef.hpp
+-
+boost/function_types/detail/encoding/undef.hpp
+-
+
+../libraries/boost/function_types/detail/pp_retag_default_cc/master.hpp
+boost/preprocessor/slot/slot.hpp
+-
+boost/preprocessor/iteration/self.hpp
+-
+boost/function_types/detail/encoding/def.hpp
+-
+boost/function_types/detail/encoding/aliases_def.hpp
+-
+boost/function_types/detail/encoding/aliases_undef.hpp
+-
+boost/function_types/detail/encoding/undef.hpp
+-
+
+../libraries/boost/function_types/detail/pp_retag_default_cc/preprocessed.hpp
+
+../libraries/boost/function_types/detail/pp_tags/preprocessed.hpp
+
+../libraries/boost/function_types/detail/retag_default_cc.hpp
+boost/mpl/bitand.hpp
+-
+boost/function_types/components.hpp
+-
+boost/function_types/detail/pp_retag_default_cc/master.hpp
+-
+boost/function_types/detail/pp_retag_default_cc/preprocessed.hpp
+-
+
+../libraries/boost/function_types/is_callable_builtin.hpp
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/function_types/is_function.hpp
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/function_types/is_member_function_pointer.hpp
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/function_types/is_member_pointer.hpp
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/function_types/parameter_types.hpp
+boost/blank.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/pop_front.hpp
+-
+boost/function_types/is_callable_builtin.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/function_types/property_tags.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/bitxor.hpp
+-
+boost/function_types/detail/pp_tags/preprocessed.hpp
+-
+boost/function_types/detail/pp_loop.hpp
+-
+
+../libraries/boost/function_types/result_type.hpp
+boost/blank.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/at.hpp
+-
+boost/function_types/is_callable_builtin.hpp
+-
+boost/function_types/components.hpp
+-
+
+../libraries/boost/functional.hpp
+boost/config.hpp
+-
+boost/call_traits.hpp
+-
+functional
+-
+
+../libraries/boost/fusion/adapted/mpl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/adapted/mpl/detail/begin_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/end_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/is_sequence_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/size_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/value_at_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/at_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/has_key_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/category_of_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/is_view_impl.hpp
+-
+boost/fusion/adapted/mpl/detail/empty_impl.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/at.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/mpl/begin.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/category_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/mpl_iterator_category.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/is_sequence.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/empty_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/empty.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/mpl/end.hpp
+-
+boost/type_traits/add_const.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/has_key_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/has_key.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/is_sequence_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/is_view_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/size_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/size.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/at.hpp
+-
+
+../libraries/boost/fusion/adapted/mpl/mpl_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/mpl_iterator_category.hpp
+-
+boost/fusion/iterator/iterator_facade.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/prior.hpp
+-
+boost/mpl/advance.hpp
+-
+boost/mpl/distance.hpp
+-
+
+../libraries/boost/fusion/algorithm.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration.hpp
+-
+boost/fusion/algorithm/query.hpp
+-
+boost/fusion/algorithm/transformation.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/accumulate.hpp
+-
+boost/fusion/algorithm/iteration/fold.hpp
+-
+boost/fusion/algorithm/iteration/for_each.hpp
+-
+boost/fusion/algorithm/iteration/iter_fold.hpp
+-
+boost/fusion/algorithm/iteration/reverse_fold.hpp
+-
+boost/fusion/algorithm/iteration/reverse_iter_fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/accumulate.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/accumulate_fwd.hpp
+-
+boost/fusion/algorithm/iteration/fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/accumulate_fwd.hpp
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/detail/fold.hpp
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/detail/for_each.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/detail/preprocessed/fold.hpp
+
+../libraries/boost/fusion/algorithm/iteration/detail/preprocessed/iter_fold.hpp
+
+../libraries/boost/fusion/algorithm/iteration/detail/preprocessed/reverse_fold.hpp
+
+../libraries/boost/fusion/algorithm/iteration/detail/preprocessed/reverse_iter_fold.hpp
+
+../libraries/boost/fusion/algorithm/iteration/detail/segmented_fold.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/fold_fwd.hpp
+-
+boost/fusion/support/segmented_fold_until.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/detail/segmented_for_each.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/support/void.hpp
+-
+boost/fusion/algorithm/iteration/for_each_fwd.hpp
+-
+boost/fusion/support/segmented_fold_until.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/fold.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/fold_fwd.hpp
+-
+boost/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/fusion/algorithm/iteration/detail/preprocessed/fold.hpp
+-
+boost/fusion/algorithm/iteration/detail/fold.hpp
+-
+boost/fusion/algorithm/iteration/detail/segmented_fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/fold_fwd.hpp
+
+../libraries/boost/fusion/algorithm/iteration/for_each.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/detail/for_each.hpp
+-
+boost/fusion/algorithm/iteration/detail/segmented_for_each.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/for_each_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/iter_fold.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/iter_fold_fwd.hpp
+-
+boost/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/fusion/algorithm/iteration/detail/preprocessed/iter_fold.hpp
+-
+boost/fusion/algorithm/iteration/detail/fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/iter_fold_fwd.hpp
+
+../libraries/boost/fusion/algorithm/iteration/reverse_fold.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/reverse_fold_fwd.hpp
+-
+boost/config.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/fusion/algorithm/iteration/detail/preprocessed/reverse_fold.hpp
+-
+boost/fusion/algorithm/iteration/detail/fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/reverse_fold_fwd.hpp
+
+../libraries/boost/fusion/algorithm/iteration/reverse_iter_fold.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/reverse_iter_fold_fwd.hpp
+-
+boost/config.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/fusion/algorithm/iteration/detail/preprocessed/reverse_iter_fold.hpp
+-
+boost/fusion/algorithm/iteration/detail/fold.hpp
+-
+
+../libraries/boost/fusion/algorithm/iteration/reverse_iter_fold_fwd.hpp
+
+../libraries/boost/fusion/algorithm/query.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/all.hpp
+-
+boost/fusion/algorithm/query/any.hpp
+-
+boost/fusion/algorithm/query/count.hpp
+-
+boost/fusion/algorithm/query/count_if.hpp
+-
+boost/fusion/algorithm/query/find.hpp
+-
+boost/fusion/algorithm/query/find_if.hpp
+-
+boost/fusion/algorithm/query/none.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/all.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/algorithm/query/detail/all.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/any.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/algorithm/query/detail/any.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/count.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/count_if.hpp
+-
+boost/fusion/algorithm/query/detail/count.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/count_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/detail/count_if.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/all.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/any.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/count.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+boost/mpl/or.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/count_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/find_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/or.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/segmented_find.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/fusion/algorithm/query/find_fwd.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/support/segmented_fold_until.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/detail/segmented_find_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/fusion/algorithm/query/find_if_fwd.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/support/segmented_fold_until.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/find.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/find_if_fwd.hpp
+-
+boost/fusion/algorithm/query/detail/find_if.hpp
+-
+boost/fusion/algorithm/query/detail/segmented_find.hpp
+-
+boost/fusion/iterator/key_of.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/find_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/find_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/find_if_fwd.hpp
+-
+boost/fusion/algorithm/query/detail/find_if.hpp
+-
+boost/fusion/algorithm/query/detail/segmented_find_if.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/mpl/bind.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/quote.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/find_if_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+
+../libraries/boost/fusion/algorithm/query/none.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/any.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/transformation/clear.hpp
+-
+boost/fusion/algorithm/transformation/erase.hpp
+-
+boost/fusion/algorithm/transformation/erase_key.hpp
+-
+boost/fusion/algorithm/transformation/filter.hpp
+-
+boost/fusion/algorithm/transformation/filter_if.hpp
+-
+boost/fusion/algorithm/transformation/insert.hpp
+-
+boost/fusion/algorithm/transformation/insert_range.hpp
+-
+boost/fusion/algorithm/transformation/join.hpp
+-
+boost/fusion/algorithm/transformation/pop_back.hpp
+-
+boost/fusion/algorithm/transformation/pop_front.hpp
+-
+boost/fusion/algorithm/transformation/push_back.hpp
+-
+boost/fusion/algorithm/transformation/push_front.hpp
+-
+boost/fusion/algorithm/transformation/remove.hpp
+-
+boost/fusion/algorithm/transformation/remove_if.hpp
+-
+boost/fusion/algorithm/transformation/replace.hpp
+-
+boost/fusion/algorithm/transformation/replace_if.hpp
+-
+boost/fusion/algorithm/transformation/reverse.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/algorithm/transformation/zip.hpp
+-
+boost/fusion/algorithm/transformation/flatten.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/clear.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector10.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip.hpp
+boost/fusion/algorithm/transformation/detail/preprocessed/zip10.hpp
+-
+boost/fusion/algorithm/transformation/detail/preprocessed/zip20.hpp
+-
+boost/fusion/algorithm/transformation/detail/preprocessed/zip30.hpp
+-
+boost/fusion/algorithm/transformation/detail/preprocessed/zip40.hpp
+-
+boost/fusion/algorithm/transformation/detail/preprocessed/zip50.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip10.hpp
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip20.hpp
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip30.hpp
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip40.hpp
+
+../libraries/boost/fusion/algorithm/transformation/detail/preprocessed/zip50.hpp
+
+../libraries/boost/fusion/algorithm/transformation/detail/replace.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/detail/replace_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/erase.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/erase_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/find.hpp
+-
+boost/fusion/algorithm/transformation/erase.hpp
+-
+boost/mpl/not.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/filter.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/filter_view/filter_view.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/filter_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/filter_view/filter_view.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/flatten.hpp
+boost/fusion/view/flatten_view.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/insert.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/single_view/single_view.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/insert_range.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/join.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/joint_view.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/pop_back.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/empty.hpp
+-
+boost/fusion/iterator/iterator_adapter.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/pop_front.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/push_back.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/single_view/single_view.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/push_front.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/single_view/single_view.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/remove.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/filter_view/filter_view.hpp
+-
+boost/mpl/not.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/remove_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/filter_view/filter_view.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/replace.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/transform_view/transform_view.hpp
+-
+boost/fusion/algorithm/transformation/detail/replace.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/replace_if.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/transform_view/transform_view.hpp
+-
+boost/fusion/algorithm/transformation/detail/replace_if.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/reverse.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/reverse_view/reverse_view.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/transform.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/transform_view/transform_view.hpp
+-
+
+../libraries/boost/fusion/algorithm/transformation/zip.hpp
+boost/fusion/view/zip_view.hpp
+-
+boost/fusion/adapted/mpl.hpp
+-
+boost/fusion/container/vector.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/support/detail/pp_round.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/mpl/vector.hpp
+-
+boost/mpl/transform.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/fusion/algorithm/transformation/detail/preprocessed/zip.hpp
+-
+
+../libraries/boost/fusion/container/deque/deque_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+boost/fusion/container/deque/detail/cpp03/deque_fwd.hpp
+-
+
+../libraries/boost/fusion/container/deque/detail/cpp03/deque_fwd.hpp
+boost/fusion/container/deque/detail/cpp03/limits.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque_fwd.hpp
+-
+
+../libraries/boost/fusion/container/deque/detail/cpp03/limits.hpp
+boost/fusion/container/vector/detail/cpp03/limits.hpp
+-
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque10_fwd.hpp
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque20_fwd.hpp
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque30_fwd.hpp
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque40_fwd.hpp
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque50_fwd.hpp
+
+../libraries/boost/fusion/container/deque/detail/cpp03/preprocessed/deque_fwd.hpp
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque10_fwd.hpp
+-
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque20_fwd.hpp
+-
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque30_fwd.hpp
+-
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque40_fwd.hpp
+-
+boost/fusion/container/deque/detail/cpp03/preprocessed/deque50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/generation/detail/pp_make_vector.hpp
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/container/generation/detail/preprocessed/make_vector.hpp
+-
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector.hpp
+boost/fusion/container/generation/detail/preprocessed/make_vector10.hpp
+-
+boost/fusion/container/generation/detail/preprocessed/make_vector20.hpp
+-
+boost/fusion/container/generation/detail/preprocessed/make_vector30.hpp
+-
+boost/fusion/container/generation/detail/preprocessed/make_vector40.hpp
+-
+boost/fusion/container/generation/detail/preprocessed/make_vector50.hpp
+-
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector10.hpp
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector20.hpp
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector30.hpp
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector40.hpp
+
+../libraries/boost/fusion/container/generation/detail/preprocessed/make_vector50.hpp
+
+../libraries/boost/fusion/container/generation/make_vector.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/container/generation/detail/pp_make_vector.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+utility
+-
+
+../libraries/boost/fusion/container/list/cons.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/void.hpp
+-
+boost/fusion/support/detail/enabler.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/container/list/nil.hpp
+-
+boost/fusion/container/list/cons_iterator.hpp
+-
+boost/fusion/container/list/detail/begin_impl.hpp
+-
+boost/fusion/container/list/detail/end_impl.hpp
+-
+boost/fusion/container/list/detail/at_impl.hpp
+-
+boost/fusion/container/list/detail/value_at_impl.hpp
+-
+boost/fusion/container/list/detail/empty_impl.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/fusion/container/list/cons_fwd.hpp
+
+../libraries/boost/fusion/container/list/cons_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/container/list/detail/deref_impl.hpp
+-
+boost/fusion/container/list/detail/next_impl.hpp
+-
+boost/fusion/container/list/detail/value_of_impl.hpp
+-
+boost/fusion/container/list/detail/equal_to_impl.hpp
+-
+boost/fusion/container/list/list_fwd.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/cpp03/limits.hpp
+boost/fusion/support/detail/pp_round.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/cpp03/list_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/list/detail/cpp03/limits.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/fusion/container/list/detail/cpp03/preprocessed/list_fwd.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list10_fwd.hpp
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list20_fwd.hpp
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list30_fwd.hpp
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list40_fwd.hpp
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list50_fwd.hpp
+
+../libraries/boost/fusion/container/list/detail/cpp03/preprocessed/list_fwd.hpp
+boost/fusion/container/list/detail/cpp03/preprocessed/list10_fwd.hpp
+-
+boost/fusion/container/list/detail/cpp03/preprocessed/list20_fwd.hpp
+-
+boost/fusion/container/list/detail/cpp03/preprocessed/list30_fwd.hpp
+-
+boost/fusion/container/list/detail/cpp03/preprocessed/list40_fwd.hpp
+-
+boost/fusion/container/list/detail/cpp03/preprocessed/list50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/empty_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/fusion/container/list/nil.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/equal_to_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/and.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/add_const.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/reverse_cons.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/container/list/detail/value_of_impl.hpp
+
+../libraries/boost/fusion/container/list/list_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+boost/fusion/container/list/detail/cpp03/list_fwd.hpp
+-
+
+../libraries/boost/fusion/container/list/nil.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/container/map/detail/cpp03/limits.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/limits.hpp
+-
+
+../libraries/boost/fusion/container/map/detail/cpp03/map_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/map/detail/cpp03/limits.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/fusion/container/map/detail/cpp03/preprocessed/map_fwd.hpp
+-
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map10_fwd.hpp
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map20_fwd.hpp
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map30_fwd.hpp
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map40_fwd.hpp
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map50_fwd.hpp
+
+../libraries/boost/fusion/container/map/detail/cpp03/preprocessed/map_fwd.hpp
+boost/fusion/container/map/detail/cpp03/preprocessed/map10_fwd.hpp
+-
+boost/fusion/container/map/detail/cpp03/preprocessed/map20_fwd.hpp
+-
+boost/fusion/container/map/detail/cpp03/preprocessed/map30_fwd.hpp
+-
+boost/fusion/container/map/detail/cpp03/preprocessed/map40_fwd.hpp
+-
+boost/fusion/container/map/detail/cpp03/preprocessed/map50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/map/map_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+boost/fusion/container/map/detail/cpp03/map_fwd.hpp
+-
+
+../libraries/boost/fusion/container/set/detail/cpp03/limits.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/limits.hpp
+-
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set10_fwd.hpp
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set20_fwd.hpp
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set30_fwd.hpp
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set40_fwd.hpp
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set50_fwd.hpp
+
+../libraries/boost/fusion/container/set/detail/cpp03/preprocessed/set_fwd.hpp
+boost/fusion/container/set/detail/cpp03/preprocessed/set10_fwd.hpp
+-
+boost/fusion/container/set/detail/cpp03/preprocessed/set20_fwd.hpp
+-
+boost/fusion/container/set/detail/cpp03/preprocessed/set30_fwd.hpp
+-
+boost/fusion/container/set/detail/cpp03/preprocessed/set40_fwd.hpp
+-
+boost/fusion/container/set/detail/cpp03/preprocessed/set50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/set/detail/cpp03/set_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/set/detail/cpp03/limits.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/fusion/container/set/detail/cpp03/preprocessed/set_fwd.hpp
+-
+
+../libraries/boost/fusion/container/set/set_fwd.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/set/detail/cpp03/set_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+
+../libraries/boost/fusion/container/vector/convert.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/as_vector.hpp
+-
+boost/fusion/container/vector/detail/convert_impl.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/advance_impl.hpp
+
+../libraries/boost/fusion/container/vector/detail/as_vector.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/as_vector.hpp
+-
+boost/fusion/support/detail/index_sequence.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+cstddef
+-
+
+../libraries/boost/fusion/container/vector/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_iterator.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/config.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/convert_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/as_vector.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/as_vector.hpp
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/limits.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/pp_round.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector.hpp
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector10.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector20.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector30.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector40.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector50.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector10.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector20.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector30.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector40.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/as_vector50.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector.hpp
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector10.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector20.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector30.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector40.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector50.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector10.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector10_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector20.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector20_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector30.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector30_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector40.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector40_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector50.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector50_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser.hpp
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser10.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser20.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser30.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser40.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser50.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser10.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser20.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser30.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser40.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser50.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vector_fwd.hpp
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector10_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector20_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector30_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector40_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vvector50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector10.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector10_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector20.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector20_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector30.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector30_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector40.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector40_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector50.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/preprocessed/vvector50_fwd.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/at.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector.hpp
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/void.hpp
+-
+boost/fusion/support/detail/enabler.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector_n_chooser.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/remove_cv_ref.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector_forward_ctor.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector10.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector10_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/vector/vector10.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector10.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector10_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector10_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector20.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector20_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/vector/vector20.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector20.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector20_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector20_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector30.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector30_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/vector/vector30.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector30.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector30_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector30_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector40.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector40_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/vector/vector40.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector40.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector40_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector40_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector50.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector50_fwd.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/vector/vector50.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector50.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector50_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector50_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector_forward_ctor.hpp
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/limits.hpp
+-
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector10.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector20.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector30.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector40.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector50.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_fwd.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/cpp03/vector_n_chooser.hpp
+boost/fusion/container/vector/detail/cpp03/limits.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector10.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector20.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector30.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector40.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector50.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/facilities/intercept.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_trailing_params.hpp
+-
+boost/fusion/container/vector/detail/cpp03/preprocessed/vector_chooser.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/distance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/minus.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_iterator.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/equal_to_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/and.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_iterator.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/prior_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_iterator.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/value_at_impl.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/container/vector/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+
+../libraries/boost/fusion/container/vector/vector.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/detail/and.hpp
+-
+boost/fusion/support/detail/index_sequence.hpp
+-
+boost/fusion/container/vector/detail/at_impl.hpp
+-
+boost/fusion/container/vector/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/detail/begin_impl.hpp
+-
+boost/fusion/container/vector/detail/end_impl.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/mpl/int.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+cstddef
+-
+utility
+-
+
+../libraries/boost/fusion/container/vector/vector10.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector10.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/fusion/container/vector/vector.hpp
+-
+
+../libraries/boost/fusion/container/vector/vector_fwd.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/detail/config.hpp
+-
+boost/fusion/container/vector/detail/cpp03/vector_fwd.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/fusion/container/vector/vector_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/container/vector/detail/deref_impl.hpp
+-
+boost/fusion/container/vector/detail/value_of_impl.hpp
+-
+boost/fusion/container/vector/detail/next_impl.hpp
+-
+boost/fusion/container/vector/detail/prior_impl.hpp
+-
+boost/fusion/container/vector/detail/equal_to_impl.hpp
+-
+boost/fusion/container/vector/detail/distance_impl.hpp
+-
+boost/fusion/container/vector/detail/advance_impl.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/fusion/functional/adapter/detail/access.hpp
+
+../libraries/boost/fusion/functional/adapter/fused.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/config.hpp
+-
+boost/fusion/functional/adapter/detail/access.hpp
+-
+boost/fusion/functional/invocation/invoke.hpp
+-
+
+../libraries/boost/fusion/functional/generation/detail/gen_make_adapter.hpp
+boost/preprocessor/cat.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+
+../libraries/boost/fusion/functional/generation/make_fused.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/functional/adapter/fused.hpp
+-
+boost/fusion/functional/generation/detail/gen_make_adapter.hpp
+-
+
+../libraries/boost/fusion/functional/invocation/detail/that_ptr.hpp
+boost/fusion/support/config.hpp
+-
+boost/get_pointer.hpp
+-
+boost/utility/addressof.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/fusion/functional/invocation/invoke.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_shifted.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_shifted_params.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/front.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/function_types/is_function.hpp
+-
+boost/function_types/is_callable_builtin.hpp
+-
+boost/function_types/is_member_pointer.hpp
+-
+boost/function_types/is_member_function_pointer.hpp
+-
+boost/function_types/result_type.hpp
+-
+boost/function_types/parameter_types.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/sequence/intrinsic/at.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/intrinsic/front.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/functional/invocation/limits.hpp
+-
+boost/fusion/functional/invocation/detail/that_ptr.hpp
+-
+
+../libraries/boost/fusion/functional/invocation/limits.hpp
+
+../libraries/boost/fusion/include/all.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/query/all.hpp
+-
+
+../libraries/boost/fusion/include/equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/sequence/comparison/equal_to.hpp
+-
+
+../libraries/boost/fusion/include/for_each.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/algorithm/iteration/for_each.hpp
+-
+
+../libraries/boost/fusion/include/front.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/front.hpp
+-
+
+../libraries/boost/fusion/include/is_sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+
+../libraries/boost/fusion/include/make_fused.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/functional/generation/make_fused.hpp
+-
+
+../libraries/boost/fusion/include/vector.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector.hpp
+-
+
+../libraries/boost/fusion/include/zip_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view.hpp
+-
+
+../libraries/boost/fusion/iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/iterator_facade.hpp
+-
+boost/fusion/iterator/iterator_adapter.hpp
+-
+boost/fusion/iterator/segmented_iterator.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/mpl.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/iterator/advance.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/advance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/deref.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/deref_data.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/adapt_deref_traits.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/adapt_value_traits.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/advance.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/distance.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/segment_sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/segmented_equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/segmented_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/iterator/iterator_facade.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/deref_data.hpp
+-
+boost/fusion/iterator/key_of.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/value_of_data.hpp
+-
+boost/fusion/iterator/detail/segmented_equal_to.hpp
+-
+
+../libraries/boost/fusion/iterator/detail/segmented_next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+
+../libraries/boost/fusion/iterator/distance.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/distance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/fusion/support/is_iterator.hpp
+-
+boost/mpl/and.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/iterator/iterator_adapter.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/iterator_facade.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/fusion/iterator/iterator_facade.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/iterator/detail/advance.hpp
+-
+boost/fusion/iterator/detail/distance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/iterator/key_of.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/mpl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/iterator/mpl/fusion_iterator.hpp
+-
+
+../libraries/boost/fusion/iterator/mpl/convert_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/is_iterator.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/iterator/mpl/fusion_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/advance_fwd.hpp
+-
+boost/mpl/distance_fwd.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+
+../libraries/boost/fusion/iterator/next.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/prior.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/segmented_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/segmented_iterator.hpp
+-
+boost/fusion/iterator/detail/segmented_next_impl.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/container/list/cons.hpp
+-
+
+../libraries/boost/fusion/iterator/value_of.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/iterator/value_of_data.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/mpl.hpp
+boost/fusion/iterator/mpl.hpp
+-
+boost/fusion/adapted/mpl.hpp
+-
+boost/fusion/mpl/at.hpp
+-
+boost/fusion/mpl/back.hpp
+-
+boost/fusion/mpl/begin.hpp
+-
+boost/fusion/mpl/clear.hpp
+-
+boost/fusion/mpl/empty.hpp
+-
+boost/fusion/mpl/end.hpp
+-
+boost/fusion/mpl/erase.hpp
+-
+boost/fusion/mpl/erase_key.hpp
+-
+boost/fusion/mpl/front.hpp
+-
+boost/fusion/mpl/has_key.hpp
+-
+boost/fusion/mpl/insert.hpp
+-
+boost/fusion/mpl/insert_range.hpp
+-
+boost/fusion/mpl/pop_back.hpp
+-
+boost/fusion/mpl/pop_front.hpp
+-
+boost/fusion/mpl/push_back.hpp
+-
+boost/fusion/mpl/push_front.hpp
+-
+boost/fusion/mpl/size.hpp
+-
+
+../libraries/boost/fusion/mpl/at.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/at.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+
+../libraries/boost/fusion/mpl/back.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/back.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/mpl/begin.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/adapted/mpl/detail/begin_impl.hpp
+-
+boost/fusion/iterator/mpl/fusion_iterator.hpp
+-
+
+../libraries/boost/fusion/mpl/clear.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/clear.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/mpl/detail/clear.hpp
+-
+
+../libraries/boost/fusion/mpl/detail/clear.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/vector_fwd.hpp
+-
+boost/fusion/container/list/list_fwd.hpp
+-
+boost/fusion/container/map/map_fwd.hpp
+-
+boost/fusion/container/set/set_fwd.hpp
+-
+boost/fusion/container/deque/deque_fwd.hpp
+-
+
+../libraries/boost/fusion/mpl/empty.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/empty.hpp
+-
+boost/fusion/sequence/intrinsic/empty.hpp
+-
+
+../libraries/boost/fusion/mpl/end.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/adapted/mpl/detail/end_impl.hpp
+-
+boost/fusion/iterator/mpl/fusion_iterator.hpp
+-
+
+../libraries/boost/fusion/mpl/erase.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/erase.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/erase.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/erase_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/erase_key.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/erase_key.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/front.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/front.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/mpl/has_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/has_key.hpp
+-
+boost/fusion/sequence/intrinsic/has_key.hpp
+-
+
+../libraries/boost/fusion/mpl/insert.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/insert.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/insert.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/insert_range.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/insert_range.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/insert_range.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/pop_back.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/pop_back.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/pop_back.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/pop_front.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/pop_front.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/pop_front.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/push_back.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/push_back.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/push_back.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/push_front.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/algorithm/transformation/push_front.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/mpl/size.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/size.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+
+../libraries/boost/fusion/sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/sequence_facade.hpp
+-
+boost/fusion/sequence/comparison.hpp
+-
+boost/fusion/sequence/intrinsic.hpp
+-
+boost/fusion/sequence/io.hpp
+-
+boost/fusion/sequence/convert.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/comparison/equal_to.hpp
+-
+boost/fusion/sequence/comparison/greater.hpp
+-
+boost/fusion/sequence/comparison/greater_equal.hpp
+-
+boost/fusion/sequence/comparison/less.hpp
+-
+boost/fusion/sequence/comparison/less_equal.hpp
+-
+boost/fusion/sequence/comparison/not_equal_to.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/greater.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/greater_equal.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/less.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/less_equal.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/detail/not_equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/support/as_const.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/enable_comparison.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/detail/equal_to.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/greater.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+boost/fusion/sequence/comparison/detail/greater.hpp
+-
+boost/fusion/sequence/comparison/less.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/greater_equal.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+boost/fusion/sequence/comparison/detail/greater_equal.hpp
+-
+boost/fusion/sequence/comparison/less.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/less.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/detail/less.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/less_equal.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+boost/fusion/sequence/comparison/detail/less_equal.hpp
+-
+boost/fusion/sequence/comparison/less.hpp
+-
+
+../libraries/boost/fusion/sequence/comparison/not_equal_to.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/comparison/enable_comparison.hpp
+-
+boost/fusion/sequence/comparison/detail/not_equal_to.hpp
+-
+boost/fusion/sequence/comparison/equal_to.hpp
+-
+
+../libraries/boost/fusion/sequence/convert.hpp
+boost/fusion/support/config.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/is_const.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/at.hpp
+-
+boost/fusion/sequence/intrinsic/back.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/empty.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/front.hpp
+-
+boost/fusion/sequence/intrinsic/has_key.hpp
+-
+boost/fusion/sequence/intrinsic/segments.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+boost/fusion/sequence/intrinsic/at_key.hpp
+-
+boost/fusion/sequence/intrinsic/value_at_key.hpp
+-
+boost/fusion/sequence/intrinsic/swap.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/at.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/less.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/at_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/has_key.hpp
+-
+boost/fusion/algorithm/query/find.hpp
+-
+boost/fusion/iterator/deref_data.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/or.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/back.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/begin.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/mpl/if.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_begin.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/detail/segmented_begin.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_begin_impl.hpp
+-
+boost/fusion/iterator/segmented_iterator.hpp
+-
+boost/fusion/view/iterator_range.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/empty.hpp
+-
+boost/fusion/container/list/cons.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/detail/segmented_begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_end_impl.hpp
+-
+boost/fusion/support/detail/segmented_fold_until_impl.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/detail/segmented_end.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_end_impl.hpp
+-
+boost/fusion/iterator/segmented_iterator.hpp
+-
+boost/fusion/container/list/cons.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/detail/segmented_end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/detail/segmented_size.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/mpl/fold.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/size_t.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/mpl/begin.hpp
+-
+boost/fusion/mpl/end.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/empty.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/end.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/mpl/if.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_end.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/front.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/has_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/algorithm/query/find.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/segments.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/size.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/int.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/sequence/intrinsic/detail/segmented_size.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/swap.hpp
+boost/fusion/support/config.hpp
+-
+algorithm
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/fusion/view/zip_view.hpp
+-
+boost/fusion/algorithm/iteration/for_each.hpp
+-
+boost/fusion/sequence/intrinsic/front.hpp
+-
+boost/fusion/sequence/intrinsic/back.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/mpl/and.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/value_at.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/less.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic/value_at_key.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/empty_base.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/or.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/has_key.hpp
+-
+boost/fusion/iterator/value_of_data.hpp
+-
+boost/fusion/algorithm/query/find.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+
+../libraries/boost/fusion/sequence/intrinsic_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+
+../libraries/boost/fusion/sequence/io.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/io/in.hpp
+-
+boost/fusion/sequence/io/out.hpp
+-
+
+../libraries/boost/fusion/sequence/io/detail/in.hpp
+boost/fusion/support/config.hpp
+-
+istream
+-
+boost/fusion/sequence/io/detail/manip.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/sequence/io/detail/manip.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+string
+-
+vector
+-
+cctype
+-
+
+../libraries/boost/fusion/sequence/io/detail/out.hpp
+boost/fusion/support/config.hpp
+-
+ostream
+-
+boost/fusion/sequence/io/detail/manip.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/sequence/io/in.hpp
+boost/fusion/support/config.hpp
+-
+istream
+-
+boost/fusion/sequence/io/detail/in.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+
+../libraries/boost/fusion/sequence/io/out.hpp
+boost/fusion/support/config.hpp
+-
+ostream
+-
+boost/fusion/sequence/io/detail/out.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/mpl/or.hpp
+-
+
+../libraries/boost/fusion/sequence/sequence_facade.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/support/as_const.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/support/category_of.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+
+../libraries/boost/fusion/support/config.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+utility
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/support/detail/access.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+
+../libraries/boost/fusion/support/detail/and.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/fusion/support/detail/as_fusion_element.hpp
+boost/fusion/support/config.hpp
+-
+boost/ref.hpp
+-
+functional
+-
+
+../libraries/boost/fusion/support/detail/enabler.hpp
+boost/config.hpp
+-
+
+../libraries/boost/fusion/support/detail/index_sequence.hpp
+boost/fusion/support/config.hpp
+-
+cstddef
+-
+utility
+-
+
+../libraries/boost/fusion/support/detail/is_mpl_sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/is_native_fusion_sequence.hpp
+-
+boost/mpl/is_sequence.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/fusion/support/detail/is_native_fusion_sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/mpl/and.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/fusion/support/detail/mpl_iterator_category.hpp
+
+../libraries/boost/fusion/support/detail/pp_round.hpp
+boost/fusion/support/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/comparison/less.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+
+../libraries/boost/fusion/support/detail/segmented_fold_until_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/utility/result_of.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/support/void.hpp
+-
+boost/fusion/container/list/cons_fwd.hpp
+-
+boost/fusion/sequence/intrinsic_fwd.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/sequence/intrinsic/segments.hpp
+-
+
+../libraries/boost/fusion/support/is_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+
+../libraries/boost/fusion/support/is_segmented.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/support/is_sequence.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/support/detail/is_native_fusion_sequence.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/is_sequence.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/fusion/support/is_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+
+../libraries/boost/fusion/support/iterator_base.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/support/segmented_fold_until.hpp
+boost/fusion/support/config.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/support/detail/segmented_fold_until_impl.hpp
+-
+
+../libraries/boost/fusion/support/sequence_base.hpp
+boost/config.hpp
+-
+boost/fusion/support/config.hpp
+-
+boost/mpl/begin_end_fwd.hpp
+-
+
+../libraries/boost/fusion/support/tag_of.hpp
+boost/fusion/support/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/fusion/support/tag_of_fwd.hpp
+-
+boost/fusion/support/detail/is_mpl_sequence.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/if.hpp
+-
+boost/config/no_tr1/utility.hpp
+-
+
+../libraries/boost/fusion/support/tag_of_fwd.hpp
+
+../libraries/boost/fusion/support/unused.hpp
+boost/fusion/support/config.hpp
+-
+iosfwd
+-
+
+../libraries/boost/fusion/support/void.hpp
+
+../libraries/boost/fusion/view/detail/strictest_traversal.hpp
+boost/fusion/support/config.hpp
+-
+boost/config.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/if.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/mpl.hpp
+-
+boost/fusion/algorithm/iteration/fold.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/begin_impl.hpp
+
+../libraries/boost/fusion/view/filter_view/detail/deref_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref_data.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/adapt_deref_traits.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/end_impl.hpp
+
+../libraries/boost/fusion/view/filter_view/detail/equal_to_impl.hpp
+
+../libraries/boost/fusion/view/filter_view/detail/key_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/key_of.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/size_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/value_of_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of_data.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/adapt_value_traits.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/filter_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/is_view.hpp
+-
+boost/fusion/view/filter_view/filter_view_iterator.hpp
+-
+boost/fusion/view/filter_view/detail/begin_impl.hpp
+-
+boost/fusion/view/filter_view/detail/end_impl.hpp
+-
+boost/fusion/view/filter_view/detail/size_impl.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/inherit.hpp
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/view/filter_view/filter_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/algorithm/query/detail/find_if.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/quote.hpp
+-
+boost/mpl/bind.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/fusion/view/filter_view/detail/deref_impl.hpp
+-
+boost/fusion/view/filter_view/detail/next_impl.hpp
+-
+boost/fusion/view/filter_view/detail/value_of_impl.hpp
+-
+boost/fusion/view/filter_view/detail/equal_to_impl.hpp
+-
+boost/fusion/view/filter_view/detail/deref_data_impl.hpp
+-
+boost/fusion/view/filter_view/detail/value_of_data_impl.hpp
+-
+boost/fusion/view/filter_view/detail/key_of_impl.hpp
+-
+
+../libraries/boost/fusion/view/flatten_view.hpp
+boost/fusion/view/flatten_view/flatten_view.hpp
+-
+boost/fusion/view/flatten_view/flatten_view_iterator.hpp
+-
+
+../libraries/boost/fusion/view/flatten_view/flatten_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/single_view.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/is_view.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/view/flatten_view/flatten_view_iterator.hpp
+-
+
+../libraries/boost/fusion/view/flatten_view/flatten_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/container/list/cons.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/fusion/include/equal_to.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/iterator_range/iterator_range.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/is_segmented_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/segmented_iterator_range.hpp
+boost/fusion/support/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/support/tag_of.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/sequence/intrinsic/segments.hpp
+-
+boost/fusion/algorithm/transformation/push_back.hpp
+-
+boost/fusion/algorithm/transformation/push_front.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/container/list/detail/reverse_cons.hpp
+-
+boost/fusion/iterator/detail/segment_sequence.hpp
+-
+boost/fusion/support/is_sequence.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/segments_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/fusion/sequence/intrinsic/segments.hpp
+-
+boost/fusion/support/is_segmented.hpp
+-
+boost/fusion/view/iterator_range/detail/segmented_iterator_range.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/size_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+
+../libraries/boost/fusion/view/iterator_range/iterator_range.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/view/iterator_range/detail/begin_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/end_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/at_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/size_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/value_at_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/is_segmented_impl.hpp
+-
+boost/fusion/view/iterator_range/detail/segments_impl.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/joint_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/joint_view/joint_view.hpp
+-
+boost/fusion/view/joint_view/joint_view_iterator.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/deref_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref_data.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/adapt_deref_traits.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/key_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/key_of.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/mpl/if.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/value_of_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of_data.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/detail/adapt_value_traits.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/joint_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/joint_view/joint_view_fwd.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/is_view.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/view/joint_view/joint_view_iterator.hpp
+-
+boost/fusion/view/joint_view/detail/begin_impl.hpp
+-
+boost/fusion/view/joint_view/detail/end_impl.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/inherit.hpp
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/view/joint_view/joint_view_fwd.hpp
+
+../libraries/boost/fusion/view/joint_view/joint_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/fusion/view/joint_view/detail/deref_impl.hpp
+-
+boost/fusion/view/joint_view/detail/next_impl.hpp
+-
+boost/fusion/view/joint_view/detail/value_of_impl.hpp
+-
+boost/fusion/view/joint_view/detail/deref_data_impl.hpp
+-
+boost/fusion/view/joint_view/detail/value_of_data_impl.hpp
+-
+boost/fusion/view/joint_view/detail/key_of_impl.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/advance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/mpl/negate.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/at.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/begin_impl.hpp
+
+../libraries/boost/fusion/view/reverse_view/detail/deref_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref_data.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/distance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/end_impl.hpp
+
+../libraries/boost/fusion/view/reverse_view/detail/key_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/key_of.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/prior_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/value_of_data_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of_data.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/reverse_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/is_view.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/view/reverse_view/reverse_view_iterator.hpp
+-
+boost/fusion/view/reverse_view/detail/begin_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/end_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/at_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/value_at_impl.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/static_assert.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/inherit.hpp
+-
+boost/mpl/identity.hpp
+-
+
+../libraries/boost/fusion/view/reverse_view/reverse_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/fusion/view/reverse_view/detail/deref_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/next_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/prior_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/advance_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/distance_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/value_of_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/deref_data_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/value_of_data_impl.hpp
+-
+boost/fusion/view/reverse_view/detail/key_of_impl.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/advance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/plus.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/equal_to.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/equal_to.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/distance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/minus.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/equal_to_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/add_const.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/next.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/prior_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/prior.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/size_impl.hpp
+
+../libraries/boost/fusion/view/single_view/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+
+../libraries/boost/fusion/view/single_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/equal_to.hpp
+-
+
+../libraries/boost/fusion/view/single_view/single_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/detail/as_fusion_element.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/view/single_view/single_view_iterator.hpp
+-
+boost/fusion/view/single_view/detail/at_impl.hpp
+-
+boost/fusion/view/single_view/detail/begin_impl.hpp
+-
+boost/fusion/view/single_view/detail/end_impl.hpp
+-
+boost/fusion/view/single_view/detail/size_impl.hpp
+-
+boost/fusion/view/single_view/detail/value_at_impl.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/int.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/single_view/single_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/view/single_view/detail/deref_impl.hpp
+-
+boost/fusion/view/single_view/detail/next_impl.hpp
+-
+boost/fusion/view/single_view/detail/prior_impl.hpp
+-
+boost/fusion/view/single_view/detail/advance_impl.hpp
+-
+boost/fusion/view/single_view/detail/distance_impl.hpp
+-
+boost/fusion/view/single_view/detail/equal_to_impl.hpp
+-
+boost/fusion/view/single_view/detail/value_of_impl.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/advance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/at.hpp
+-
+boost/utility/result_of.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/transform_view/transform_view_fwd.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/utility/result_of.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/distance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/transform_view/transform_view_fwd.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/equal_to_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/prior_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+boost/utility/result_of.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/utility/result_of.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/transform_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/fusion/support/detail/access.hpp
+-
+boost/fusion/support/is_view.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/view/transform_view/transform_view_iterator.hpp
+-
+boost/fusion/view/transform_view/transform_view_fwd.hpp
+-
+boost/fusion/view/transform_view/detail/begin_impl.hpp
+-
+boost/fusion/view/transform_view/detail/end_impl.hpp
+-
+boost/fusion/view/transform_view/detail/at_impl.hpp
+-
+boost/fusion/view/transform_view/detail/value_at_impl.hpp
+-
+boost/fusion/view/detail/strictest_traversal.hpp
+-
+boost/fusion/container/vector/vector10.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/fusion/view/transform_view/transform_view_fwd.hpp
+
+../libraries/boost/fusion/view/transform_view/transform_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/iterator/mpl/convert_iterator.hpp
+-
+boost/fusion/adapted/mpl/mpl_iterator.hpp
+-
+boost/fusion/view/transform_view/detail/deref_impl.hpp
+-
+boost/fusion/view/transform_view/detail/next_impl.hpp
+-
+boost/fusion/view/transform_view/detail/prior_impl.hpp
+-
+boost/fusion/view/transform_view/detail/value_of_impl.hpp
+-
+boost/fusion/view/transform_view/detail/advance_impl.hpp
+-
+boost/fusion/view/transform_view/detail/distance_impl.hpp
+-
+boost/fusion/view/transform_view/detail/equal_to_impl.hpp
+-
+
+../libraries/boost/fusion/view/zip_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/advance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector.hpp
+-
+boost/fusion/sequence/intrinsic/at.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/begin_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/fusion/support/unused.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/deref_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector.hpp
+-
+boost/fusion/iterator/deref.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/distance_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/fusion/iterator/distance.hpp
+-
+boost/fusion/support/category_of.hpp
+-
+boost/fusion/algorithm/query/find_if.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/end_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/begin.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/sequence/intrinsic/front.hpp
+-
+boost/fusion/iterator/advance.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/min.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/equal_to_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/mpl.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/transform_view.hpp
+-
+boost/mpl/zip_view.hpp
+-
+boost/mpl/vector.hpp
+-
+boost/mpl/unpack_args.hpp
+-
+boost/mpl/find_if.hpp
+-
+boost/mpl/end.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/next_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/iterator/next.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/prior_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/iterator/prior.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/size_impl.hpp
+
+../libraries/boost/fusion/view/zip_view/detail/value_at_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/sequence/intrinsic/value_at.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/detail/value_of_impl.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/algorithm/transformation/transform.hpp
+-
+boost/fusion/iterator/value_of.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/zip_view.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/support/sequence_base.hpp
+-
+boost/fusion/support/unused.hpp
+-
+boost/fusion/iterator/equal_to.hpp
+-
+boost/fusion/view/detail/strictest_traversal.hpp
+-
+boost/fusion/view/zip_view/detail/begin_impl.hpp
+-
+boost/fusion/view/zip_view/detail/end_impl.hpp
+-
+boost/fusion/view/zip_view/detail/size_impl.hpp
+-
+boost/fusion/view/zip_view/detail/at_impl.hpp
+-
+boost/fusion/view/zip_view/detail/value_at_impl.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+boost/fusion/algorithm/query/find_if.hpp
+-
+boost/fusion/sequence/intrinsic/end.hpp
+-
+boost/fusion/sequence/intrinsic/size.hpp
+-
+boost/fusion/mpl.hpp
+-
+boost/fusion/algorithm/transformation/remove.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/transform_view.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/find_if.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/zip_view_iterator.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+-
+boost/fusion/support/iterator_base.hpp
+-
+boost/fusion/view/zip_view/detail/deref_impl.hpp
+-
+boost/fusion/view/zip_view/detail/next_impl.hpp
+-
+boost/fusion/view/zip_view/detail/prior_impl.hpp
+-
+boost/fusion/view/zip_view/detail/advance_impl.hpp
+-
+boost/fusion/view/zip_view/detail/distance_impl.hpp
+-
+boost/fusion/view/zip_view/detail/value_of_impl.hpp
+-
+boost/fusion/view/zip_view/detail/equal_to_impl.hpp
+-
+boost/fusion/container/vector/convert.hpp
+-
+
+../libraries/boost/fusion/view/zip_view/zip_view_iterator_fwd.hpp
+boost/fusion/support/config.hpp
+-
+boost/fusion/view/detail/strictest_traversal.hpp
+-
+
+../libraries/boost/get_pointer.hpp
+boost/config.hpp
+-
+boost/config/no_tr1/memory.hpp
+-
+
+../libraries/boost/integer.hpp
+boost/integer_fwd.hpp
+-
+boost/integer_traits.hpp
+-
+boost/limits.hpp
+-
+boost/cstdint.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/integer/common_factor_ct.hpp
+boost/integer_fwd.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/integer/static_log2.hpp
+boost/config.hpp
+-
+boost/integer_fwd.hpp
+-
+
+../libraries/boost/integer_fwd.hpp
+climits
+-
+cstddef
+-
+boost/config.hpp
+-
+boost/limits.hpp
+-
+boost/cstdint.hpp
+-
+
+../libraries/boost/integer_traits.hpp
+boost/config.hpp
+-
+boost/limits.hpp
+-
+limits.h
+-
+wchar.h
+-
+
+../libraries/boost/is_placeholder.hpp
+
+../libraries/boost/iterator/advance.hpp
+boost/config.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+
+../libraries/boost/iterator/detail/config_def.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/iterator/detail/config_undef.hpp
+
+../libraries/boost/iterator/detail/enable_if.hpp
+boost/detail/workaround.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/detail/facade_iterator_category.hpp
+boost/core/use_default.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/detail/indirect_traits.hpp
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/distance.hpp
+boost/config.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+
+../libraries/boost/iterator/interoperable.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/or.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/iterator_adaptor.hpp
+boost/static_assert.hpp
+-
+boost/core/use_default.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+boost/iterator/iterator_facade.hpp
+-
+boost/iterator/detail/enable_if.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/or.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/iterator_categories.hpp
+boost/config.hpp
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/static_assert.hpp
+-
+iterator
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/iterator_concepts.hpp
+boost/concept_check.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/or.hpp
+-
+boost/static_assert.hpp
+-
+boost/limits.hpp
+-
+boost/config.hpp
+-
+algorithm
+-
+iterator
+-
+boost/concept/detail/concept_def.hpp
+-
+boost/concept/detail/concept_undef.hpp
+-
+
+../libraries/boost/iterator/iterator_facade.hpp
+boost/config.hpp
+-
+boost/iterator/interoperable.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+boost/iterator/iterator_categories.hpp
+-
+boost/iterator/detail/facade_iterator_category.hpp
+-
+boost/iterator/detail/enable_if.hpp
+-
+boost/static_assert.hpp
+-
+boost/core/addressof.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_pointer.hpp
+-
+boost/type_traits/add_lvalue_reference.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/always.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/identity.hpp
+-
+cstddef
+-
+boost/iterator/detail/config_def.hpp
+-
+boost/iterator/detail/config_undef.hpp
+-
+
+../libraries/boost/iterator/iterator_traits.hpp
+boost/detail/workaround.hpp
+-
+iterator
+-
+
+../libraries/boost/iterator/reverse_iterator.hpp
+boost/iterator/iterator_adaptor.hpp
+-
+
+../libraries/boost/lexical_cast.hpp
+boost/config.hpp
+-
+boost/range/iterator_range_core.hpp
+-
+boost/lexical_cast/bad_lexical_cast.hpp
+-
+boost/lexical_cast/try_lexical_convert.hpp
+-
+
+../libraries/boost/lexical_cast/bad_lexical_cast.hpp
+boost/config.hpp
+-
+exception
+-
+typeinfo
+-
+boost/throw_exception.hpp
+-
+
+../libraries/boost/lexical_cast/detail/converter_lexical.hpp
+boost/config.hpp
+-
+cstddef
+-
+string
+-
+boost/limits.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_float.hpp
+-
+boost/type_traits/has_left_shift.hpp
+-
+boost/type_traits/has_right_shift.hpp
+-
+boost/static_assert.hpp
+-
+boost/detail/lcast_precision.hpp
+-
+boost/lexical_cast/detail/widest_char.hpp
+-
+boost/lexical_cast/detail/is_character.hpp
+-
+array
+-
+boost/array.hpp
+-
+boost/range/iterator_range_core.hpp
+-
+boost/container/container_fwd.hpp
+-
+boost/lexical_cast/detail/converter_lexical_streams.hpp
+-
+
+../libraries/boost/lexical_cast/detail/converter_lexical_streams.hpp
+boost/config.hpp
+-
+cstddef
+-
+string
+-
+cstring
+-
+cstdio
+-
+boost/limits.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/static_assert.hpp
+-
+boost/detail/lcast_precision.hpp
+-
+boost/detail/workaround.hpp
+-
+locale
+-
+strstream
+-
+sstream
+-
+boost/lexical_cast/detail/lcast_char_constants.hpp
+-
+boost/lexical_cast/detail/lcast_unsigned_converters.hpp
+-
+boost/lexical_cast/detail/inf_nan.hpp
+-
+istream
+-
+array
+-
+boost/array.hpp
+-
+boost/type_traits/make_unsigned.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_float.hpp
+-
+boost/range/iterator_range_core.hpp
+-
+boost/container/container_fwd.hpp
+-
+boost/integer.hpp
+-
+boost/detail/basic_pointerbuf.hpp
+-
+boost/noncopyable.hpp
+-
+cwchar
+-
+
+../libraries/boost/lexical_cast/detail/converter_numeric.hpp
+boost/config.hpp
+-
+boost/limits.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/make_unsigned.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/is_float.hpp
+-
+boost/numeric/conversion/cast.hpp
+-
+
+../libraries/boost/lexical_cast/detail/inf_nan.hpp
+boost/config.hpp
+-
+boost/limits.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/core/cmath.hpp
+-
+cstddef
+-
+cstring
+-
+boost/lexical_cast/detail/lcast_char_constants.hpp
+-
+
+../libraries/boost/lexical_cast/detail/is_character.hpp
+boost/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/lexical_cast/detail/lcast_char_constants.hpp
+boost/config.hpp
+-
+
+../libraries/boost/lexical_cast/detail/lcast_unsigned_converters.hpp
+boost/config.hpp
+-
+climits
+-
+cstddef
+-
+string
+-
+cstring
+-
+cstdio
+-
+boost/limits.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/static_assert.hpp
+-
+boost/detail/workaround.hpp
+-
+locale
+-
+boost/lexical_cast/detail/lcast_char_constants.hpp
+-
+boost/type_traits/make_unsigned.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/noncopyable.hpp
+-
+
+../libraries/boost/lexical_cast/detail/widest_char.hpp
+boost/config.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/lexical_cast/try_lexical_convert.hpp
+boost/config.hpp
+-
+string
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/lexical_cast/detail/is_character.hpp
+-
+boost/lexical_cast/detail/converter_numeric.hpp
+-
+boost/lexical_cast/detail/converter_lexical.hpp
+-
+boost/range/iterator_range_core.hpp
+-
+boost/container/container_fwd.hpp
+-
+
+../libraries/boost/limits.hpp
+boost/config.hpp
+-
+limits
+-
+climits
+-
+
+../libraries/boost/math/constants/calculate_constants.hpp
+boost/static_assert.hpp
+-
+type_traits
+-
+
+../libraries/boost/math/constants/constants.hpp
+boost/math/tools/config.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+boost/math/policies/policy.hpp
+-
+boost/math/tools/precision.hpp
+-
+boost/math/tools/convert_from_string.hpp
+-
+utility
+-
+type_traits
+-
+boost/math/constants/calculate_constants.hpp
+-
+
+../libraries/boost/math/policies/error_handling.hpp
+stdexcept
+-
+iomanip
+-
+string
+-
+cstring
+-
+typeinfo
+-
+cerrno
+-
+boost/config/no_tr1/complex.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+stdexcept
+-
+boost/math/tools/config.hpp
+-
+boost/math/policies/policy.hpp
+-
+boost/math/tools/precision.hpp
+-
+boost/throw_exception.hpp
+-
+boost/cstdint.hpp
+-
+sstream
+-
+
+../libraries/boost/math/policies/policy.hpp
+boost/math/tools/config.hpp
+-
+boost/math/tools/mp.hpp
+-
+limits
+-
+type_traits
+-
+cmath
+-
+cstdint
+-
+cstddef
+-
+
+../libraries/boost/math/special_functions/bernoulli.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/detail/unchecked_bernoulli.hpp
+-
+boost/math/special_functions/detail/bernoulli_details.hpp
+-
+
+../libraries/boost/math/special_functions/beta.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/gamma.hpp
+-
+boost/math/special_functions/binomial.hpp
+-
+boost/math/special_functions/factorials.hpp
+-
+boost/math/special_functions/erf.hpp
+-
+boost/math/special_functions/log1p.hpp
+-
+boost/math/special_functions/expm1.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/tools/roots.hpp
+-
+boost/static_assert.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+boost/math/special_functions/detail/ibeta_inverse.hpp
+-
+boost/math/special_functions/detail/ibeta_inv_ab.hpp
+-
+
+../libraries/boost/math/special_functions/binomial.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/factorials.hpp
+-
+boost/math/special_functions/beta.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+
+../libraries/boost/math/special_functions/cbrt.hpp
+boost/math/tools/rational.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+type_traits
+-
+cstdint
+-
+
+../libraries/boost/math/special_functions/cos_pi.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/constants/constants.hpp
+-
+
+../libraries/boost/math/special_functions/detail/bernoulli_details.hpp
+boost/config.hpp
+-
+boost/detail/lightweight_mutex.hpp
+-
+boost/math/tools/atomic.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/math/tools/toms748_solve.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+vector
+-
+
+../libraries/boost/math/special_functions/detail/erf_inv.hpp
+
+../libraries/boost/math/special_functions/detail/fp_traits.hpp
+cstring
+-
+limits
+-
+boost/assert.hpp
+-
+boost/cstdint.hpp
+-
+boost/predef/other/endian.h
+-
+boost/static_assert.hpp
+-
+boost/type_traits/is_floating_point.hpp
+-
+
+../libraries/boost/math/special_functions/detail/gamma_inva.hpp
+boost/math/tools/toms748_solve.hpp
+-
+boost/cstdint.hpp
+-
+
+../libraries/boost/math/special_functions/detail/ibeta_inv_ab.hpp
+boost/math/tools/toms748_solve.hpp
+-
+boost/cstdint.hpp
+-
+
+../libraries/boost/math/special_functions/detail/ibeta_inverse.hpp
+boost/math/special_functions/beta.hpp
+-
+boost/math/special_functions/erf.hpp
+-
+boost/math/tools/roots.hpp
+-
+boost/math/special_functions/detail/t_distribution_inv.hpp
+-
+
+../libraries/boost/math/special_functions/detail/igamma_inverse.hpp
+boost/math/tools/tuple.hpp
+-
+boost/math/special_functions/gamma.hpp
+-
+boost/math/special_functions/sign.hpp
+-
+boost/math/tools/roots.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+
+../libraries/boost/math/special_functions/detail/igamma_large.hpp
+
+../libraries/boost/math/special_functions/detail/lanczos_sse2.hpp
+emmintrin.h
+-
+
+../libraries/boost/math/special_functions/detail/lgamma_small.hpp
+boost/math/tools/big_constant.hpp
+-
+
+../libraries/boost/math/special_functions/detail/polygamma.hpp
+cmath
+-
+limits
+-
+boost/cstdint.hpp
+-
+boost/math/policies/policy.hpp
+-
+boost/math/special_functions/bernoulli.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/special_functions/zeta.hpp
+-
+boost/math/special_functions/digamma.hpp
+-
+boost/math/special_functions/sin_pi.hpp
+-
+boost/math/special_functions/cos_pi.hpp
+-
+boost/math/special_functions/pow.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/math/special_functions/detail/round_fwd.hpp
+boost/config.hpp
+-
+boost/math/tools/promotion.hpp
+-
+
+../libraries/boost/math/special_functions/detail/t_distribution_inv.hpp
+boost/math/special_functions/cbrt.hpp
+-
+boost/math/special_functions/round.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+
+../libraries/boost/math/special_functions/detail/unchecked_bernoulli.hpp
+limits
+-
+cmath
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/constants/constants.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+array
+-
+boost/array.hpp
+-
+
+../libraries/boost/math/special_functions/detail/unchecked_factorial.hpp
+boost/lexical_cast.hpp
+-
+cmath
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+array
+-
+boost/array.hpp
+-
+
+../libraries/boost/math/special_functions/digamma.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/rational.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/constants/constants.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+
+../libraries/boost/math/special_functions/erf.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/gamma.hpp
+-
+boost/math/tools/roots.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/special_functions/detail/erf_inv.hpp
+-
+
+../libraries/boost/math/special_functions/expm1.hpp
+cmath
+-
+boost/limits.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/precision.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/tools/rational.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/static_assert.hpp
+-
+boost/assert.hpp
+-
+
+../libraries/boost/math/special_functions/factorials.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/gamma.hpp
+-
+boost/math/special_functions/detail/unchecked_factorial.hpp
+-
+boost/array.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/math/special_functions/fpclassify.hpp
+limits
+-
+type_traits
+-
+cmath
+-
+boost/math/tools/real_cast.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/detail/fp_traits.hpp
+-
+float.h
+-
+quadmath.h
+../libraries/boost/math/special_functions/quadmath.h
+
+../libraries/boost/math/special_functions/gamma.hpp
+boost/config.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/fraction.hpp
+-
+boost/math/tools/precision.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/constants/constants.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/log1p.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/special_functions/powm1.hpp
+-
+boost/math/special_functions/sqrt1pm1.hpp
+-
+boost/math/special_functions/lanczos.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+boost/math/special_functions/detail/igamma_large.hpp
+-
+boost/math/special_functions/detail/unchecked_factorial.hpp
+-
+boost/math/special_functions/detail/lgamma_small.hpp
+-
+boost/math/special_functions/bernoulli.hpp
+-
+boost/math/special_functions/polygamma.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/assert.hpp
+-
+cmath
+-
+algorithm
+-
+boost/math/special_functions/detail/igamma_inverse.hpp
+-
+boost/math/special_functions/detail/gamma_inva.hpp
+-
+boost/math/special_functions/erf.hpp
+-
+
+../libraries/boost/math/special_functions/lanczos.hpp
+boost/config.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/tools/rational.hpp
+-
+boost/math/policies/policy.hpp
+-
+limits
+-
+type_traits
+-
+cstdint
+-
+boost/math/special_functions/detail/lanczos_sse2.hpp
+-
+
+../libraries/boost/math/special_functions/log1p.hpp
+boost/config/no_tr1/cmath.hpp
+-
+math.h
+-
+boost/limits.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/rational.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+boost/static_assert.hpp
+-
+boost/assert.hpp
+-
+
+../libraries/boost/math/special_functions/math_fwd.hpp
+vector
+-
+complex
+-
+type_traits
+-
+boost/math/special_functions/detail/round_fwd.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/policies/policy.hpp
+-
+
+../libraries/boost/math/special_functions/next.hpp
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+boost/math/special_functions/sign.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/tools/traits.hpp
+-
+float.h
+-
+xmmintrin.h
+../libraries/boost/math/special_functions/xmmintrin.h
+
+../libraries/boost/math/special_functions/polygamma.hpp
+boost/math/special_functions/factorials.hpp
+-
+boost/math/special_functions/detail/polygamma.hpp
+-
+boost/math/special_functions/trigamma.hpp
+-
+
+../libraries/boost/math/special_functions/pow.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/policies/policy.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/tools/promotion.hpp
+-
+
+../libraries/boost/math/special_functions/powm1.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/log1p.hpp
+-
+boost/math/special_functions/expm1.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/assert.hpp
+-
+
+../libraries/boost/math/special_functions/round.hpp
+boost/math/tools/config.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+
+../libraries/boost/math/special_functions/sign.hpp
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/detail/fp_traits.hpp
+-
+
+../libraries/boost/math/special_functions/sin_pi.hpp
+boost/config/no_tr1/cmath.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/trunc.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/constants/constants.hpp
+-
+
+../libraries/boost/math/special_functions/sqrt1pm1.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/special_functions/log1p.hpp
+-
+boost/math/special_functions/expm1.hpp
+-
+
+../libraries/boost/math/special_functions/trigamma.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/rational.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/promotion.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/constants/constants.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/special_functions/polygamma.hpp
+-
+
+../libraries/boost/math/special_functions/trunc.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/fpclassify.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/math/special_functions/zeta.hpp
+boost/math/special_functions/math_fwd.hpp
+-
+boost/math/tools/precision.hpp
+-
+boost/math/tools/series.hpp
+-
+boost/math/tools/big_constant.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/special_functions/gamma.hpp
+-
+boost/math/special_functions/factorials.hpp
+-
+boost/math/special_functions/sin_pi.hpp
+-
+
+../libraries/boost/math/tools/atomic.hpp
+boost/config.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+atomic
+-
+boost/atomic.hpp
+-
+
+../libraries/boost/math/tools/big_constant.hpp
+boost/math/tools/config.hpp
+-
+boost/lexical_cast.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_floating_point.hpp
+-
+
+../libraries/boost/math/tools/complex.hpp
+boost/type_traits/is_complex.hpp
+-
+
+../libraries/boost/math/tools/config.hpp
+boost/config.hpp
+-
+boost/predef/architecture/x86.h
+-
+boost/cstdint.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+algorithm
+-
+boost/config/no_tr1/cmath.hpp
+-
+climits
+-
+cfloat
+-
+math.h
+-
+limits
+-
+boost/math/tools/user.hpp
+-
+float.h
+-
+boost/type.hpp
+../libraries/boost/math/tools/boost/type.hpp
+boost/non_type.hpp
+../libraries/boost/math/tools/boost/non_type.hpp
+type_traits
+-
+boost/type_traits/is_floating_point.hpp
+-
+boost/detail/fenv.hpp
+-
+iostream
+-
+iomanip
+-
+typeinfo
+-
+
+../libraries/boost/math/tools/convert_from_string.hpp
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/lexical_cast.hpp
+-
+
+../libraries/boost/math/tools/cxx03_warn.hpp
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/math/tools/detail/polynomial_horner1_10.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_11.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_12.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_13.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_14.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_15.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_16.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_17.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_18.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_19.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_2.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_20.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_3.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_4.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_5.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_6.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_7.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_8.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner1_9.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_10.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_11.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_12.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_13.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_14.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_15.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_16.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_17.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_18.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_19.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_2.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_20.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_3.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_4.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_5.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_6.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_7.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_8.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner2_9.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_10.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_11.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_12.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_13.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_14.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_15.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_16.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_17.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_18.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_19.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_2.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_20.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_3.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_4.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_5.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_6.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_7.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_8.hpp
+
+../libraries/boost/math/tools/detail/polynomial_horner3_9.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_10.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_11.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_12.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_13.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_14.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_15.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_16.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_17.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_18.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_19.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_2.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_20.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_3.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_4.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_5.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_6.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_7.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_8.hpp
+
+../libraries/boost/math/tools/detail/rational_horner1_9.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_10.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_11.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_12.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_13.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_14.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_15.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_16.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_17.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_18.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_19.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_2.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_20.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_3.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_4.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_5.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_6.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_7.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_8.hpp
+
+../libraries/boost/math/tools/detail/rational_horner2_9.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_10.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_11.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_12.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_13.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_14.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_15.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_16.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_17.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_18.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_19.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_2.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_20.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_3.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_4.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_5.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_6.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_7.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_8.hpp
+
+../libraries/boost/math/tools/detail/rational_horner3_9.hpp
+
+../libraries/boost/math/tools/fraction.hpp
+boost/math/tools/precision.hpp
+-
+boost/math/tools/complex.hpp
+-
+type_traits
+-
+cstdint
+-
+cmath
+-
+
+../libraries/boost/math/tools/mp.hpp
+type_traits
+-
+cstddef
+-
+utility
+-
+
+../libraries/boost/math/tools/precision.hpp
+boost/limits.hpp
+-
+boost/assert.hpp
+-
+boost/static_assert.hpp
+-
+boost/math/policies/policy.hpp
+-
+type_traits
+-
+limits
+-
+climits
+-
+cmath
+-
+cstdint
+-
+cfloat
+-
+
+../libraries/boost/math/tools/promotion.hpp
+boost/math/tools/config.hpp
+-
+type_traits
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/math/tools/rational.hpp
+boost/array.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/tools/detail/polynomial_horner1_2.hpp
+-
+boost/math/tools/detail/polynomial_horner1_3.hpp
+-
+boost/math/tools/detail/polynomial_horner1_4.hpp
+-
+boost/math/tools/detail/polynomial_horner1_5.hpp
+-
+boost/math/tools/detail/polynomial_horner1_6.hpp
+-
+boost/math/tools/detail/polynomial_horner1_7.hpp
+-
+boost/math/tools/detail/polynomial_horner1_8.hpp
+-
+boost/math/tools/detail/polynomial_horner1_9.hpp
+-
+boost/math/tools/detail/polynomial_horner1_10.hpp
+-
+boost/math/tools/detail/polynomial_horner1_11.hpp
+-
+boost/math/tools/detail/polynomial_horner1_12.hpp
+-
+boost/math/tools/detail/polynomial_horner1_13.hpp
+-
+boost/math/tools/detail/polynomial_horner1_14.hpp
+-
+boost/math/tools/detail/polynomial_horner1_15.hpp
+-
+boost/math/tools/detail/polynomial_horner1_16.hpp
+-
+boost/math/tools/detail/polynomial_horner1_17.hpp
+-
+boost/math/tools/detail/polynomial_horner1_18.hpp
+-
+boost/math/tools/detail/polynomial_horner1_19.hpp
+-
+boost/math/tools/detail/polynomial_horner1_20.hpp
+-
+boost/math/tools/detail/polynomial_horner2_2.hpp
+-
+boost/math/tools/detail/polynomial_horner2_3.hpp
+-
+boost/math/tools/detail/polynomial_horner2_4.hpp
+-
+boost/math/tools/detail/polynomial_horner2_5.hpp
+-
+boost/math/tools/detail/polynomial_horner2_6.hpp
+-
+boost/math/tools/detail/polynomial_horner2_7.hpp
+-
+boost/math/tools/detail/polynomial_horner2_8.hpp
+-
+boost/math/tools/detail/polynomial_horner2_9.hpp
+-
+boost/math/tools/detail/polynomial_horner2_10.hpp
+-
+boost/math/tools/detail/polynomial_horner2_11.hpp
+-
+boost/math/tools/detail/polynomial_horner2_12.hpp
+-
+boost/math/tools/detail/polynomial_horner2_13.hpp
+-
+boost/math/tools/detail/polynomial_horner2_14.hpp
+-
+boost/math/tools/detail/polynomial_horner2_15.hpp
+-
+boost/math/tools/detail/polynomial_horner2_16.hpp
+-
+boost/math/tools/detail/polynomial_horner2_17.hpp
+-
+boost/math/tools/detail/polynomial_horner2_18.hpp
+-
+boost/math/tools/detail/polynomial_horner2_19.hpp
+-
+boost/math/tools/detail/polynomial_horner2_20.hpp
+-
+boost/math/tools/detail/polynomial_horner3_2.hpp
+-
+boost/math/tools/detail/polynomial_horner3_3.hpp
+-
+boost/math/tools/detail/polynomial_horner3_4.hpp
+-
+boost/math/tools/detail/polynomial_horner3_5.hpp
+-
+boost/math/tools/detail/polynomial_horner3_6.hpp
+-
+boost/math/tools/detail/polynomial_horner3_7.hpp
+-
+boost/math/tools/detail/polynomial_horner3_8.hpp
+-
+boost/math/tools/detail/polynomial_horner3_9.hpp
+-
+boost/math/tools/detail/polynomial_horner3_10.hpp
+-
+boost/math/tools/detail/polynomial_horner3_11.hpp
+-
+boost/math/tools/detail/polynomial_horner3_12.hpp
+-
+boost/math/tools/detail/polynomial_horner3_13.hpp
+-
+boost/math/tools/detail/polynomial_horner3_14.hpp
+-
+boost/math/tools/detail/polynomial_horner3_15.hpp
+-
+boost/math/tools/detail/polynomial_horner3_16.hpp
+-
+boost/math/tools/detail/polynomial_horner3_17.hpp
+-
+boost/math/tools/detail/polynomial_horner3_18.hpp
+-
+boost/math/tools/detail/polynomial_horner3_19.hpp
+-
+boost/math/tools/detail/polynomial_horner3_20.hpp
+-
+boost/math/tools/detail/rational_horner1_2.hpp
+-
+boost/math/tools/detail/rational_horner1_3.hpp
+-
+boost/math/tools/detail/rational_horner1_4.hpp
+-
+boost/math/tools/detail/rational_horner1_5.hpp
+-
+boost/math/tools/detail/rational_horner1_6.hpp
+-
+boost/math/tools/detail/rational_horner1_7.hpp
+-
+boost/math/tools/detail/rational_horner1_8.hpp
+-
+boost/math/tools/detail/rational_horner1_9.hpp
+-
+boost/math/tools/detail/rational_horner1_10.hpp
+-
+boost/math/tools/detail/rational_horner1_11.hpp
+-
+boost/math/tools/detail/rational_horner1_12.hpp
+-
+boost/math/tools/detail/rational_horner1_13.hpp
+-
+boost/math/tools/detail/rational_horner1_14.hpp
+-
+boost/math/tools/detail/rational_horner1_15.hpp
+-
+boost/math/tools/detail/rational_horner1_16.hpp
+-
+boost/math/tools/detail/rational_horner1_17.hpp
+-
+boost/math/tools/detail/rational_horner1_18.hpp
+-
+boost/math/tools/detail/rational_horner1_19.hpp
+-
+boost/math/tools/detail/rational_horner1_20.hpp
+-
+boost/math/tools/detail/rational_horner2_2.hpp
+-
+boost/math/tools/detail/rational_horner2_3.hpp
+-
+boost/math/tools/detail/rational_horner2_4.hpp
+-
+boost/math/tools/detail/rational_horner2_5.hpp
+-
+boost/math/tools/detail/rational_horner2_6.hpp
+-
+boost/math/tools/detail/rational_horner2_7.hpp
+-
+boost/math/tools/detail/rational_horner2_8.hpp
+-
+boost/math/tools/detail/rational_horner2_9.hpp
+-
+boost/math/tools/detail/rational_horner2_10.hpp
+-
+boost/math/tools/detail/rational_horner2_11.hpp
+-
+boost/math/tools/detail/rational_horner2_12.hpp
+-
+boost/math/tools/detail/rational_horner2_13.hpp
+-
+boost/math/tools/detail/rational_horner2_14.hpp
+-
+boost/math/tools/detail/rational_horner2_15.hpp
+-
+boost/math/tools/detail/rational_horner2_16.hpp
+-
+boost/math/tools/detail/rational_horner2_17.hpp
+-
+boost/math/tools/detail/rational_horner2_18.hpp
+-
+boost/math/tools/detail/rational_horner2_19.hpp
+-
+boost/math/tools/detail/rational_horner2_20.hpp
+-
+boost/math/tools/detail/rational_horner3_2.hpp
+-
+boost/math/tools/detail/rational_horner3_3.hpp
+-
+boost/math/tools/detail/rational_horner3_4.hpp
+-
+boost/math/tools/detail/rational_horner3_5.hpp
+-
+boost/math/tools/detail/rational_horner3_6.hpp
+-
+boost/math/tools/detail/rational_horner3_7.hpp
+-
+boost/math/tools/detail/rational_horner3_8.hpp
+-
+boost/math/tools/detail/rational_horner3_9.hpp
+-
+boost/math/tools/detail/rational_horner3_10.hpp
+-
+boost/math/tools/detail/rational_horner3_11.hpp
+-
+boost/math/tools/detail/rational_horner3_12.hpp
+-
+boost/math/tools/detail/rational_horner3_13.hpp
+-
+boost/math/tools/detail/rational_horner3_14.hpp
+-
+boost/math/tools/detail/rational_horner3_15.hpp
+-
+boost/math/tools/detail/rational_horner3_16.hpp
+-
+boost/math/tools/detail/rational_horner3_17.hpp
+-
+boost/math/tools/detail/rational_horner3_18.hpp
+-
+boost/math/tools/detail/rational_horner3_19.hpp
+-
+boost/math/tools/detail/rational_horner3_20.hpp
+-
+
+../libraries/boost/math/tools/real_cast.hpp
+boost/math/tools/config.hpp
+-
+
+../libraries/boost/math/tools/roots.hpp
+boost/math/tools/complex.hpp
+-
+utility
+-
+cmath
+-
+tuple
+-
+boost/math/tools/config.hpp
+-
+boost/cstdint.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+boost/math/special_functions/sign.hpp
+-
+boost/math/special_functions/next.hpp
+-
+boost/math/tools/toms748_solve.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+
+../libraries/boost/math/tools/series.hpp
+boost/config/no_tr1/cmath.hpp
+-
+boost/cstdint.hpp
+-
+boost/limits.hpp
+-
+boost/math/tools/config.hpp
+-
+
+../libraries/boost/math/tools/toms748_solve.hpp
+boost/math/tools/precision.hpp
+-
+boost/math/policies/error_handling.hpp
+-
+boost/math/tools/config.hpp
+-
+boost/math/special_functions/sign.hpp
+-
+boost/cstdint.hpp
+-
+limits
+-
+
+../libraries/boost/math/tools/traits.hpp
+type_traits
+-
+
+../libraries/boost/math/tools/tuple.hpp
+boost/config.hpp
+-
+boost/math/tools/cxx03_warn.hpp
+-
+tuple
+-
+
+../libraries/boost/math/tools/user.hpp
+
+../libraries/boost/mem_fn.hpp
+boost/bind/mem_fn.hpp
+-
+
+../libraries/boost/memory_order.hpp
+boost/config.hpp
+-
+
+../libraries/boost/move/detail/std_ns_begin.hpp
+
+../libraries/boost/move/detail/std_ns_end.hpp
+
+../libraries/boost/mpl/O1_size.hpp
+boost/mpl/O1_size_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/O1_size_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/O1_size_fwd.hpp
+
+../libraries/boost/mpl/advance.hpp
+boost/mpl/advance_fwd.hpp
+-
+boost/mpl/less.hpp
+-
+boost/mpl/negate.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/tag.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/aux_/advance_forward.hpp
+-
+boost/mpl/aux_/advance_backward.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/advance_fwd.hpp
+boost/mpl/aux_/common_name_wknd.hpp
+-
+
+../libraries/boost/mpl/always.hpp
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/arity_spec.hpp
+-
+
+../libraries/boost/mpl/and.hpp
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/nested_type_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/logical_op.hpp
+-
+
+../libraries/boost/mpl/apply.hpp
+boost/mpl/apply_fwd.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/partial_spec_params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/mpl/aux_/count_args.hpp
+-
+
+../libraries/boost/mpl/apply_fwd.hpp
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/apply_wrap.hpp
+boost/mpl/aux_/arity.hpp
+-
+boost/mpl/aux_/has_apply.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/msvc_never_true.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/add.hpp
+-
+boost/mpl/aux_/config/bcc.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/logical/and.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/mpl/aux_/msvc_dtw.hpp
+-
+
+../libraries/boost/mpl/arg.hpp
+boost/mpl/arg_fwd.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/na_assert.hpp
+-
+boost/mpl/aux_/arity_spec.hpp
+-
+boost/mpl/aux_/arg_typedef.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/arg_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/arithmetic.hpp
+boost/mpl/plus.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/times.hpp
+-
+boost/mpl/divides.hpp
+-
+boost/mpl/modulus.hpp
+-
+boost/mpl/negate.hpp
+-
+boost/mpl/multiplies.hpp
+-
+
+../libraries/boost/mpl/assert.hpp
+boost/mpl/not.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/nested_type_wknd.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/config/nttp.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/gpu.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/pp_counter.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/config.hpp
+-
+cstddef
+-
+boost/mpl/if.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/mpl/at.hpp
+boost/mpl/at_fwd.hpp
+-
+boost/mpl/aux_/at_impl.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/at_fwd.hpp
+
+../libraries/boost/mpl/aux_/O1_size_impl.hpp
+boost/mpl/O1_size_fwd.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/has_size.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/adl_barrier.hpp
+boost/mpl/aux_/config/adl.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/advance_backward.hpp
+boost/mpl/prior.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/unrolling.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+
+../libraries/boost/mpl/aux_/advance_forward.hpp
+boost/mpl/next.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/unrolling.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+
+../libraries/boost/mpl/aux_/arg_typedef.hpp
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/arithmetic_op.hpp
+boost/mpl/integral_c.hpp
+-
+boost/mpl/aux_/largest_int.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/numeric_op.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/arity.hpp
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/aux_/arity_spec.hpp
+boost/mpl/int.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/arity.hpp
+-
+boost/mpl/aux_/template_arity_fwd.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/aux_/at_impl.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/advance.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/back_impl.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/begin_end_impl.hpp
+boost/mpl/begin_end_fwd.hpp
+-
+boost/mpl/sequence_tag_fwd.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/aux_/has_begin.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/aux_/clear_impl.hpp
+boost/mpl/clear_fwd.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/aux_/common_name_wknd.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/comparison_op.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/numeric_op.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/integral.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/config/adl.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/intel.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/arrays.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/bcc.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/bind.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/compiler.hpp
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/ctps.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/dtp.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/eti.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/forwarding.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/gcc.hpp
+
+../libraries/boost/mpl/aux_/config/gpu.hpp
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/config/has_apply.hpp
+boost/mpl/aux_/config/has_xxx.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/has_xxx.hpp
+boost/mpl/aux_/config/overload_resolution.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/integral.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/intel.hpp
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/config/lambda.hpp
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/aux_/config/msvc.hpp
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/config/msvc_typename.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/nttp.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/overload_resolution.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/pp_counter.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+
+../libraries/boost/mpl/aux_/config/preprocessor.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/static_constant.hpp
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/config/ttp.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/config/typeof.hpp
+boost/mpl/aux_/config/gcc.hpp
+-
+
+../libraries/boost/mpl/aux_/config/use_preprocessed.hpp
+
+../libraries/boost/mpl/aux_/config/workaround.hpp
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/count_args.hpp
+boost/preprocessor/expr_if.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/preprocessor/enum_shifted_params.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+
+../libraries/boost/mpl/aux_/empty_impl.hpp
+boost/mpl/empty_fwd.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/erase_impl.hpp
+boost/mpl/clear.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/reverse_fold.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+
+../libraries/boost/mpl/aux_/erase_key_impl.hpp
+boost/mpl/erase_key_fwd.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/find_if_pred.hpp
+boost/mpl/aux_/iter_apply.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/mpl/aux_/fold_impl.hpp
+boost/mpl/next_prior.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/fold_impl_body.hpp
+-
+
+../libraries/boost/mpl/aux_/fold_impl_body.hpp
+boost/mpl/limits/unrolling.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/front_impl.hpp
+boost/mpl/front_fwd.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/full_lambda.hpp
+boost/mpl/lambda_fwd.hpp
+-
+boost/mpl/bind_fwd.hpp
+-
+boost/mpl/protect.hpp
+-
+boost/mpl/quote.hpp
+-
+boost/mpl/arg.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/int_fwd.hpp
+-
+boost/mpl/aux_/template_arity.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/lambda_arity_param.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/has_apply.hpp
+boost/mpl/has_xxx.hpp
+-
+boost/mpl/aux_/config/has_apply.hpp
+-
+
+../libraries/boost/mpl/aux_/has_begin.hpp
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/mpl/aux_/has_key_impl.hpp
+boost/mpl/has_key_fwd.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/has_rebind.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/intel.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/msvc_is_class.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/aux_/has_size.hpp
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/mpl/aux_/has_tag.hpp
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/mpl/aux_/has_type.hpp
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/mpl/aux_/include_preprocessed.hpp
+boost/mpl/aux_/config/compiler.hpp
+-
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+
+../libraries/boost/mpl/aux_/insert_impl.hpp
+boost/mpl/reverse_fold.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/clear.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/insert_range_impl.hpp
+boost/mpl/placeholders.hpp
+-
+boost/mpl/fold.hpp
+-
+boost/mpl/insert.hpp
+-
+boost/mpl/clear.hpp
+-
+boost/mpl/joint_view.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/iter_push_front.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/type_traits/same_traits.hpp
+-
+
+../libraries/boost/mpl/aux_/inserter_algorithm.hpp
+boost/mpl/back_inserter.hpp
+-
+boost/mpl/front_inserter.hpp
+-
+boost/mpl/push_back.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/back_inserter.hpp
+-
+boost/mpl/front_inserter.hpp
+-
+boost/mpl/clear.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/common_name_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+
+../libraries/boost/mpl/aux_/integral_wrapper.hpp
+boost/mpl/integral_c_tag.hpp
+-
+boost/mpl/aux_/static_cast.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/is_msvc_eti_arg.hpp
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/aux_/iter_apply.hpp
+boost/mpl/apply.hpp
+-
+boost/mpl/deref.hpp
+-
+
+../libraries/boost/mpl/aux_/iter_fold_if_impl.hpp
+boost/mpl/identity.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/unrolling.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/iter_fold_impl.hpp
+boost/mpl/next_prior.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/fold_impl_body.hpp
+-
+
+../libraries/boost/mpl/aux_/iter_push_front.hpp
+boost/mpl/push_front.hpp
+-
+boost/mpl/deref.hpp
+-
+
+../libraries/boost/mpl/aux_/joint_iter.hpp
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/aux_/lambda_spec.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/lambda_arity_param.hpp
+boost/mpl/aux_/config/ttp.hpp
+-
+
+../libraries/boost/mpl/aux_/lambda_no_ctps.hpp
+boost/mpl/lambda_fwd.hpp
+-
+boost/mpl/bind_fwd.hpp
+-
+boost/mpl/protect.hpp
+-
+boost/mpl/is_placeholder.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/template_arity.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/lambda_spec.hpp
+boost/mpl/void.hpp
+-
+boost/mpl/lambda_fwd.hpp
+-
+boost/mpl/int_fwd.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/lambda_arity_param.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+
+../libraries/boost/mpl/aux_/lambda_support.hpp
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/int_fwd.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/na_fwd.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/tuple/to_list.hpp
+-
+boost/preprocessor/list/for_each_i.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/largest_int.hpp
+boost/mpl/if.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/aux_/config/integral.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/mpl/aux_/logical_op.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/nested_type_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/ext_params.hpp
+-
+boost/mpl/aux_/preprocessor/def_params_tail.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/sub.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/msvc_dtw.hpp
+boost/mpl/aux_/preprocessor/params.hpp
+-
+
+../libraries/boost/mpl/aux_/msvc_eti_base.hpp
+boost/mpl/aux_/is_msvc_eti_arg.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/msvc_is_class.hpp
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+
+../libraries/boost/mpl/aux_/msvc_never_true.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/msvc_type.hpp
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/is_msvc_eti_arg.hpp
+-
+
+../libraries/boost/mpl/aux_/na.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/na_fwd.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/aux_/na_assert.hpp
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/mpl/aux_/na_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+
+../libraries/boost/mpl/aux_/na_spec.hpp
+boost/mpl/lambda_fwd.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/arity.hpp
+-
+boost/mpl/aux_/template_arity_fwd.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/def_params_tail.hpp
+-
+boost/mpl/aux_/lambda_arity_param.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/config/overload_resolution.hpp
+-
+
+../libraries/boost/mpl/aux_/nested_type_wknd.hpp
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/nttp_decl.hpp
+boost/mpl/aux_/config/nttp.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/numeric_cast_utils.hpp
+boost/mpl/numeric_cast.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+
+../libraries/boost/mpl/aux_/numeric_op.hpp
+boost/mpl/numeric_cast.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/tag.hpp
+-
+boost/mpl/aux_/numeric_cast_utils.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/msvc_eti_base.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/partial_spec_params.hpp
+-
+boost/mpl/aux_/preprocessor/def_params_tail.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/preprocessor/ext_params.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/add.hpp
+-
+boost/mpl/aux_/preprocessor/sub.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/pop_back_impl.hpp
+boost/mpl/pop_back_fwd.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+
+../libraries/boost/mpl/aux_/pop_front_impl.hpp
+boost/mpl/pop_front_fwd.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/add.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/mpl/aux_/preprocessor/tuple.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/arithmetic/add.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/def_params_tail.hpp
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/logical/and.hpp
+-
+boost/preprocessor/identity.hpp
+-
+boost/preprocessor/empty.hpp
+-
+boost/mpl/aux_/preprocessor/filter_params.hpp
+-
+boost/mpl/aux_/preprocessor/sub.hpp
+-
+boost/preprocessor/arithmetic/add.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/default_params.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/enum.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/ext_params.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/mpl/aux_/preprocessor/filter_params.hpp
+-
+boost/mpl/aux_/preprocessor/sub.hpp
+-
+boost/preprocessor/arithmetic/add.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/filter_params.hpp
+
+../libraries/boost/mpl/aux_/preprocessor/params.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/partial_spec_params.hpp
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/sub.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/range.hpp
+boost/preprocessor/seq/subseq.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/arithmetic/add.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/repeat.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/sub.hpp
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/mpl/aux_/preprocessor/tuple.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+
+../libraries/boost/mpl/aux_/preprocessor/tuple.hpp
+
+../libraries/boost/mpl/aux_/push_back_impl.hpp
+boost/mpl/push_back_fwd.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/aux_/has_type.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/push_front_impl.hpp
+boost/mpl/push_front_fwd.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/aux_/has_type.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/O1_size.hpp
+boost/mpl/O1_size_fwd.hpp
+-
+boost/mpl/aux_/range_c/size.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/back.hpp
+boost/mpl/back_fwd.hpp
+-
+boost/mpl/prior.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/empty.hpp
+boost/mpl/empty_fwd.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/front.hpp
+boost/mpl/front_fwd.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/iterator.hpp
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/advance_fwd.hpp
+-
+boost/mpl/distance_fwd.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/size.hpp
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/aux_/range_c/tag.hpp
+
+../libraries/boost/mpl/aux_/reverse_fold_impl.hpp
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/reverse_fold_impl_body.hpp
+-
+
+../libraries/boost/mpl/aux_/reverse_fold_impl_body.hpp
+boost/mpl/limits/unrolling.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/aux_/sequence_wrapper.hpp
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/enum_params_with_a_default.hpp
+-
+boost/preprocessor/enum_params.hpp
+-
+boost/preprocessor/enum.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/mpl/aux_/count_args.hpp
+-
+
+../libraries/boost/mpl/aux_/single_element_iter.hpp
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/advance_fwd.hpp
+-
+boost/mpl/distance_fwd.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/aux_/size_impl.hpp
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/distance.hpp
+-
+boost/mpl/aux_/traits_lambda_spec.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/static_cast.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/aux_/template_arity.hpp
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/template_arity_fwd.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/has_rebind.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/range.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/seq/fold_left.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/aux_/template_arity_fwd.hpp
+
+../libraries/boost/mpl/aux_/traits_lambda_spec.hpp
+boost/mpl/sequence_tag_fwd.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+
+../libraries/boost/mpl/aux_/transform_iter.hpp
+boost/mpl/apply.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/lambda_spec.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/aux_/type_wrapper.hpp
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/aux_/unwrap.hpp
+boost/ref.hpp
+-
+boost/mpl/aux_/config/gpu.hpp
+-
+
+../libraries/boost/mpl/aux_/value_wknd.hpp
+boost/mpl/aux_/static_cast.hpp
+-
+boost/mpl/aux_/config/integral.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/int.hpp
+-
+
+../libraries/boost/mpl/aux_/yes_no.hpp
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/arrays.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/back.hpp
+boost/mpl/back_fwd.hpp
+-
+boost/mpl/aux_/back_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/back_fwd.hpp
+
+../libraries/boost/mpl/back_inserter.hpp
+boost/mpl/push_back.hpp
+-
+boost/mpl/inserter.hpp
+-
+
+../libraries/boost/mpl/begin.hpp
+boost/mpl/begin_end.hpp
+-
+
+../libraries/boost/mpl/begin_end.hpp
+boost/mpl/begin_end_fwd.hpp
+-
+boost/mpl/aux_/begin_end_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/begin_end_fwd.hpp
+
+../libraries/boost/mpl/bind.hpp
+boost/mpl/bind_fwd.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/protect.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/arity_spec.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/mpl/aux_/config/bind.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/def_params_tail.hpp
+-
+boost/mpl/aux_/preprocessor/partial_spec_params.hpp
+-
+boost/mpl/aux_/preprocessor/ext_params.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/preprocessor/add.hpp
+-
+boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/mpl/aux_/count_args.hpp
+-
+
+../libraries/boost/mpl/bind_fwd.hpp
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/bind.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/bitand.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/bitxor.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/bool.hpp
+boost/mpl/bool_fwd.hpp
+-
+boost/mpl/integral_c_tag.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/bool_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+
+../libraries/boost/mpl/clear.hpp
+boost/mpl/clear_fwd.hpp
+-
+boost/mpl/aux_/clear_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/clear_fwd.hpp
+
+../libraries/boost/mpl/copy.hpp
+boost/mpl/fold.hpp
+-
+boost/mpl/reverse_fold.hpp
+-
+boost/mpl/aux_/inserter_algorithm.hpp
+-
+
+../libraries/boost/mpl/deref.hpp
+boost/mpl/aux_/msvc_type.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/distance.hpp
+boost/mpl/distance_fwd.hpp
+-
+boost/mpl/iter_fold.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/tag.hpp
+-
+boost/mpl/apply_wrap.hpp
+-
+boost/mpl/aux_/msvc_eti_base.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/distance_fwd.hpp
+boost/mpl/aux_/common_name_wknd.hpp
+-
+
+../libraries/boost/mpl/divides.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/empty.hpp
+boost/mpl/empty_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/empty_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/empty_base.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_empty.hpp
+-
+
+../libraries/boost/mpl/empty_fwd.hpp
+
+../libraries/boost/mpl/end.hpp
+boost/mpl/begin_end.hpp
+-
+
+../libraries/boost/mpl/equal_to.hpp
+boost/mpl/aux_/comparison_op.hpp
+-
+
+../libraries/boost/mpl/erase.hpp
+boost/mpl/erase_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/erase_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/msvc_typename.hpp
+-
+
+../libraries/boost/mpl/erase_fwd.hpp
+
+../libraries/boost/mpl/erase_key.hpp
+boost/mpl/erase_key_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/erase_key_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/msvc_typename.hpp
+-
+
+../libraries/boost/mpl/erase_key_fwd.hpp
+
+../libraries/boost/mpl/eval_if.hpp
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/find_if.hpp
+boost/mpl/aux_/find_if_pred.hpp
+-
+boost/mpl/arg.hpp
+-
+boost/mpl/iter_fold_if.hpp
+-
+boost/mpl/aux_/common_name_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/fold.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/O1_size.hpp
+-
+boost/mpl/aux_/fold_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/for_each.hpp
+boost/mpl/is_sequence.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/mpl/aux_/config/gpu.hpp
+-
+boost/mpl/aux_/unwrap.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/utility/value_init.hpp
+-
+
+../libraries/boost/mpl/front.hpp
+boost/mpl/front_fwd.hpp
+-
+boost/mpl/aux_/front_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/front_fwd.hpp
+
+../libraries/boost/mpl/front_inserter.hpp
+boost/mpl/push_front.hpp
+-
+boost/mpl/inserter.hpp
+-
+
+../libraries/boost/mpl/greater.hpp
+boost/mpl/aux_/comparison_op.hpp
+-
+
+../libraries/boost/mpl/has_key.hpp
+boost/mpl/has_key_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/has_key_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/has_key_fwd.hpp
+
+../libraries/boost/mpl/has_xxx.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/config/gcc.hpp
+-
+boost/mpl/aux_/config/has_xxx.hpp
+-
+boost/mpl/aux_/config/msvc_typename.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/array/elem.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_trailing_params.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/mpl/identity.hpp
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/if.hpp
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/static_cast.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/integral.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/inherit.hpp
+boost/mpl/empty_base.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/enum.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/insert.hpp
+boost/mpl/insert_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/insert_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/insert_fwd.hpp
+
+../libraries/boost/mpl/insert_range.hpp
+boost/mpl/insert_range_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/insert_range_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/insert_range_fwd.hpp
+
+../libraries/boost/mpl/inserter.hpp
+
+../libraries/boost/mpl/int.hpp
+boost/mpl/int_fwd.hpp
+-
+boost/mpl/aux_/integral_wrapper.hpp
+-
+
+../libraries/boost/mpl/int_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/integral_c.hpp
+boost/mpl/integral_c_fwd.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/integral_wrapper.hpp
+-
+
+../libraries/boost/mpl/integral_c_fwd.hpp
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/adl_barrier.hpp
+-
+
+../libraries/boost/mpl/integral_c_tag.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/is_placeholder.hpp
+boost/mpl/arg_fwd.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/is_sequence.hpp
+boost/mpl/not.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/sequence_tag_fwd.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/has_tag.hpp
+-
+boost/mpl/aux_/has_begin.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/mpl/aux_/msvc_is_class.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/iter_fold.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/O1_size.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/aux_/iter_fold_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/iter_fold_if.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/logical.hpp
+-
+boost/mpl/always.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/pair.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/aux_/iter_fold_if_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/iterator_category.hpp
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/iterator_range.hpp
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/iterator_tags.hpp
+boost/mpl/int.hpp
+-
+
+../libraries/boost/mpl/joint_view.hpp
+boost/mpl/aux_/joint_iter.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/lambda.hpp
+boost/mpl/lambda_fwd.hpp
+-
+boost/mpl/bind.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/aux_/full_lambda.hpp
+-
+boost/mpl/aux_/lambda_no_ctps.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/lambda_fwd.hpp
+boost/mpl/void_fwd.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/lambda.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/aux_/lambda_arity_param.hpp
+-
+boost/mpl/aux_/template_arity_fwd.hpp
+-
+boost/mpl/bool.hpp
+-
+
+../libraries/boost/mpl/less.hpp
+boost/mpl/aux_/comparison_op.hpp
+-
+
+../libraries/boost/mpl/limits/arity.hpp
+
+../libraries/boost/mpl/limits/list.hpp
+
+../libraries/boost/mpl/limits/unrolling.hpp
+
+../libraries/boost/mpl/limits/vector.hpp
+
+../libraries/boost/mpl/list.hpp
+boost/mpl/limits/list.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/list.hpp
+-
+boost/mpl/aux_/sequence_wrapper.hpp
+-
+
+../libraries/boost/mpl/logical.hpp
+boost/mpl/or.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+
+../libraries/boost/mpl/long.hpp
+boost/mpl/long_fwd.hpp
+-
+boost/mpl/aux_/integral_wrapper.hpp
+-
+
+../libraries/boost/mpl/long_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/min.hpp
+boost/mpl/min_max.hpp
+-
+
+../libraries/boost/mpl/min_max.hpp
+boost/mpl/less.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/minus.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/modulus.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/multiplies.hpp
+boost/mpl/times.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/preprocessor/default_params.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/negate.hpp
+boost/mpl/integral_c.hpp
+-
+boost/mpl/aux_/msvc_eti_base.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/config/integral.hpp
+-
+boost/mpl/aux_/config/static_constant.hpp
+-
+
+../libraries/boost/mpl/next.hpp
+boost/mpl/next_prior.hpp
+-
+
+../libraries/boost/mpl/next_prior.hpp
+boost/mpl/aux_/common_name_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/not.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/nested_type_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/numeric_cast.hpp
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/or.hpp
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/nested_type_wknd.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/logical_op.hpp
+-
+
+../libraries/boost/mpl/pair.hpp
+boost/mpl/aux_/msvc_eti_base.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/pair_view.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/iterator_category.hpp
+-
+boost/mpl/advance.hpp
+-
+boost/mpl/distance.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/min_max.hpp
+-
+boost/mpl/pair.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/placeholders.hpp
+boost/mpl/arg.hpp
+-
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/plus.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/pop_back.hpp
+boost/mpl/pop_back_fwd.hpp
+-
+boost/mpl/aux_/pop_back_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/pop_back_fwd.hpp
+
+../libraries/boost/mpl/pop_front.hpp
+boost/mpl/pop_front_fwd.hpp
+-
+boost/mpl/aux_/pop_front_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/pop_front_fwd.hpp
+
+../libraries/boost/mpl/prior.hpp
+boost/mpl/next_prior.hpp
+-
+
+../libraries/boost/mpl/protect.hpp
+boost/mpl/aux_/arity.hpp
+-
+boost/mpl/aux_/config/dtp.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/push_back.hpp
+boost/mpl/push_back_fwd.hpp
+-
+boost/mpl/aux_/push_back_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/push_back_fwd.hpp
+
+../libraries/boost/mpl/push_front.hpp
+boost/mpl/push_front_fwd.hpp
+-
+boost/mpl/aux_/push_front_impl.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+
+../libraries/boost/mpl/push_front_fwd.hpp
+
+../libraries/boost/mpl/quote.hpp
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/has_type.hpp
+-
+boost/mpl/aux_/config/bcc.hpp
+-
+boost/mpl/aux_/config/ttp.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/params.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/range_c.hpp
+boost/mpl/integral_c.hpp
+-
+boost/mpl/aux_/range_c/front.hpp
+-
+boost/mpl/aux_/range_c/back.hpp
+-
+boost/mpl/aux_/range_c/size.hpp
+-
+boost/mpl/aux_/range_c/O1_size.hpp
+-
+boost/mpl/aux_/range_c/empty.hpp
+-
+boost/mpl/aux_/range_c/iterator.hpp
+-
+boost/mpl/aux_/range_c/tag.hpp
+-
+
+../libraries/boost/mpl/remove.hpp
+boost/mpl/remove_if.hpp
+-
+boost/mpl/same_as.hpp
+-
+boost/mpl/aux_/inserter_algorithm.hpp
+-
+
+../libraries/boost/mpl/remove_if.hpp
+boost/mpl/fold.hpp
+-
+boost/mpl/reverse_fold.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/protect.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/aux_/inserter_algorithm.hpp
+-
+
+../libraries/boost/mpl/reverse_fold.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/O1_size.hpp
+-
+boost/mpl/arg.hpp
+-
+boost/mpl/aux_/reverse_fold_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/same_as.hpp
+boost/mpl/not.hpp
+-
+boost/mpl/aux_/lambda_spec.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/sequence_tag.hpp
+boost/mpl/sequence_tag_fwd.hpp
+-
+boost/mpl/aux_/has_tag.hpp
+-
+boost/mpl/aux_/has_begin.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/is_msvc_eti_arg.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+boost/mpl/aux_/yes_no.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/sequence_tag_fwd.hpp
+
+../libraries/boost/mpl/single_view.hpp
+boost/mpl/aux_/single_element_iter.hpp
+-
+boost/mpl/iterator_range.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/size.hpp
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/sequence_tag.hpp
+-
+boost/mpl/aux_/size_impl.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/lambda_support.hpp
+-
+boost/mpl/aux_/msvc_eti_base.hpp
+-
+
+../libraries/boost/mpl/size_fwd.hpp
+
+../libraries/boost/mpl/size_t.hpp
+boost/mpl/size_t_fwd.hpp
+-
+boost/mpl/aux_/integral_wrapper.hpp
+-
+
+../libraries/boost/mpl/size_t_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+boost/config.hpp
+-
+cstddef
+-
+
+../libraries/boost/mpl/tag.hpp
+boost/mpl/eval_if.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/has_tag.hpp
+-
+boost/mpl/aux_/config/eti.hpp
+-
+
+../libraries/boost/mpl/times.hpp
+boost/mpl/aux_/arithmetic_op.hpp
+-
+
+../libraries/boost/mpl/transform.hpp
+boost/mpl/fold.hpp
+-
+boost/mpl/reverse_fold.hpp
+-
+boost/mpl/pair_view.hpp
+-
+boost/mpl/is_sequence.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/bind.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/inserter_algorithm.hpp
+-
+
+../libraries/boost/mpl/transform_view.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/aux_/transform_iter.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/mpl/unpack_args.hpp
+boost/mpl/apply.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/size.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/lambda_spec.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/arity.hpp
+-
+boost/mpl/aux_/preprocessor/repeat.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/forwarding.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/mpl/vector.hpp
+boost/mpl/limits/vector.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/aux_/include_preprocessed.hpp
+-
+boost/mpl/limits/vector.hpp
+-
+boost/mpl/aux_/sequence_wrapper.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/O1_size.hpp
+boost/mpl/O1_size_fwd.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/at.hpp
+boost/mpl/at_fwd.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/long.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/back.hpp
+boost/mpl/back_fwd.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/vector/aux_/at.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/begin_end.hpp
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/begin_end_fwd.hpp
+-
+boost/mpl/vector/aux_/iterator.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/clear.hpp
+boost/mpl/clear_fwd.hpp
+-
+boost/mpl/vector/aux_/vector0.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/empty.hpp
+boost/mpl/empty_fwd.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/front.hpp
+boost/mpl/front_fwd.hpp
+-
+boost/mpl/vector/aux_/at.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/include_preprocessed.hpp
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/preprocessor.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/item.hpp
+boost/mpl/long.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/next_prior.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/iterator.hpp
+boost/mpl/vector/aux_/at.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/minus.hpp
+-
+boost/mpl/advance_fwd.hpp
+-
+boost/mpl/distance_fwd.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/prior.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+boost/mpl/aux_/value_wknd.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/pop_back.hpp
+boost/mpl/pop_back_fwd.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/vector/aux_/item.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/pop_front.hpp
+boost/mpl/pop_front_fwd.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/vector/aux_/item.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/push_back.hpp
+boost/mpl/push_back_fwd.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/vector/aux_/item.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/push_front.hpp
+boost/mpl/push_front_fwd.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/vector/aux_/item.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/size.hpp
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/vector/aux_/O1_size.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/tag.hpp
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/nttp_decl.hpp
+-
+
+../libraries/boost/mpl/vector/aux_/vector0.hpp
+boost/mpl/long.hpp
+-
+boost/mpl/void.hpp
+-
+boost/mpl/aux_/na.hpp
+-
+boost/mpl/aux_/type_wrapper.hpp
+-
+boost/mpl/vector/aux_/iterator.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+
+../libraries/boost/mpl/vector/vector0.hpp
+boost/mpl/vector/aux_/at.hpp
+-
+boost/mpl/vector/aux_/front.hpp
+-
+boost/mpl/vector/aux_/push_front.hpp
+-
+boost/mpl/vector/aux_/pop_front.hpp
+-
+boost/mpl/vector/aux_/push_back.hpp
+-
+boost/mpl/vector/aux_/pop_back.hpp
+-
+boost/mpl/vector/aux_/back.hpp
+-
+boost/mpl/vector/aux_/clear.hpp
+-
+boost/mpl/vector/aux_/O1_size.hpp
+-
+boost/mpl/vector/aux_/size.hpp
+-
+boost/mpl/vector/aux_/empty.hpp
+-
+boost/mpl/vector/aux_/item.hpp
+-
+boost/mpl/vector/aux_/iterator.hpp
+-
+boost/mpl/vector/aux_/vector0.hpp
+-
+boost/mpl/vector/aux_/begin_end.hpp
+-
+boost/mpl/vector/aux_/tag.hpp
+-
+
+../libraries/boost/mpl/vector/vector10.hpp
+boost/mpl/vector/vector0.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/vector/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+
+../libraries/boost/mpl/vector/vector20.hpp
+boost/mpl/vector/vector10.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/vector/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+
+../libraries/boost/mpl/vector/vector30.hpp
+boost/mpl/vector/vector20.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/vector/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+
+../libraries/boost/mpl/vector/vector40.hpp
+boost/mpl/vector/vector30.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/vector/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+
+../libraries/boost/mpl/vector/vector50.hpp
+boost/mpl/vector/vector40.hpp
+-
+boost/mpl/aux_/config/use_preprocessed.hpp
+-
+boost/mpl/vector/aux_/include_preprocessed.hpp
+-
+boost/mpl/aux_/config/typeof.hpp
+-
+boost/mpl/aux_/config/ctps.hpp
+-
+boost/preprocessor/iterate.hpp
+-
+
+../libraries/boost/mpl/void.hpp
+boost/mpl/void_fwd.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+boost/mpl/aux_/config/msvc.hpp
+-
+boost/mpl/aux_/config/workaround.hpp
+-
+
+../libraries/boost/mpl/void_fwd.hpp
+boost/mpl/aux_/adl_barrier.hpp
+-
+
+../libraries/boost/mpl/zip_view.hpp
+boost/mpl/transform.hpp
+-
+boost/mpl/begin_end.hpp
+-
+boost/mpl/iterator_tags.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/lambda.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/aux_/na_spec.hpp
+-
+
+../libraries/boost/multi_array.hpp
+boost/multi_array/base.hpp
+../libraries/boost/boost/multi_array/base.hpp
+boost/multi_array/collection_concept.hpp
+../libraries/boost/boost/multi_array/collection_concept.hpp
+boost/multi_array/copy_array.hpp
+../libraries/boost/boost/multi_array/copy_array.hpp
+boost/multi_array/iterator.hpp
+../libraries/boost/boost/multi_array/iterator.hpp
+boost/multi_array/subarray.hpp
+../libraries/boost/boost/multi_array/subarray.hpp
+boost/multi_array/multi_array_ref.hpp
+../libraries/boost/boost/multi_array/multi_array_ref.hpp
+boost/multi_array/algorithm.hpp
+../libraries/boost/boost/multi_array/algorithm.hpp
+boost/core/alloc_construct.hpp
+../libraries/boost/boost/core/alloc_construct.hpp
+boost/core/empty_value.hpp
+../libraries/boost/boost/core/empty_value.hpp
+boost/array.hpp
+../libraries/boost/boost/array.hpp
+boost/mpl/if.hpp
+../libraries/boost/boost/mpl/if.hpp
+boost/type_traits.hpp
+../libraries/boost/boost/type_traits.hpp
+algorithm
+-
+cstddef
+-
+functional
+-
+numeric
+-
+vector
+-
+
+../libraries/boost/multi_array/algorithm.hpp
+iterator
+-
+
+../libraries/boost/multi_array/base.hpp
+boost/multi_array/extent_range.hpp
+../libraries/boost/multi_array/boost/multi_array/extent_range.hpp
+boost/multi_array/extent_gen.hpp
+../libraries/boost/multi_array/boost/multi_array/extent_gen.hpp
+boost/multi_array/index_range.hpp
+../libraries/boost/multi_array/boost/multi_array/index_range.hpp
+boost/multi_array/index_gen.hpp
+../libraries/boost/multi_array/boost/multi_array/index_gen.hpp
+boost/multi_array/storage_order.hpp
+../libraries/boost/multi_array/boost/multi_array/storage_order.hpp
+boost/multi_array/types.hpp
+../libraries/boost/multi_array/boost/multi_array/types.hpp
+boost/config.hpp
+../libraries/boost/multi_array/boost/config.hpp
+boost/multi_array/concept_checks.hpp
+../libraries/boost/multi_array/boost/multi_array/concept_checks.hpp
+boost/mpl/eval_if.hpp
+../libraries/boost/multi_array/boost/mpl/eval_if.hpp
+boost/mpl/if.hpp
+../libraries/boost/multi_array/boost/mpl/if.hpp
+boost/mpl/size_t.hpp
+../libraries/boost/multi_array/boost/mpl/size_t.hpp
+boost/iterator/reverse_iterator.hpp
+../libraries/boost/multi_array/boost/iterator/reverse_iterator.hpp
+boost/static_assert.hpp
+../libraries/boost/multi_array/boost/static_assert.hpp
+boost/type.hpp
+../libraries/boost/multi_array/boost/type.hpp
+boost/assert.hpp
+../libraries/boost/multi_array/boost/assert.hpp
+cstddef
+-
+memory
+-
+
+../libraries/boost/multi_array/collection_concept.hpp
+boost/concept_check.hpp
+../libraries/boost/multi_array/boost/concept_check.hpp
+
+../libraries/boost/multi_array/concept_checks.hpp
+boost/concept_check.hpp
+../libraries/boost/multi_array/boost/concept_check.hpp
+boost/iterator/iterator_concepts.hpp
+../libraries/boost/multi_array/boost/iterator/iterator_concepts.hpp
+
+../libraries/boost/multi_array/copy_array.hpp
+boost/type.hpp
+../libraries/boost/multi_array/boost/type.hpp
+boost/assert.hpp
+../libraries/boost/multi_array/boost/assert.hpp
+
+../libraries/boost/multi_array/extent_gen.hpp
+boost/multi_array/extent_range.hpp
+../libraries/boost/multi_array/boost/multi_array/extent_range.hpp
+boost/multi_array/range_list.hpp
+../libraries/boost/multi_array/boost/multi_array/range_list.hpp
+boost/multi_array/types.hpp
+../libraries/boost/multi_array/boost/multi_array/types.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+algorithm
+-
+
+../libraries/boost/multi_array/extent_range.hpp
+utility
+-
+
+../libraries/boost/multi_array/index_gen.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+boost/multi_array/index_range.hpp
+../libraries/boost/multi_array/boost/multi_array/index_range.hpp
+boost/multi_array/range_list.hpp
+../libraries/boost/multi_array/boost/multi_array/range_list.hpp
+boost/multi_array/types.hpp
+../libraries/boost/multi_array/boost/multi_array/types.hpp
+algorithm
+-
+cstddef
+-
+
+../libraries/boost/multi_array/index_range.hpp
+boost/config.hpp
+-
+utility
+-
+boost/limits.hpp
+-
+
+../libraries/boost/multi_array/iterator.hpp
+boost/multi_array/base.hpp
+../libraries/boost/multi_array/boost/multi_array/base.hpp
+boost/iterator/iterator_facade.hpp
+../libraries/boost/multi_array/boost/iterator/iterator_facade.hpp
+algorithm
+-
+cstddef
+-
+iterator
+-
+
+../libraries/boost/multi_array/multi_array_ref.hpp
+boost/multi_array/base.hpp
+../libraries/boost/multi_array/boost/multi_array/base.hpp
+boost/multi_array/collection_concept.hpp
+../libraries/boost/multi_array/boost/multi_array/collection_concept.hpp
+boost/multi_array/concept_checks.hpp
+../libraries/boost/multi_array/boost/multi_array/concept_checks.hpp
+boost/multi_array/iterator.hpp
+../libraries/boost/multi_array/boost/multi_array/iterator.hpp
+boost/multi_array/storage_order.hpp
+../libraries/boost/multi_array/boost/multi_array/storage_order.hpp
+boost/multi_array/subarray.hpp
+../libraries/boost/multi_array/boost/multi_array/subarray.hpp
+boost/multi_array/view.hpp
+../libraries/boost/multi_array/boost/multi_array/view.hpp
+boost/multi_array/algorithm.hpp
+../libraries/boost/multi_array/boost/multi_array/algorithm.hpp
+boost/type_traits/is_integral.hpp
+../libraries/boost/multi_array/boost/type_traits/is_integral.hpp
+boost/utility/enable_if.hpp
+../libraries/boost/multi_array/boost/utility/enable_if.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+boost/concept_check.hpp
+../libraries/boost/multi_array/boost/concept_check.hpp
+boost/functional.hpp
+../libraries/boost/multi_array/boost/functional.hpp
+boost/limits.hpp
+../libraries/boost/multi_array/boost/limits.hpp
+algorithm
+-
+cstddef
+-
+functional
+-
+numeric
+-
+
+../libraries/boost/multi_array/range_list.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+
+../libraries/boost/multi_array/storage_order.hpp
+boost/multi_array/types.hpp
+../libraries/boost/multi_array/boost/multi_array/types.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+boost/multi_array/algorithm.hpp
+../libraries/boost/multi_array/boost/multi_array/algorithm.hpp
+algorithm
+-
+cstddef
+-
+functional
+-
+numeric
+-
+vector
+-
+
+../libraries/boost/multi_array/subarray.hpp
+boost/multi_array/base.hpp
+../libraries/boost/multi_array/boost/multi_array/base.hpp
+boost/multi_array/concept_checks.hpp
+../libraries/boost/multi_array/boost/multi_array/concept_checks.hpp
+boost/limits.hpp
+../libraries/boost/multi_array/boost/limits.hpp
+boost/type.hpp
+../libraries/boost/multi_array/boost/type.hpp
+algorithm
+-
+cstddef
+-
+functional
+-
+
+../libraries/boost/multi_array/types.hpp
+boost/config.hpp
+../libraries/boost/multi_array/boost/config.hpp
+cstddef
+-
+
+../libraries/boost/multi_array/view.hpp
+boost/multi_array/base.hpp
+../libraries/boost/multi_array/boost/multi_array/base.hpp
+boost/multi_array/concept_checks.hpp
+../libraries/boost/multi_array/boost/multi_array/concept_checks.hpp
+boost/multi_array/iterator.hpp
+../libraries/boost/multi_array/boost/multi_array/iterator.hpp
+boost/multi_array/storage_order.hpp
+../libraries/boost/multi_array/boost/multi_array/storage_order.hpp
+boost/multi_array/subarray.hpp
+../libraries/boost/multi_array/boost/multi_array/subarray.hpp
+boost/multi_array/algorithm.hpp
+../libraries/boost/multi_array/boost/multi_array/algorithm.hpp
+boost/type_traits/is_integral.hpp
+../libraries/boost/multi_array/boost/type_traits/is_integral.hpp
+boost/utility/enable_if.hpp
+../libraries/boost/multi_array/boost/utility/enable_if.hpp
+boost/array.hpp
+../libraries/boost/multi_array/boost/array.hpp
+boost/limits.hpp
+../libraries/boost/multi_array/boost/limits.hpp
+algorithm
+-
+cstddef
+-
+functional
+-
+numeric
+-
+
+../libraries/boost/next_prior.hpp
+iterator
+-
+boost/config.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/type_traits/has_plus.hpp
+-
+boost/type_traits/has_plus_assign.hpp
+-
+boost/type_traits/has_minus.hpp
+-
+boost/type_traits/has_minus_assign.hpp
+-
+boost/iterator/advance.hpp
+-
+boost/iterator/reverse_iterator.hpp
+-
+
+../libraries/boost/non_type.hpp
+
+../libraries/boost/noncopyable.hpp
+boost/core/noncopyable.hpp
+-
+
+../libraries/boost/numeric/conversion/bounds.hpp
+boost/numeric/conversion/detail/bounds.hpp
+../libraries/boost/numeric/conversion/boost/numeric/conversion/detail/bounds.hpp
+
+../libraries/boost/numeric/conversion/cast.hpp
+boost/detail/workaround.hpp
+-
+boost/numeric/conversion/detail/old_numeric_cast.hpp
+-
+boost/type.hpp
+-
+boost/numeric/conversion/converter.hpp
+-
+boost/numeric/conversion/numeric_cast_traits.hpp
+-
+
+../libraries/boost/numeric/conversion/conversion_traits.hpp
+boost/numeric/conversion/detail/conversion_traits.hpp
+../libraries/boost/numeric/conversion/boost/numeric/conversion/detail/conversion_traits.hpp
+boost/detail/workaround.hpp
+../libraries/boost/numeric/conversion/boost/detail/workaround.hpp
+boost/config.hpp
+../libraries/boost/numeric/conversion/boost/config.hpp
+
+../libraries/boost/numeric/conversion/converter.hpp
+boost/numeric/conversion/conversion_traits.hpp
+../libraries/boost/numeric/conversion/boost/numeric/conversion/conversion_traits.hpp
+boost/numeric/conversion/converter_policies.hpp
+../libraries/boost/numeric/conversion/boost/numeric/conversion/converter_policies.hpp
+boost/numeric/conversion/detail/converter.hpp
+../libraries/boost/numeric/conversion/boost/numeric/conversion/detail/converter.hpp
+
+../libraries/boost/numeric/conversion/converter_policies.hpp
+functional
+-
+typeinfo
+-
+boost/config.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+boost/throw_exception.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+../libraries/boost/numeric/conversion/boost/type_traits/is_arithmetic.hpp
+boost/mpl/if.hpp
+../libraries/boost/numeric/conversion/boost/mpl/if.hpp
+boost/mpl/integral_c.hpp
+../libraries/boost/numeric/conversion/boost/mpl/integral_c.hpp
+
+../libraries/boost/numeric/conversion/detail/bounds.hpp
+boost/limits.hpp
+../libraries/boost/numeric/conversion/detail/boost/limits.hpp
+boost/config.hpp
+../libraries/boost/numeric/conversion/detail/boost/config.hpp
+boost/mpl/if.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/if.hpp
+
+../libraries/boost/numeric/conversion/detail/conversion_traits.hpp
+boost/type_traits/is_arithmetic.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/is_arithmetic.hpp
+boost/type_traits/is_same.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/is_same.hpp
+boost/type_traits/remove_cv.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/remove_cv.hpp
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/numeric/conversion/detail/int_float_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/int_float_mixture.hpp
+boost/numeric/conversion/detail/sign_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/sign_mixture.hpp
+boost/numeric/conversion/detail/udt_builtin_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/udt_builtin_mixture.hpp
+boost/numeric/conversion/detail/is_subranged.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/is_subranged.hpp
+
+../libraries/boost/numeric/conversion/detail/converter.hpp
+functional
+-
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/numeric/conversion/detail/conversion_traits.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/conversion_traits.hpp
+boost/numeric/conversion/bounds.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/bounds.hpp
+boost/type_traits/is_same.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/is_same.hpp
+boost/mpl/integral_c.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/integral_c.hpp
+
+../libraries/boost/numeric/conversion/detail/int_float_mixture.hpp
+boost/config.hpp
+../libraries/boost/numeric/conversion/detail/boost/config.hpp
+boost/limits.hpp
+../libraries/boost/numeric/conversion/detail/boost/limits.hpp
+boost/numeric/conversion/int_float_mixture_enum.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/int_float_mixture_enum.hpp
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/mpl/integral_c.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/integral_c.hpp
+
+../libraries/boost/numeric/conversion/detail/is_subranged.hpp
+boost/config.hpp
+../libraries/boost/numeric/conversion/detail/boost/config.hpp
+boost/limits.hpp
+../libraries/boost/numeric/conversion/detail/boost/limits.hpp
+boost/mpl/int.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/int.hpp
+boost/mpl/multiplies.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/multiplies.hpp
+boost/mpl/less.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/less.hpp
+boost/mpl/equal_to.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/equal_to.hpp
+boost/type_traits/is_same.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/is_same.hpp
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/numeric/conversion/detail/int_float_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/int_float_mixture.hpp
+boost/numeric/conversion/detail/sign_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/sign_mixture.hpp
+boost/numeric/conversion/detail/udt_builtin_mixture.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/udt_builtin_mixture.hpp
+
+../libraries/boost/numeric/conversion/detail/meta.hpp
+boost/type_traits/remove_cv.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/remove_cv.hpp
+boost/mpl/if.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/if.hpp
+boost/mpl/eval_if.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/eval_if.hpp
+boost/mpl/equal_to.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/equal_to.hpp
+boost/mpl/not.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/not.hpp
+boost/mpl/and.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/and.hpp
+boost/mpl/bool.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/bool.hpp
+boost/mpl/identity.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/identity.hpp
+
+../libraries/boost/numeric/conversion/detail/numeric_cast_traits.hpp
+boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp
+-
+boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp
+-
+boost/preprocessor/seq/elem.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+
+../libraries/boost/numeric/conversion/detail/old_numeric_cast.hpp
+boost/config.hpp
+-
+cassert
+-
+typeinfo
+-
+boost/type.hpp
+-
+boost/limits.hpp
+-
+boost/numeric/conversion/converter_policies.hpp
+-
+
+../libraries/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_common.hpp
+
+../libraries/boost/numeric/conversion/detail/preprocessed/numeric_cast_traits_long_long.hpp
+
+../libraries/boost/numeric/conversion/detail/sign_mixture.hpp
+boost/config.hpp
+../libraries/boost/numeric/conversion/detail/boost/config.hpp
+boost/limits.hpp
+../libraries/boost/numeric/conversion/detail/boost/limits.hpp
+boost/numeric/conversion/sign_mixture_enum.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/sign_mixture_enum.hpp
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/mpl/integral_c.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/integral_c.hpp
+
+../libraries/boost/numeric/conversion/detail/udt_builtin_mixture.hpp
+boost/type_traits/is_arithmetic.hpp
+../libraries/boost/numeric/conversion/detail/boost/type_traits/is_arithmetic.hpp
+boost/numeric/conversion/udt_builtin_mixture_enum.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/udt_builtin_mixture_enum.hpp
+boost/numeric/conversion/detail/meta.hpp
+../libraries/boost/numeric/conversion/detail/boost/numeric/conversion/detail/meta.hpp
+boost/mpl/integral_c.hpp
+../libraries/boost/numeric/conversion/detail/boost/mpl/integral_c.hpp
+
+../libraries/boost/numeric/conversion/int_float_mixture_enum.hpp
+
+../libraries/boost/numeric/conversion/numeric_cast_traits.hpp
+boost/numeric/conversion/converter_policies.hpp
+-
+boost/cstdint.hpp
+-
+boost/numeric/conversion/detail/numeric_cast_traits.hpp
+-
+
+../libraries/boost/numeric/conversion/sign_mixture_enum.hpp
+
+../libraries/boost/numeric/conversion/udt_builtin_mixture_enum.hpp
+
+../libraries/boost/numeric/interval.hpp
+boost/limits.hpp
+-
+boost/numeric/interval/interval.hpp
+-
+boost/numeric/interval/policies.hpp
+-
+boost/numeric/interval/hw_rounding.hpp
+-
+boost/numeric/interval/rounded_arith.hpp
+-
+boost/numeric/interval/rounded_transc.hpp
+-
+boost/numeric/interval/constants.hpp
+-
+boost/numeric/interval/checking.hpp
+-
+boost/numeric/interval/compare.hpp
+-
+boost/numeric/interval/utility.hpp
+-
+boost/numeric/interval/arith.hpp
+-
+boost/numeric/interval/arith2.hpp
+-
+boost/numeric/interval/arith3.hpp
+-
+boost/numeric/interval/transc.hpp
+-
+
+../libraries/boost/numeric/interval/arith.hpp
+boost/config.hpp
+-
+boost/numeric/interval/interval.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/detail/division.hpp
+-
+algorithm
+-
+
+../libraries/boost/numeric/interval/arith2.hpp
+boost/config.hpp
+-
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/numeric/interval/detail/division.hpp
+-
+boost/numeric/interval/arith.hpp
+-
+boost/numeric/interval/policies.hpp
+-
+algorithm
+-
+cassert
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/numeric/interval/arith3.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+
+../libraries/boost/numeric/interval/checking.hpp
+stdexcept
+-
+string
+-
+cassert
+-
+boost/limits.hpp
+-
+
+../libraries/boost/numeric/interval/compare.hpp
+boost/numeric/interval/compare/certain.hpp
+-
+boost/numeric/interval/compare/possible.hpp
+-
+boost/numeric/interval/compare/explicit.hpp
+-
+boost/numeric/interval/compare/lexicographic.hpp
+-
+boost/numeric/interval/compare/set.hpp
+-
+
+../libraries/boost/numeric/interval/compare/certain.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+
+../libraries/boost/numeric/interval/compare/explicit.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+
+../libraries/boost/numeric/interval/compare/lexicographic.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+
+../libraries/boost/numeric/interval/compare/possible.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+
+../libraries/boost/numeric/interval/compare/set.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/utility.hpp
+-
+
+../libraries/boost/numeric/interval/constants.hpp
+
+../libraries/boost/numeric/interval/detail/alpha_rounding_control.hpp
+float.h
+-
+
+../libraries/boost/numeric/interval/detail/bcc_rounding_control.hpp
+float.h
+-
+
+../libraries/boost/numeric/interval/detail/bugs.hpp
+boost/config.hpp
+-
+
+../libraries/boost/numeric/interval/detail/c99_rounding_control.hpp
+boost/numeric/interval/detail/c99sub_rounding_control.hpp
+-
+
+../libraries/boost/numeric/interval/detail/c99sub_rounding_control.hpp
+boost/detail/fenv.hpp
+-
+
+../libraries/boost/numeric/interval/detail/division.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/rounded_arith.hpp
+-
+algorithm
+-
+
+../libraries/boost/numeric/interval/detail/ia64_rounding_control.hpp
+fenv.h
+-
+
+../libraries/boost/numeric/interval/detail/interval_prototype.hpp
+
+../libraries/boost/numeric/interval/detail/msvc_rounding_control.hpp
+float.h
+-
+
+../libraries/boost/numeric/interval/detail/ppc_rounding_control.hpp
+
+../libraries/boost/numeric/interval/detail/sparc_rounding_control.hpp
+ieeefp.h
+-
+
+../libraries/boost/numeric/interval/detail/test_input.hpp
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+
+../libraries/boost/numeric/interval/detail/x86_rounding_control.hpp
+boost/numeric/interval/detail/x86gcc_rounding_control.hpp
+-
+boost/numeric/interval/detail/bcc_rounding_control.hpp
+-
+boost/numeric/interval/detail/msvc_rounding_control.hpp
+-
+boost/numeric/interval/detail/c99sub_rounding_control.hpp
+-
+
+../libraries/boost/numeric/interval/detail/x86gcc_rounding_control.hpp
+
+../libraries/boost/numeric/interval/hw_rounding.hpp
+boost/numeric/interval/rounding.hpp
+-
+boost/numeric/interval/rounded_arith.hpp
+-
+boost/numeric/interval/detail/c99_rounding_control.hpp
+-
+boost/numeric/interval/detail/x86_rounding_control.hpp
+-
+boost/numeric/interval/detail/x86_rounding_control.hpp
+-
+boost/numeric/interval/detail/ppc_rounding_control.hpp
+-
+boost/numeric/interval/detail/sparc_rounding_control.hpp
+-
+boost/numeric/interval/detail/alpha_rounding_control.hpp
+-
+boost/numeric/interval/detail/ia64_rounding_control.hpp
+-
+boost/numeric/interval/detail/c99_rounding_control.hpp
+-
+
+../libraries/boost/numeric/interval/interval.hpp
+stdexcept
+-
+string
+-
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+
+../libraries/boost/numeric/interval/policies.hpp
+boost/numeric/interval/interval.hpp
+-
+
+../libraries/boost/numeric/interval/rounded_arith.hpp
+boost/numeric/interval/rounding.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/numeric/interval/rounded_transc.hpp
+boost/numeric/interval/rounding.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/config/no_tr1/cmath.hpp
+-
+
+../libraries/boost/numeric/interval/rounding.hpp
+
+../libraries/boost/numeric/interval/transc.hpp
+boost/config.hpp
+-
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/rounding.hpp
+-
+boost/numeric/interval/constants.hpp
+-
+boost/numeric/interval/arith.hpp
+-
+boost/numeric/interval/arith2.hpp
+-
+algorithm
+-
+
+../libraries/boost/numeric/interval/utility.hpp
+boost/numeric/interval/utility_fwd.hpp
+-
+boost/numeric/interval/detail/test_input.hpp
+-
+boost/numeric/interval/detail/bugs.hpp
+-
+algorithm
+-
+utility
+-
+
+../libraries/boost/numeric/interval/utility_fwd.hpp
+boost/config.hpp
+-
+boost/numeric/interval/detail/interval_prototype.hpp
+-
+utility
+-
+
+../libraries/boost/numeric/odeint.hpp
+boost/numeric/odeint/version.hpp
+-
+boost/numeric/odeint/config.hpp
+-
+boost/numeric/odeint/util/ublas_wrapper.hpp
+-
+boost/numeric/odeint/stepper/euler.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta4_classic.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta4.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_cash_karp54_classic.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp
+-
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/bulirsch_stoer.hpp
+-
+boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp
+-
+boost/numeric/odeint/stepper/symplectic_euler.hpp
+-
+boost/numeric/odeint/stepper/symplectic_rkn_sb3a_mclachlan.hpp
+-
+boost/numeric/odeint/stepper/velocity_verlet.hpp
+-
+boost/numeric/odeint/stepper/adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/adaptive_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/controlled_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/implicit_euler.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4_controller.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/multi_array_algebra.hpp
+-
+boost/numeric/odeint/util/multi_array_adaption.hpp
+-
+boost/numeric/odeint/integrate/integrate.hpp
+-
+boost/numeric/odeint/integrate/integrate_adaptive.hpp
+-
+boost/numeric/odeint/integrate/integrate_const.hpp
+-
+boost/numeric/odeint/integrate/integrate_n_steps.hpp
+-
+boost/numeric/odeint/integrate/integrate_times.hpp
+-
+boost/numeric/odeint/integrate/observer_collection.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+boost/numeric/odeint/stepper/generation.hpp
+-
+boost/numeric/odeint/iterator/adaptive_iterator.hpp
+-
+boost/numeric/odeint/iterator/adaptive_time_iterator.hpp
+-
+boost/numeric/odeint/iterator/const_step_iterator.hpp
+-
+boost/numeric/odeint/iterator/const_step_time_iterator.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+boost/numeric/odeint/config.hpp
+-
+complex
+-
+boost/type_traits/is_floating_point.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/array_algebra.hpp
+-
+boost/numeric/odeint/algebra/vector_space_algebra.hpp
+-
+boost/array.hpp
+-
+array
+-
+
+../libraries/boost/numeric/odeint/algebra/array_algebra.hpp
+algorithm
+-
+boost/array.hpp
+-
+boost/numeric/odeint/algebra/norm_result_type.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/default_operations.hpp
+algorithm
+-
+boost/config.hpp
+-
+boost/array.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/detail/extract_value_type.hpp
+boost/utility.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/detail/for_each.hpp
+
+../libraries/boost/numeric/odeint/algebra/detail/macros.hpp
+boost/type_traits.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/detail/norm_inf.hpp
+cmath
+-
+
+../libraries/boost/numeric/odeint/algebra/multi_array_algebra.hpp
+boost/multi_array.hpp
+-
+boost/numeric/odeint/algebra/detail/for_each.hpp
+-
+boost/numeric/odeint/algebra/detail/norm_inf.hpp
+-
+boost/numeric/odeint/algebra/norm_result_type.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/norm_result_type.hpp
+boost/numeric/odeint/algebra/detail/extract_value_type.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/operations_dispatcher.hpp
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/range_algebra.hpp
+boost/range.hpp
+-
+boost/mpl/size_t.hpp
+-
+boost/numeric/odeint/algebra/detail/macros.hpp
+-
+boost/numeric/odeint/algebra/detail/for_each.hpp
+-
+boost/numeric/odeint/algebra/detail/norm_inf.hpp
+-
+boost/numeric/odeint/algebra/norm_result_type.hpp
+-
+
+../libraries/boost/numeric/odeint/algebra/vector_space_algebra.hpp
+complex
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/numeric/odeint/config.hpp
+boost/config.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/check_adapter.hpp
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp
+stdexcept
+-
+boost/throw_exception.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_const.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+iostream
+-
+
+../libraries/boost/numeric/odeint/integrate/detail/integrate_const.hpp
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/detail/integrate_n_steps.hpp
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/detail/integrate_times.hpp
+stdexcept
+-
+boost/config.hpp
+-
+boost/throw_exception.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/integrate.hpp
+boost/utility/enable_if.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp
+-
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/integrate/null_observer.hpp
+-
+boost/numeric/odeint/integrate/integrate_adaptive.hpp
+-
+boost/numeric/odeint/algebra/detail/extract_value_type.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/integrate_adaptive.hpp
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/null_observer.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/integrate_const.hpp
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/null_observer.hpp
+-
+boost/numeric/odeint/integrate/check_adapter.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_const.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_adaptive.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/integrate_n_steps.hpp
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/null_observer.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_n_steps.hpp
+-
+boost/numeric/odeint/integrate/check_adapter.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/integrate_times.hpp
+boost/type_traits/is_same.hpp
+-
+boost/range.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/null_observer.hpp
+-
+boost/numeric/odeint/integrate/check_adapter.hpp
+-
+boost/numeric/odeint/integrate/detail/integrate_times.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/max_step_checker.hpp
+stdexcept
+-
+cstdio
+-
+boost/throw_exception.hpp
+-
+boost/numeric/odeint/util/odeint_error.hpp
+-
+
+../libraries/boost/numeric/odeint/integrate/null_observer.hpp
+
+../libraries/boost/numeric/odeint/integrate/observer_collection.hpp
+vector
+-
+boost/function.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/adaptive_iterator.hpp
+boost/numeric/odeint/util/stepper_traits.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/iterator/impl/adaptive_iterator_impl.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/adaptive_time_iterator.hpp
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/stepper_traits.hpp
+-
+boost/numeric/odeint/iterator/impl/adaptive_iterator_impl.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/const_step_iterator.hpp
+boost/numeric/odeint/util/stepper_traits.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/iterator/detail/ode_iterator_base.hpp
+-
+boost/numeric/odeint/iterator/impl/const_step_iterator_impl.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/const_step_time_iterator.hpp
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/stepper_traits.hpp
+-
+boost/numeric/odeint/iterator/detail/ode_iterator_base.hpp
+-
+boost/numeric/odeint/iterator/impl/const_step_iterator_impl.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/detail/ode_iterator_base.hpp
+boost/iterator/iterator_facade.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/impl/adaptive_iterator_impl.hpp
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/throw_exception.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/iterator/detail/ode_iterator_base.hpp
+-
+
+../libraries/boost/numeric/odeint/iterator/impl/const_step_iterator_impl.hpp
+boost/numeric/odeint/iterator/detail/ode_iterator_base.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/adams_bashforth.hpp
+boost/static_assert.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta4.hpp
+-
+boost/numeric/odeint/stepper/extrapolation_stepper.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+boost/numeric/odeint/stepper/detail/adams_bashforth_coefficients.hpp
+-
+boost/numeric/odeint/stepper/detail/adams_bashforth_call_algebra.hpp
+-
+boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/mpl/min_max.hpp
+-
+boost/mpl/equal_to.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/adams_bashforth_moulton.hpp
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/adams_bashforth.hpp
+-
+boost/numeric/odeint/stepper/adams_moulton.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/adams_moulton.hpp
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta4_classic.hpp
+-
+boost/numeric/odeint/stepper/detail/adams_moulton_call_algebra.hpp
+-
+boost/numeric/odeint/stepper/detail/adams_moulton_coefficients.hpp
+-
+boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/adaptive_adams_bashforth_moulton.hpp
+boost/numeric/odeint/stepper/detail/adaptive_adams_coefficients.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+
+../libraries/boost/numeric/odeint/stepper/base/explicit_error_stepper_base.hpp
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/base/explicit_error_stepper_fsal_base.hpp
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/base/symplectic_rkn_stepper_base.hpp
+boost/array.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/is_pair.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/bulirsch_stoer.hpp
+iostream
+-
+algorithm
+-
+boost/config.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/modified_midpoint.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp
+iostream
+-
+algorithm
+-
+boost/config.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/math/special_functions/binomial.hpp
+-
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/modified_midpoint.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+boost/type_traits.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/controlled_adams_bashforth_moulton.hpp
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/stepper/adaptive_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/detail/pid_step_adjuster.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+iostream
+-
+
+../libraries/boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+cmath
+-
+boost/config.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/controlled_step_result.hpp
+
+../libraries/boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp
+utility
+-
+stdexcept
+-
+boost/throw_exception.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/adams_bashforth_call_algebra.hpp
+boost/assert.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/adams_bashforth_coefficients.hpp
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/adams_moulton_call_algebra.hpp
+boost/assert.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/adams_moulton_coefficients.hpp
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/adaptive_adams_coefficients.hpp
+boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/generic_rk_algorithm.hpp
+boost/static_assert.hpp
+-
+boost/mpl/vector.hpp
+-
+boost/mpl/push_back.hpp
+-
+boost/mpl/for_each.hpp
+-
+boost/mpl/range_c.hpp
+-
+boost/mpl/copy.hpp
+-
+boost/mpl/size_t.hpp
+-
+boost/fusion/algorithm.hpp
+-
+boost/fusion/iterator.hpp
+-
+boost/fusion/mpl.hpp
+-
+boost/fusion/sequence.hpp
+-
+boost/array.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_call_algebra.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_operations.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/generic_rk_call_algebra.hpp
+
+../libraries/boost/numeric/odeint/stepper/detail/generic_rk_operations.hpp
+
+../libraries/boost/numeric/odeint/stepper/detail/pid_step_adjuster.hpp
+boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+-
+boost/numeric/odeint/stepper/detail/pid_step_adjuster_coefficients.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+math.h
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/pid_step_adjuster_coefficients.hpp
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/detail/rotating_buffer.hpp
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/euler.hpp
+boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/explicit_error_generic_rk.hpp
+boost/numeric/odeint/stepper/base/explicit_error_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_algorithm.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_call_algebra.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_operations.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/explicit_generic_rk.hpp
+boost/array.hpp
+-
+boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/stepper/detail/generic_rk_algorithm.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/extrapolation_stepper.hpp
+iostream
+-
+algorithm
+-
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/base/explicit_error_stepper_base.hpp
+-
+boost/numeric/odeint/stepper/modified_midpoint.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation.hpp
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+boost/numeric/odeint/stepper/generation/make_dense_output.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_dense_output_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_runge_kutta_cash_karp54_classic.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_runge_kutta_cash_karp54.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_runge_kutta_dopri5.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_runge_kutta_fehlberg78.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_controlled_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/generation/generation_rosenbrock4.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_controlled_adams_bashforth_moulton.hpp
+boost/numeric/odeint/stepper/adaptive_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/controlled_adams_bashforth_moulton.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_controlled_runge_kutta.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_dense_output_runge_kutta.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/generation/make_dense_output.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_rosenbrock4.hpp
+boost/numeric/odeint/stepper/rosenbrock4.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4_controller.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_runge_kutta_cash_karp54.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_runge_kutta_cash_karp54_classic.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_cash_karp54_classic.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_runge_kutta_dopri5.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/dense_output_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+boost/numeric/odeint/stepper/generation/make_dense_output.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/generation_runge_kutta_fehlberg78.hpp
+boost/numeric/odeint/stepper/controlled_runge_kutta.hpp
+-
+boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp
+-
+boost/numeric/odeint/stepper/generation/make_controlled.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/generation/make_controlled.hpp
+
+../libraries/boost/numeric/odeint/stepper/generation/make_dense_output.hpp
+
+../libraries/boost/numeric/odeint/stepper/implicit_euler.hpp
+utility
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/ublas_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/ublas/lu.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/modified_midpoint.hpp
+vector
+-
+boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/rosenbrock4.hpp
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/ublas/lu.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/ublas_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/ublas/lu.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/rosenbrock4_controller.hpp
+boost/config.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/stepper/controlled_step_result.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/detail/less_with_sign.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/rosenbrock4_dense_output.hpp
+utility
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/stepper/rosenbrock4_controller.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/integrate/max_step_checker.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta4.hpp
+boost/fusion/container/vector.hpp
+-
+boost/fusion/container/generation/make_vector.hpp
+-
+boost/numeric/odeint/stepper/explicit_generic_rk.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/array.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta4_classic.hpp
+boost/numeric/odeint/stepper/base/explicit_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta_cash_karp54.hpp
+boost/fusion/container/vector.hpp
+-
+boost/fusion/container/generation/make_vector.hpp
+-
+boost/numeric/odeint/stepper/explicit_error_generic_rk.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta_cash_karp54_classic.hpp
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/stepper/base/explicit_error_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta_dopri5.hpp
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/stepper/base/explicit_error_stepper_fsal_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/same_instance.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/runge_kutta_fehlberg78.hpp
+boost/fusion/container/vector.hpp
+-
+boost/fusion/container/generation/make_vector.hpp
+-
+boost/numeric/odeint/stepper/explicit_error_generic_rk.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/array.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/stepper_categories.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/symplectic_euler.hpp
+boost/numeric/odeint/stepper/base/symplectic_rkn_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/symplectic_rkn_sb3a_mclachlan.hpp
+boost/numeric/odeint/stepper/base/symplectic_rkn_stepper_base.hpp
+-
+boost/numeric/odeint/algebra/range_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/array.hpp
+-
+
+../libraries/boost/numeric/odeint/stepper/velocity_verlet.hpp
+boost/numeric/odeint/stepper/base/algebra_stepper_base.hpp
+-
+boost/numeric/odeint/stepper/stepper_categories.hpp
+-
+boost/numeric/odeint/algebra/algebra_dispatcher.hpp
+-
+boost/numeric/odeint/algebra/operations_dispatcher.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+boost/numeric/odeint/util/bind.hpp
+-
+boost/numeric/odeint/util/copy.hpp
+-
+boost/numeric/odeint/util/resizer.hpp
+-
+
+../libraries/boost/numeric/odeint/util/bind.hpp
+boost/numeric/odeint/config.hpp
+-
+functional
+-
+boost/bind.hpp
+-
+boost/bind.hpp
+-
+functional
+-
+
+../libraries/boost/numeric/odeint/util/copy.hpp
+boost/range/algorithm/copy.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/numeric/odeint/util/detail/is_range.hpp
+-
+
+../libraries/boost/numeric/odeint/util/detail/is_range.hpp
+cstddef
+-
+boost/range/config.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/and.hpp
+-
+
+../libraries/boost/numeric/odeint/util/detail/less_with_sign.hpp
+limits
+-
+boost/numeric/odeint/util/unit_helper.hpp
+-
+
+../libraries/boost/numeric/odeint/util/is_pair.hpp
+boost/mpl/bool.hpp
+-
+utility
+-
+
+../libraries/boost/numeric/odeint/util/is_resizeable.hpp
+vector
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/fusion/include/front.hpp
+-
+boost/fusion/include/is_sequence.hpp
+-
+boost/mpl/find_if.hpp
+-
+boost/mpl/end.hpp
+-
+boost/mpl/placeholders.hpp
+-
+boost/mpl/if.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/numeric/odeint/util/multi_array_adaption.hpp
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resize.hpp
+-
+boost/numeric/odeint/util/same_size.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/multi_array.hpp
+-
+
+../libraries/boost/numeric/odeint/util/odeint_error.hpp
+stdexcept
+-
+string
+-
+
+../libraries/boost/numeric/odeint/util/resize.hpp
+boost/range.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/include/is_sequence.hpp
+-
+boost/fusion/include/zip_view.hpp
+-
+boost/fusion/include/vector.hpp
+-
+boost/fusion/include/make_fused.hpp
+-
+boost/fusion/include/for_each.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+
+../libraries/boost/numeric/odeint/util/resizer.hpp
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/same_size.hpp
+-
+boost/numeric/odeint/util/resize.hpp
+-
+
+../libraries/boost/numeric/odeint/util/same_instance.hpp
+
+../libraries/boost/numeric/odeint/util/same_size.hpp
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/fusion/include/is_sequence.hpp
+-
+boost/fusion/include/zip_view.hpp
+-
+boost/fusion/include/vector.hpp
+-
+boost/fusion/include/make_fused.hpp
+-
+boost/fusion/include/all.hpp
+-
+boost/range.hpp
+-
+
+../libraries/boost/numeric/odeint/util/state_wrapper.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/resize.hpp
+-
+boost/numeric/odeint/util/same_size.hpp
+-
+
+../libraries/boost/numeric/odeint/util/stepper_traits.hpp
+boost/numeric/odeint/util/unwrap_reference.hpp
+-
+
+../libraries/boost/numeric/odeint/util/ublas_wrapper.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/ublas/lu.hpp
+-
+boost/numeric/ublas/vector_expression.hpp
+-
+boost/numeric/ublas/matrix_expression.hpp
+-
+boost/numeric/odeint/algebra/vector_space_algebra.hpp
+-
+boost/numeric/odeint/algebra/default_operations.hpp
+-
+boost/numeric/odeint/util/is_resizeable.hpp
+-
+boost/numeric/odeint/util/state_wrapper.hpp
+-
+
+../libraries/boost/numeric/odeint/util/unit_helper.hpp
+boost/units/quantity.hpp
+-
+boost/units/get_dimension.hpp
+-
+boost/units/get_system.hpp
+-
+
+../libraries/boost/numeric/odeint/util/unwrap_reference.hpp
+boost/numeric/odeint/config.hpp
+-
+functional
+-
+boost/ref.hpp
+-
+boost/config.hpp
+-
+boost/ref.hpp
+-
+functional
+-
+
+../libraries/boost/numeric/odeint/version.hpp
+string
+-
+sstream
+-
+
+../libraries/boost/numeric/ublas/detail/config.hpp
+cassert
+-
+cstddef
+-
+algorithm
+-
+limits
+-
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/noncopyable.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/and.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+cstdlib
+-
+cstdlib
+-
+boost/numeric/ublas/fwd.hpp
+-
+boost/numeric/ublas/detail/definitions.hpp
+-
+
+../libraries/boost/numeric/ublas/detail/definitions.hpp
+
+../libraries/boost/numeric/ublas/detail/duff.hpp
+
+../libraries/boost/numeric/ublas/detail/iterator.hpp
+boost/numeric/ublas/exception.hpp
+-
+iterator
+-
+
+../libraries/boost/numeric/ublas/detail/matrix_assign.hpp
+boost/numeric/ublas/traits.hpp
+-
+vector
+-
+
+../libraries/boost/numeric/ublas/detail/raw.hpp
+
+../libraries/boost/numeric/ublas/detail/returntype_deduction.hpp
+boost/mpl/vector/vector20.hpp
+-
+boost/mpl/at.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/numeric/ublas/detail/temporary.hpp
+
+../libraries/boost/numeric/ublas/detail/vector_assign.hpp
+boost/numeric/ublas/functional.hpp
+-
+vector
+-
+
+../libraries/boost/numeric/ublas/exception.hpp
+stdexcept
+-
+cstdlib
+-
+iostream
+-
+boost/numeric/ublas/detail/config.hpp
+-
+
+../libraries/boost/numeric/ublas/expression_types.hpp
+boost/numeric/ublas/exception.hpp
+-
+boost/numeric/ublas/traits.hpp
+-
+boost/numeric/ublas/functional.hpp
+-
+
+../libraries/boost/numeric/ublas/functional.hpp
+functional
+-
+boost/core/ignore_unused.hpp
+-
+boost/numeric/ublas/traits.hpp
+-
+boost/numeric/ublas/detail/duff.hpp
+-
+boost/numeric/ublas/detail/raw.hpp
+-
+boost/numeric/bindings/traits/std_vector.hpp
+-
+boost/numeric/bindings/traits/ublas_vector.hpp
+-
+boost/numeric/bindings/traits/ublas_matrix.hpp
+-
+boost/numeric/bindings/atlas/cblas.hpp
+-
+boost/numeric/ublas/detail/definitions.hpp
+-
+
+../libraries/boost/numeric/ublas/fwd.hpp
+memory
+-
+array
+-
+
+../libraries/boost/numeric/ublas/lu.hpp
+boost/numeric/ublas/operation.hpp
+-
+boost/numeric/ublas/vector_proxy.hpp
+-
+boost/numeric/ublas/matrix_proxy.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/triangular.hpp
+-
+
+../libraries/boost/numeric/ublas/matrix.hpp
+boost/config.hpp
+-
+boost/numeric/ublas/vector.hpp
+-
+boost/numeric/ublas/matrix_expression.hpp
+-
+boost/numeric/ublas/detail/matrix_assign.hpp
+-
+boost/serialization/collection_size_type.hpp
+-
+boost/serialization/array.hpp
+-
+boost/serialization/nvp.hpp
+-
+
+../libraries/boost/numeric/ublas/matrix_expression.hpp
+boost/numeric/ublas/vector_expression.hpp
+-
+
+../libraries/boost/numeric/ublas/matrix_proxy.hpp
+boost/numeric/ublas/matrix_expression.hpp
+-
+boost/numeric/ublas/detail/vector_assign.hpp
+-
+boost/numeric/ublas/detail/matrix_assign.hpp
+-
+boost/numeric/ublas/detail/temporary.hpp
+-
+
+../libraries/boost/numeric/ublas/operation.hpp
+boost/numeric/ublas/matrix_proxy.hpp
+-
+
+../libraries/boost/numeric/ublas/storage.hpp
+algorithm
+-
+boost/shared_array.hpp
+-
+boost/core/allocator_access.hpp
+-
+boost/serialization/array.hpp
+-
+boost/serialization/collection_size_type.hpp
+-
+boost/serialization/nvp.hpp
+-
+boost/numeric/ublas/exception.hpp
+-
+boost/numeric/ublas/traits.hpp
+-
+boost/numeric/ublas/detail/iterator.hpp
+-
+
+../libraries/boost/numeric/ublas/traits.hpp
+iterator
+-
+complex
+-
+boost/config/no_tr1/cmath.hpp
+-
+boost/numeric/ublas/detail/config.hpp
+-
+boost/numeric/ublas/detail/iterator.hpp
+-
+boost/numeric/ublas/detail/returntype_deduction.hpp
+-
+boost/numeric/interval.hpp
+-
+boost/type_traits.hpp
+-
+complex
+-
+boost/typeof/typeof.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_float.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_unsigned.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/if.hpp
+-
+boost/typeof/typeof.hpp
+-
+
+../libraries/boost/numeric/ublas/triangular.hpp
+boost/numeric/ublas/matrix.hpp
+-
+boost/numeric/ublas/detail/temporary.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/numeric/ublas/vector.hpp
+boost/config.hpp
+-
+boost/numeric/ublas/storage.hpp
+-
+boost/numeric/ublas/vector_expression.hpp
+-
+boost/numeric/ublas/detail/vector_assign.hpp
+-
+boost/serialization/collection_size_type.hpp
+-
+boost/serialization/nvp.hpp
+-
+array
+-
+initializer_list
+-
+utility
+-
+
+../libraries/boost/numeric/ublas/vector_expression.hpp
+boost/numeric/ublas/expression_types.hpp
+-
+
+../libraries/boost/numeric/ublas/vector_proxy.hpp
+boost/numeric/ublas/vector_expression.hpp
+-
+boost/numeric/ublas/detail/vector_assign.hpp
+-
+boost/numeric/ublas/detail/temporary.hpp
+-
+
+../libraries/boost/operators.hpp
+operators_v1.hpp
+../libraries/boost/operators_v1.hpp
+cstddef
+-
+iterator
+-
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/core/addressof.hpp
+-
+
+../libraries/boost/operators_v1.hpp
+cstddef
+-
+iterator
+-
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/predef/architecture.h
+boost/predef/architecture/alpha.h
+-
+boost/predef/architecture/arm.h
+-
+boost/predef/architecture/blackfin.h
+-
+boost/predef/architecture/convex.h
+-
+boost/predef/architecture/e2k.h
+-
+boost/predef/architecture/ia64.h
+-
+boost/predef/architecture/m68k.h
+-
+boost/predef/architecture/mips.h
+-
+boost/predef/architecture/parisc.h
+-
+boost/predef/architecture/ppc.h
+-
+boost/predef/architecture/ptx.h
+-
+boost/predef/architecture/pyramid.h
+-
+boost/predef/architecture/riscv.h
+-
+boost/predef/architecture/rs6k.h
+-
+boost/predef/architecture/sparc.h
+-
+boost/predef/architecture/superh.h
+-
+boost/predef/architecture/sys370.h
+-
+boost/predef/architecture/sys390.h
+-
+boost/predef/architecture/x86.h
+-
+boost/predef/architecture/z.h
+-
+
+../libraries/boost/predef/architecture/alpha.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/arm.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/blackfin.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/convex.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/e2k.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/ia64.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/m68k.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/mips.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/parisc.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/ppc.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/ptx.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/pyramid.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/riscv.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/rs6k.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/sparc.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/superh.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/sys370.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/sys390.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/x86.h
+boost/predef/architecture/x86/32.h
+-
+boost/predef/architecture/x86/64.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/x86/32.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/architecture/x86.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/x86/64.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/architecture/x86.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/architecture/z.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/detail/_cassert.h
+cassert
+-
+assert.h
+-
+
+../libraries/boost/predef/detail/os_detected.h
+
+../libraries/boost/predef/detail/platform_detected.h
+
+../libraries/boost/predef/detail/test.h
+
+../libraries/boost/predef/library/c/_prefix.h
+boost/predef/detail/_cassert.h
+-
+
+../libraries/boost/predef/library/c/gnu.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/library/c/_prefix.h
+-
+stddef.h
+-
+cstddef
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/make.h
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd.h
+boost/predef/os/macos.h
+-
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/os/bsd/bsdi.h
+-
+boost/predef/os/bsd/dragonfly.h
+-
+boost/predef/os/bsd/free.h
+-
+boost/predef/os/bsd/open.h
+-
+boost/predef/os/bsd/net.h
+-
+sys/param.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/os/bsd/bsdi.h
+-
+boost/predef/os/bsd/dragonfly.h
+-
+boost/predef/os/bsd/free.h
+-
+boost/predef/os/bsd/open.h
+-
+boost/predef/os/bsd/net.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd/bsdi.h
+boost/predef/os/bsd.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd/dragonfly.h
+boost/predef/os/bsd.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd/free.h
+boost/predef/os/bsd.h
+-
+sys/param.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd/net.h
+boost/predef/os/bsd.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/bsd/open.h
+boost/predef/os/bsd.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/ios.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/macos.h
+boost/predef/os/ios.h
+-
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/os/windows.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/os_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/other/endian.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/library/c/gnu.h
+-
+boost/predef/os/macos.h
+-
+boost/predef/os/bsd.h
+-
+boost/predef/platform/android.h
+-
+endian.h
+-
+machine/endian.h
+-
+sys/endian.h
+-
+boost/predef/architecture.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform.h
+boost/predef/platform/android.h
+-
+boost/predef/platform/cloudabi.h
+-
+boost/predef/platform/mingw.h
+-
+boost/predef/platform/mingw32.h
+-
+boost/predef/platform/mingw64.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/platform/windows_desktop.h
+-
+boost/predef/platform/windows_phone.h
+-
+boost/predef/platform/windows_server.h
+-
+boost/predef/platform/windows_store.h
+-
+boost/predef/platform/windows_system.h
+-
+boost/predef/platform/windows_runtime.h
+-
+boost/predef/platform/ios.h
+-
+
+../libraries/boost/predef/platform/android.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/cloudabi.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/ios.h
+boost/predef/os/ios.h
+-
+boost/predef/version_number.h
+-
+TargetConditionals.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/mingw.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+_mingw.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/mingw32.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+_mingw.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/mingw64.h
+boost/predef/version_number.h
+-
+boost/predef/make.h
+-
+_mingw.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_desktop.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_phone.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_runtime.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_phone.h
+-
+boost/predef/platform/windows_store.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_server.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_store.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_system.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/platform/windows_uwp.h
+-
+boost/predef/version_number.h
+-
+boost/predef/detail/platform_detected.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/platform/windows_uwp.h
+boost/predef/make.h
+-
+boost/predef/os/windows.h
+-
+boost/predef/version_number.h
+-
+ntverp.h
+-
+boost/predef/detail/platform_detected.h
+-
+winapifamily.h
+-
+boost/predef/detail/test.h
+-
+
+../libraries/boost/predef/version_number.h
+
+../libraries/boost/preprocessor/arithmetic/add.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+boost/preprocessor/logical/bitor.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/logical/compl.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/detail/is_maximum_number.hpp
+-
+boost/preprocessor/arithmetic/detail/is_minimum_number.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/dec.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_256.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_256.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_512.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_256.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_512.hpp
+-
+boost/preprocessor/arithmetic/limits/dec_1024.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/detail/div_base.hpp
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/comparison/less_equal.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/detail/is_1_number.hpp
+boost/preprocessor/comparison/equal.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/detail/is_maximum_number.hpp
+boost/preprocessor/comparison/equal.hpp
+-
+boost/preprocessor/arithmetic/detail/maximum_number.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/detail/is_minimum_number.hpp
+boost/preprocessor/logical/not.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/detail/maximum_number.hpp
+boost/preprocessor/config/limits.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/inc.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_256.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_256.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_512.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_256.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_512.hpp
+-
+boost/preprocessor/arithmetic/limits/inc_1024.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/limits/dec_1024.hpp
+
+../libraries/boost/preprocessor/arithmetic/limits/dec_256.hpp
+
+../libraries/boost/preprocessor/arithmetic/limits/dec_512.hpp
+
+../libraries/boost/preprocessor/arithmetic/limits/inc_1024.hpp
+
+../libraries/boost/preprocessor/arithmetic/limits/inc_256.hpp
+
+../libraries/boost/preprocessor/arithmetic/limits/inc_512.hpp
+
+../libraries/boost/preprocessor/arithmetic/mod.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/arithmetic/detail/div_base.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/detail/div_base.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/detail/is_1_number.hpp
+-
+
+../libraries/boost/preprocessor/arithmetic/sub.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/logical/and.hpp
+-
+boost/preprocessor/logical/bitor.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/arithmetic/detail/is_maximum_number.hpp
+-
+boost/preprocessor/arithmetic/detail/is_minimum_number.hpp
+-
+
+../libraries/boost/preprocessor/array/data.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/array/elem.hpp
+boost/preprocessor/array/data.hpp
+-
+boost/preprocessor/array/size.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/array/size.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/cat.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/comma_if.hpp
+boost/preprocessor/punctuation/comma_if.hpp
+-
+
+../libraries/boost/preprocessor/comparison/equal.hpp
+boost/preprocessor/comparison/not_equal.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/logical/compl.hpp
+-
+
+../libraries/boost/preprocessor/comparison/less.hpp
+boost/preprocessor/comparison/less_equal.hpp
+-
+boost/preprocessor/comparison/not_equal.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/comparison/less_equal.hpp
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/logical/not.hpp
+-
+
+../libraries/boost/preprocessor/comparison/limits/not_equal_1024.hpp
+
+../libraries/boost/preprocessor/comparison/limits/not_equal_256.hpp
+
+../libraries/boost/preprocessor/comparison/limits/not_equal_512.hpp
+
+../libraries/boost/preprocessor/comparison/not_equal.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_256.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_256.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_512.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_256.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_512.hpp
+-
+boost/preprocessor/comparison/limits/not_equal_1024.hpp
+-
+
+../libraries/boost/preprocessor/config/config.hpp
+
+../libraries/boost/preprocessor/config/limits.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/control/deduce_d.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+
+../libraries/boost/preprocessor/control/detail/dmc/while.hpp
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/control/detail/edg/limits/while_1024.hpp
+
+../libraries/boost/preprocessor/control/detail/edg/limits/while_256.hpp
+
+../libraries/boost/preprocessor/control/detail/edg/limits/while_512.hpp
+
+../libraries/boost/preprocessor/control/detail/edg/while.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_512.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_512.hpp
+-
+boost/preprocessor/control/detail/edg/limits/while_1024.hpp
+-
+
+../libraries/boost/preprocessor/control/detail/limits/while_1024.hpp
+
+../libraries/boost/preprocessor/control/detail/limits/while_256.hpp
+
+../libraries/boost/preprocessor/control/detail/limits/while_512.hpp
+
+../libraries/boost/preprocessor/control/detail/msvc/while.hpp
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/control/detail/while.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/control/detail/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/limits/while_512.hpp
+-
+boost/preprocessor/control/detail/limits/while_256.hpp
+-
+boost/preprocessor/control/detail/limits/while_512.hpp
+-
+boost/preprocessor/control/detail/limits/while_1024.hpp
+-
+
+../libraries/boost/preprocessor/control/expr_if.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+
+../libraries/boost/preprocessor/control/expr_iif.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/control/if.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+
+../libraries/boost/preprocessor/control/iif.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/control/limits/while_1024.hpp
+
+../libraries/boost/preprocessor/control/limits/while_256.hpp
+
+../libraries/boost/preprocessor/control/limits/while_512.hpp
+
+../libraries/boost/preprocessor/control/while.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+boost/preprocessor/list/fold_right.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+boost/preprocessor/control/detail/edg/while.hpp
+-
+boost/preprocessor/control/detail/msvc/while.hpp
+-
+boost/preprocessor/control/detail/dmc/while.hpp
+-
+boost/preprocessor/control/detail/while.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+boost/preprocessor/list/fold_right.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/control/detail/edg/while.hpp
+-
+boost/preprocessor/control/detail/msvc/while.hpp
+-
+boost/preprocessor/control/detail/dmc/while.hpp
+-
+boost/preprocessor/control/detail/while.hpp
+-
+boost/preprocessor/control/limits/while_256.hpp
+-
+boost/preprocessor/control/limits/while_256.hpp
+-
+boost/preprocessor/control/limits/while_512.hpp
+-
+boost/preprocessor/control/limits/while_256.hpp
+-
+boost/preprocessor/control/limits/while_512.hpp
+-
+boost/preprocessor/control/limits/while_1024.hpp
+-
+
+../libraries/boost/preprocessor/debug/error.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/dec.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+
+../libraries/boost/preprocessor/detail/auto_rec.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/detail/dmc/auto_rec.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/detail/dmc/auto_rec.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_256.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_256.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_512.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_256.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_512.hpp
+-
+boost/preprocessor/detail/limits/auto_rec_1024.hpp
+-
+
+../libraries/boost/preprocessor/detail/check.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/detail/dmc/auto_rec.hpp
+boost/preprocessor/control/iif.hpp
+-
+
+../libraries/boost/preprocessor/detail/is_binary.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/detail/check.hpp
+-
+
+../libraries/boost/preprocessor/detail/is_unary.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/detail/check.hpp
+-
+
+../libraries/boost/preprocessor/detail/limits/auto_rec_1024.hpp
+
+../libraries/boost/preprocessor/detail/limits/auto_rec_256.hpp
+
+../libraries/boost/preprocessor/detail/limits/auto_rec_512.hpp
+
+../libraries/boost/preprocessor/empty.hpp
+boost/preprocessor/facilities/empty.hpp
+-
+
+../libraries/boost/preprocessor/enum.hpp
+boost/preprocessor/repetition/enum.hpp
+-
+
+../libraries/boost/preprocessor/enum_params.hpp
+boost/preprocessor/repetition/enum_params.hpp
+-
+
+../libraries/boost/preprocessor/enum_params_with_a_default.hpp
+boost/preprocessor/repetition/enum_params_with_a_default.hpp
+-
+
+../libraries/boost/preprocessor/enum_shifted_params.hpp
+boost/preprocessor/repetition/enum_shifted_params.hpp
+-
+
+../libraries/boost/preprocessor/expr_if.hpp
+boost/preprocessor/control/expr_if.hpp
+-
+
+../libraries/boost/preprocessor/facilities/check_empty.hpp
+boost/preprocessor/variadic/has_opt.hpp
+-
+boost/preprocessor/facilities/is_empty_variadic.hpp
+-
+
+../libraries/boost/preprocessor/facilities/detail/is_empty.hpp
+boost/preprocessor/punctuation/is_begin_parens.hpp
+-
+
+../libraries/boost/preprocessor/facilities/empty.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/facilities/expand.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/facilities/identity.hpp
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/facilities/intercept.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/facilities/limits/intercept_256.hpp
+-
+boost/preprocessor/facilities/limits/intercept_256.hpp
+-
+boost/preprocessor/facilities/limits/intercept_512.hpp
+-
+boost/preprocessor/facilities/limits/intercept_256.hpp
+-
+boost/preprocessor/facilities/limits/intercept_512.hpp
+-
+boost/preprocessor/facilities/limits/intercept_1024.hpp
+-
+
+../libraries/boost/preprocessor/facilities/is_1.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/facilities/is_empty.hpp
+-
+
+../libraries/boost/preprocessor/facilities/is_empty.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/facilities/is_empty_variadic.hpp
+-
+
+../libraries/boost/preprocessor/facilities/is_empty_variadic.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/punctuation/is_begin_parens.hpp
+-
+boost/preprocessor/facilities/detail/is_empty.hpp
+-
+boost/preprocessor/variadic/has_opt.hpp
+-
+
+../libraries/boost/preprocessor/facilities/limits/intercept_1024.hpp
+
+../libraries/boost/preprocessor/facilities/limits/intercept_256.hpp
+
+../libraries/boost/preprocessor/facilities/limits/intercept_512.hpp
+
+../libraries/boost/preprocessor/facilities/overload.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/variadic/size.hpp
+-
+
+../libraries/boost/preprocessor/identity.hpp
+boost/preprocessor/facilities/identity.hpp
+-
+
+../libraries/boost/preprocessor/if.hpp
+boost/preprocessor/control/if.hpp
+-
+
+../libraries/boost/preprocessor/inc.hpp
+boost/preprocessor/arithmetic/inc.hpp
+-
+
+../libraries/boost/preprocessor/iterate.hpp
+boost/preprocessor/iteration/iterate.hpp
+-
+
+../libraries/boost/preprocessor/iteration/iterate.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/array/elem.hpp
+-
+boost/preprocessor/array/size.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/slot/slot.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/iteration/local.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/slot/slot.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/iteration/self.hpp
+
+../libraries/boost/preprocessor/list/adt.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/detail/is_binary.hpp
+-
+boost/preprocessor/logical/compl.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/dmc/fold_left.hpp
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/edg/fold_left.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_left_1024.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/edg/fold_right.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_512.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_512.hpp
+-
+boost/preprocessor/list/detail/edg/limits/fold_right_1024.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_left_1024.hpp
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_left_256.hpp
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_left_512.hpp
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_right_1024.hpp
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_right_256.hpp
+
+../libraries/boost/preprocessor/list/detail/edg/limits/fold_right_512.hpp
+
+../libraries/boost/preprocessor/list/detail/fold_left.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/detail/limits/fold_left_1024.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/fold_right.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+boost/preprocessor/list/reverse.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+boost/preprocessor/list/reverse.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_512.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_256.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_512.hpp
+-
+boost/preprocessor/list/detail/limits/fold_right_1024.hpp
+-
+
+../libraries/boost/preprocessor/list/detail/limits/fold_left_1024.hpp
+
+../libraries/boost/preprocessor/list/detail/limits/fold_left_256.hpp
+
+../libraries/boost/preprocessor/list/detail/limits/fold_left_512.hpp
+
+../libraries/boost/preprocessor/list/detail/limits/fold_right_1024.hpp
+
+../libraries/boost/preprocessor/list/detail/limits/fold_right_256.hpp
+
+../libraries/boost/preprocessor/list/detail/limits/fold_right_512.hpp
+
+../libraries/boost/preprocessor/list/fold_left.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/list/detail/edg/fold_left.hpp
+-
+boost/preprocessor/list/detail/dmc/fold_left.hpp
+-
+boost/preprocessor/list/detail/fold_left.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/edg/fold_left.hpp
+-
+boost/preprocessor/list/detail/dmc/fold_left.hpp
+-
+boost/preprocessor/list/detail/fold_left.hpp
+-
+boost/preprocessor/list/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/limits/fold_left_256.hpp
+-
+boost/preprocessor/list/limits/fold_left_512.hpp
+-
+boost/preprocessor/list/limits/fold_left_1024.hpp
+-
+
+../libraries/boost/preprocessor/list/fold_right.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/list/detail/edg/fold_right.hpp
+-
+boost/preprocessor/list/detail/fold_right.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/list/detail/edg/fold_right.hpp
+-
+boost/preprocessor/list/detail/fold_right.hpp
+-
+
+../libraries/boost/preprocessor/list/for_each_i.hpp
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/repetition/for.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/list/limits/fold_left_1024.hpp
+
+../libraries/boost/preprocessor/list/limits/fold_left_256.hpp
+
+../libraries/boost/preprocessor/list/limits/fold_left_512.hpp
+
+../libraries/boost/preprocessor/list/reverse.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/list/adt.hpp
+-
+boost/preprocessor/list/fold_left.hpp
+-
+
+../libraries/boost/preprocessor/logical/and.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+
+../libraries/boost/preprocessor/logical/bitand.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/logical/bitor.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/logical/bool.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/logical/limits/bool_256.hpp
+-
+boost/preprocessor/logical/limits/bool_256.hpp
+-
+boost/preprocessor/logical/limits/bool_512.hpp
+-
+boost/preprocessor/logical/limits/bool_256.hpp
+-
+boost/preprocessor/logical/limits/bool_512.hpp
+-
+boost/preprocessor/logical/limits/bool_1024.hpp
+-
+
+../libraries/boost/preprocessor/logical/compl.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/logical/limits/bool_1024.hpp
+
+../libraries/boost/preprocessor/logical/limits/bool_256.hpp
+
+../libraries/boost/preprocessor/logical/limits/bool_512.hpp
+
+../libraries/boost/preprocessor/logical/not.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/logical/compl.hpp
+-
+
+../libraries/boost/preprocessor/logical/or.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/logical/bitor.hpp
+-
+
+../libraries/boost/preprocessor/punctuation/comma.hpp
+
+../libraries/boost/preprocessor/punctuation/comma_if.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/punctuation/comma.hpp
+-
+
+../libraries/boost/preprocessor/punctuation/detail/is_begin_parens.hpp
+boost/preprocessor/facilities/empty.hpp
+-
+
+../libraries/boost/preprocessor/punctuation/is_begin_parens.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/punctuation/detail/is_begin_parens.hpp
+-
+
+../libraries/boost/preprocessor/punctuation/paren.hpp
+
+../libraries/boost/preprocessor/repeat.hpp
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/preprocessor/repeat_from_to.hpp
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+
+../libraries/boost/preprocessor/repetition/detail/dmc/for.hpp
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/repetition/detail/edg/for.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_512.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_512.hpp
+-
+boost/preprocessor/repetition/detail/edg/limits/for_1024.hpp
+-
+
+../libraries/boost/preprocessor/repetition/detail/edg/limits/for_1024.hpp
+
+../libraries/boost/preprocessor/repetition/detail/edg/limits/for_256.hpp
+
+../libraries/boost/preprocessor/repetition/detail/edg/limits/for_512.hpp
+
+../libraries/boost/preprocessor/repetition/detail/for.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_512.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_256.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_512.hpp
+-
+boost/preprocessor/repetition/detail/limits/for_1024.hpp
+-
+
+../libraries/boost/preprocessor/repetition/detail/limits/for_1024.hpp
+
+../libraries/boost/preprocessor/repetition/detail/limits/for_256.hpp
+
+../libraries/boost/preprocessor/repetition/detail/limits/for_512.hpp
+
+../libraries/boost/preprocessor/repetition/detail/msvc/for.hpp
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/punctuation/comma_if.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_binary_params.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/punctuation/comma_if.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_params.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/punctuation/comma_if.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_params_with_a_default.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/facilities/intercept.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_shifted.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/punctuation/comma_if.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_shifted_params.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/punctuation/comma_if.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_trailing.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/repetition/enum_trailing_params.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/preprocessor/repetition/for.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/repetition/detail/edg/for.hpp
+-
+boost/preprocessor/repetition/detail/msvc/for.hpp
+-
+boost/preprocessor/repetition/detail/dmc/for.hpp
+-
+boost/preprocessor/repetition/detail/for.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/repetition/detail/edg/for.hpp
+-
+boost/preprocessor/repetition/detail/msvc/for.hpp
+-
+boost/preprocessor/repetition/detail/dmc/for.hpp
+-
+boost/preprocessor/repetition/detail/for.hpp
+-
+boost/preprocessor/repetition/limits/for_256.hpp
+-
+boost/preprocessor/repetition/limits/for_256.hpp
+-
+boost/preprocessor/repetition/limits/for_512.hpp
+-
+boost/preprocessor/repetition/limits/for_256.hpp
+-
+boost/preprocessor/repetition/limits/for_512.hpp
+-
+boost/preprocessor/repetition/limits/for_1024.hpp
+-
+
+../libraries/boost/preprocessor/repetition/limits/for_1024.hpp
+
+../libraries/boost/preprocessor/repetition/limits/for_256.hpp
+
+../libraries/boost/preprocessor/repetition/limits/for_512.hpp
+
+../libraries/boost/preprocessor/repetition/limits/repeat_1024.hpp
+
+../libraries/boost/preprocessor/repetition/limits/repeat_256.hpp
+
+../libraries/boost/preprocessor/repetition/limits/repeat_512.hpp
+
+../libraries/boost/preprocessor/repetition/repeat.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/repetition/limits/repeat_256.hpp
+-
+boost/preprocessor/repetition/limits/repeat_256.hpp
+-
+boost/preprocessor/repetition/limits/repeat_512.hpp
+-
+boost/preprocessor/repetition/limits/repeat_256.hpp
+-
+boost/preprocessor/repetition/limits/repeat_512.hpp
+-
+boost/preprocessor/repetition/limits/repeat_1024.hpp
+-
+
+../libraries/boost/preprocessor/repetition/repeat_from_to.hpp
+boost/preprocessor/arithmetic/add.hpp
+-
+boost/preprocessor/arithmetic/sub.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+
+../libraries/boost/preprocessor/seq/cat.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/seq/fold_left.hpp
+-
+boost/preprocessor/seq/seq.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+
+../libraries/boost/preprocessor/seq/detail/is_empty.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/logical/bool.hpp
+-
+boost/preprocessor/logical/compl.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+
+../libraries/boost/preprocessor/seq/detail/limits/split_1024.hpp
+
+../libraries/boost/preprocessor/seq/detail/limits/split_256.hpp
+
+../libraries/boost/preprocessor/seq/detail/limits/split_512.hpp
+
+../libraries/boost/preprocessor/seq/detail/split.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/seq/detail/limits/split_256.hpp
+-
+boost/preprocessor/seq/detail/limits/split_256.hpp
+-
+boost/preprocessor/seq/detail/limits/split_512.hpp
+-
+boost/preprocessor/seq/detail/limits/split_256.hpp
+-
+boost/preprocessor/seq/detail/limits/split_512.hpp
+-
+boost/preprocessor/seq/detail/limits/split_1024.hpp
+-
+
+../libraries/boost/preprocessor/seq/elem.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/seq/limits/elem_256.hpp
+-
+boost/preprocessor/seq/limits/elem_256.hpp
+-
+boost/preprocessor/seq/limits/elem_512.hpp
+-
+boost/preprocessor/seq/limits/elem_256.hpp
+-
+boost/preprocessor/seq/limits/elem_512.hpp
+-
+boost/preprocessor/seq/limits/elem_1024.hpp
+-
+
+../libraries/boost/preprocessor/seq/enum.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/seq/limits/enum_256.hpp
+-
+boost/preprocessor/seq/limits/enum_256.hpp
+-
+boost/preprocessor/seq/limits/enum_512.hpp
+-
+boost/preprocessor/seq/limits/enum_256.hpp
+-
+boost/preprocessor/seq/limits/enum_512.hpp
+-
+boost/preprocessor/seq/limits/enum_1024.hpp
+-
+
+../libraries/boost/preprocessor/seq/first_n.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/seq/detail/split.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/seq/fold_left.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/debug/error.hpp
+-
+boost/preprocessor/detail/auto_rec.hpp
+-
+boost/preprocessor/seq/seq.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/seq/limits/fold_left_256.hpp
+-
+boost/preprocessor/seq/limits/fold_left_256.hpp
+-
+boost/preprocessor/seq/limits/fold_left_512.hpp
+-
+boost/preprocessor/seq/limits/fold_left_256.hpp
+-
+boost/preprocessor/seq/limits/fold_left_512.hpp
+-
+boost/preprocessor/seq/limits/fold_left_1024.hpp
+-
+
+../libraries/boost/preprocessor/seq/for_each_i.hpp
+boost/preprocessor/arithmetic/dec.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/repetition/for.hpp
+-
+boost/preprocessor/seq/seq.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/seq/detail/is_empty.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/seq/limits/elem_1024.hpp
+
+../libraries/boost/preprocessor/seq/limits/elem_256.hpp
+
+../libraries/boost/preprocessor/seq/limits/elem_512.hpp
+
+../libraries/boost/preprocessor/seq/limits/enum_1024.hpp
+
+../libraries/boost/preprocessor/seq/limits/enum_256.hpp
+
+../libraries/boost/preprocessor/seq/limits/enum_512.hpp
+
+../libraries/boost/preprocessor/seq/limits/fold_left_1024.hpp
+
+../libraries/boost/preprocessor/seq/limits/fold_left_256.hpp
+
+../libraries/boost/preprocessor/seq/limits/fold_left_512.hpp
+
+../libraries/boost/preprocessor/seq/limits/size_1024.hpp
+
+../libraries/boost/preprocessor/seq/limits/size_256.hpp
+
+../libraries/boost/preprocessor/seq/limits/size_512.hpp
+
+../libraries/boost/preprocessor/seq/rest_n.hpp
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/comparison/not_equal.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/logical/bitand.hpp
+-
+boost/preprocessor/seq/detail/is_empty.hpp
+-
+boost/preprocessor/seq/detail/split.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+
+../libraries/boost/preprocessor/seq/seq.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/seq/elem.hpp
+-
+
+../libraries/boost/preprocessor/seq/size.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/seq/limits/size_256.hpp
+-
+boost/preprocessor/seq/limits/size_256.hpp
+-
+boost/preprocessor/seq/limits/size_512.hpp
+-
+boost/preprocessor/seq/limits/size_256.hpp
+-
+boost/preprocessor/seq/limits/size_512.hpp
+-
+boost/preprocessor/seq/limits/size_1024.hpp
+-
+
+../libraries/boost/preprocessor/seq/subseq.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/seq/first_n.hpp
+-
+boost/preprocessor/seq/rest_n.hpp
+-
+
+../libraries/boost/preprocessor/seq/transform.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/seq/fold_left.hpp
+-
+boost/preprocessor/seq/seq.hpp
+-
+boost/preprocessor/tuple/elem.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+
+../libraries/boost/preprocessor/slot/detail/def.hpp
+
+../libraries/boost/preprocessor/slot/slot.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/slot/detail/def.hpp
+-
+
+../libraries/boost/preprocessor/stringize.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/tuple/detail/is_single_return.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/facilities/is_1.hpp
+-
+boost/preprocessor/tuple/size.hpp
+-
+
+../libraries/boost/preprocessor/tuple/eat.hpp
+boost/preprocessor/config/config.hpp
+-
+
+../libraries/boost/preprocessor/tuple/elem.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/facilities/expand.hpp
+-
+boost/preprocessor/facilities/overload.hpp
+-
+boost/preprocessor/tuple/rem.hpp
+-
+boost/preprocessor/variadic/elem.hpp
+-
+boost/preprocessor/tuple/detail/is_single_return.hpp
+-
+
+../libraries/boost/preprocessor/tuple/limits/to_list_128.hpp
+
+../libraries/boost/preprocessor/tuple/limits/to_list_256.hpp
+
+../libraries/boost/preprocessor/tuple/limits/to_list_64.hpp
+
+../libraries/boost/preprocessor/tuple/rem.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/facilities/expand.hpp
+-
+boost/preprocessor/facilities/overload.hpp
+-
+boost/preprocessor/tuple/detail/is_single_return.hpp
+-
+
+../libraries/boost/preprocessor/tuple/size.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/variadic/has_opt.hpp
+-
+boost/preprocessor/variadic/size.hpp
+-
+
+../libraries/boost/preprocessor/tuple/to_list.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/if.hpp
+-
+boost/preprocessor/facilities/overload.hpp
+-
+boost/preprocessor/tuple/size.hpp
+-
+boost/preprocessor/variadic/size.hpp
+-
+boost/preprocessor/variadic/has_opt.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/tuple/limits/to_list_64.hpp
+-
+boost/preprocessor/tuple/limits/to_list_64.hpp
+-
+boost/preprocessor/tuple/limits/to_list_128.hpp
+-
+boost/preprocessor/tuple/limits/to_list_64.hpp
+-
+boost/preprocessor/tuple/limits/to_list_128.hpp
+-
+boost/preprocessor/tuple/limits/to_list_256.hpp
+-
+
+../libraries/boost/preprocessor/variadic/detail/has_opt.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+
+../libraries/boost/preprocessor/variadic/elem.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/variadic/limits/elem_64.hpp
+-
+boost/preprocessor/variadic/limits/elem_64.hpp
+-
+boost/preprocessor/variadic/limits/elem_128.hpp
+-
+boost/preprocessor/variadic/limits/elem_64.hpp
+-
+boost/preprocessor/variadic/limits/elem_128.hpp
+-
+boost/preprocessor/variadic/limits/elem_256.hpp
+-
+
+../libraries/boost/preprocessor/variadic/has_opt.hpp
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/variadic/detail/has_opt.hpp
+-
+
+../libraries/boost/preprocessor/variadic/limits/elem_128.hpp
+
+../libraries/boost/preprocessor/variadic/limits/elem_256.hpp
+
+../libraries/boost/preprocessor/variadic/limits/elem_64.hpp
+
+../libraries/boost/preprocessor/variadic/limits/size_128.hpp
+
+../libraries/boost/preprocessor/variadic/limits/size_256.hpp
+
+../libraries/boost/preprocessor/variadic/limits/size_64.hpp
+
+../libraries/boost/preprocessor/variadic/size.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/config/config.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/facilities/check_empty.hpp
+-
+boost/preprocessor/config/limits.hpp
+-
+boost/preprocessor/variadic/limits/size_64.hpp
+-
+boost/preprocessor/variadic/limits/size_128.hpp
+-
+boost/preprocessor/variadic/limits/size_256.hpp
+-
+
+../libraries/boost/range.hpp
+boost/range/functions.hpp
+-
+boost/range/metafunctions.hpp
+-
+boost/range/iterator_range.hpp
+-
+boost/range/sub_range.hpp
+-
+
+../libraries/boost/range/algorithm/copy.hpp
+boost/concept_check.hpp
+-
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+boost/range/concepts.hpp
+-
+boost/range/iterator_range.hpp
+-
+algorithm
+-
+
+../libraries/boost/range/algorithm/equal.hpp
+boost/config.hpp
+-
+boost/range/concepts.hpp
+-
+iterator
+-
+
+../libraries/boost/range/begin.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+
+../libraries/boost/range/category.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+
+../libraries/boost/range/concepts.hpp
+boost/concept_check.hpp
+-
+boost/iterator/iterator_concepts.hpp
+-
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+boost/range/iterator.hpp
+-
+boost/range/value_type.hpp
+-
+boost/range/detail/misc_concept.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+iterator
+-
+
+../libraries/boost/range/config.hpp
+boost/detail/workaround.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/range/const_iterator.hpp
+boost/range/config.hpp
+-
+boost/range/range_fwd.hpp
+-
+boost/range/detail/extract_optional_type.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+cstddef
+-
+utility
+-
+
+../libraries/boost/range/detail/common.hpp
+boost/range/config.hpp
+-
+boost/range/detail/sfinae.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/int.hpp
+-
+cstddef
+-
+
+../libraries/boost/range/detail/extract_optional_type.hpp
+boost/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+
+../libraries/boost/range/detail/has_member_size.hpp
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/cstdint.hpp
+-
+
+../libraries/boost/range/detail/implementation_help.hpp
+boost/range/config.hpp
+-
+boost/range/detail/common.hpp
+-
+boost/type_traits/is_same.hpp
+-
+cstddef
+-
+string.h
+-
+wchar.h
+-
+
+../libraries/boost/range/detail/misc_concept.hpp
+boost/concept_check.hpp
+-
+
+../libraries/boost/range/detail/msvc_has_iterator_workaround.hpp
+
+../libraries/boost/range/detail/safe_bool.hpp
+boost/config.hpp
+-
+boost/range/config.hpp
+-
+
+../libraries/boost/range/detail/sfinae.hpp
+boost/range/config.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+utility
+-
+
+../libraries/boost/range/difference_type.hpp
+boost/mpl/and.hpp
+-
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/range/has_range_iterator.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/range/distance.hpp
+boost/iterator/distance.hpp
+-
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+boost/range/difference_type.hpp
+-
+
+../libraries/boost/range/empty.hpp
+boost/range/config.hpp
+-
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+
+../libraries/boost/range/end.hpp
+boost/range/config.hpp
+-
+boost/range/detail/implementation_help.hpp
+-
+boost/range/iterator.hpp
+-
+boost/range/const_iterator.hpp
+-
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+
+../libraries/boost/range/functions.hpp
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+boost/range/size.hpp
+-
+boost/range/distance.hpp
+-
+boost/range/empty.hpp
+-
+boost/range/rbegin.hpp
+-
+boost/range/rend.hpp
+-
+
+../libraries/boost/range/has_range_iterator.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/has_xxx.hpp
+-
+boost/range/iterator.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/range/iterator.hpp
+boost/range/config.hpp
+-
+boost/range/range_fwd.hpp
+-
+boost/range/mutable_iterator.hpp
+-
+boost/range/const_iterator.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/mpl/eval_if.hpp
+-
+
+../libraries/boost/range/iterator_range.hpp
+boost/range/iterator_range_core.hpp
+../libraries/boost/range/boost/range/iterator_range_core.hpp
+boost/range/iterator_range_io.hpp
+../libraries/boost/range/boost/range/iterator_range_io.hpp
+
+../libraries/boost/range/iterator_range_core.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/assert.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+boost/iterator/iterator_facade.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/or.hpp
+-
+boost/type_traits/is_abstract.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/range/functions.hpp
+-
+boost/range/iterator.hpp
+-
+boost/range/difference_type.hpp
+-
+boost/range/has_range_iterator.hpp
+-
+boost/range/algorithm/equal.hpp
+-
+boost/range/detail/safe_bool.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/next_prior.hpp
+-
+iterator
+-
+algorithm
+-
+cstddef
+-
+
+../libraries/boost/range/iterator_range_io.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+ostream
+-
+ostream.h
+-
+boost/range/iterator_range_core.hpp
+-
+iterator
+-
+algorithm
+-
+cstddef
+-
+
+../libraries/boost/range/metafunctions.hpp
+boost/range/iterator.hpp
+-
+boost/range/has_range_iterator.hpp
+-
+boost/range/reverse_iterator.hpp
+-
+boost/range/value_type.hpp
+-
+boost/range/size_type.hpp
+-
+boost/range/difference_type.hpp
+-
+boost/range/category.hpp
+-
+boost/range/reference.hpp
+-
+boost/range/pointer.hpp
+-
+
+../libraries/boost/range/mutable_iterator.hpp
+boost/range/config.hpp
+-
+boost/range/range_fwd.hpp
+-
+boost/range/detail/extract_optional_type.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+cstddef
+-
+utility
+-
+boost/range/detail/msvc_has_iterator_workaround.hpp
+-
+
+../libraries/boost/range/pointer.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+
+../libraries/boost/range/range_fwd.hpp
+
+../libraries/boost/range/rbegin.hpp
+boost/range/end.hpp
+-
+boost/range/reverse_iterator.hpp
+-
+
+../libraries/boost/range/reference.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+
+../libraries/boost/range/rend.hpp
+boost/range/begin.hpp
+-
+boost/range/reverse_iterator.hpp
+-
+
+../libraries/boost/range/reverse_iterator.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/iterator/reverse_iterator.hpp
+-
+
+../libraries/boost/range/size.hpp
+boost/range/config.hpp
+-
+boost/range/begin.hpp
+-
+boost/range/end.hpp
+-
+boost/range/size_type.hpp
+-
+boost/range/detail/has_member_size.hpp
+-
+boost/assert.hpp
+-
+boost/cstdint.hpp
+-
+boost/utility.hpp
+-
+
+../libraries/boost/range/size_type.hpp
+boost/range/config.hpp
+-
+boost/range/difference_type.hpp
+-
+boost/range/concepts.hpp
+-
+boost/range/has_range_iterator.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/make_unsigned.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+cstddef
+-
+utility
+-
+
+../libraries/boost/range/sub_range.hpp
+boost/detail/workaround.hpp
+-
+boost/range/config.hpp
+-
+boost/range/iterator_range.hpp
+-
+boost/range/value_type.hpp
+-
+boost/range/size_type.hpp
+-
+boost/range/difference_type.hpp
+-
+boost/range/reference.hpp
+-
+boost/range/algorithm/equal.hpp
+-
+boost/assert.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/range/value_type.hpp
+boost/range/config.hpp
+-
+boost/range/iterator.hpp
+-
+boost/iterator/iterator_traits.hpp
+-
+
+../libraries/boost/ref.hpp
+boost/core/ref.hpp
+-
+
+../libraries/boost/serialization/access.hpp
+boost/config.hpp
+-
+
+../libraries/boost/serialization/array.hpp
+boost/config.hpp
+-
+iostream
+-
+cstddef
+-
+boost/serialization/array_wrapper.hpp
+-
+array
+-
+boost/serialization/nvp.hpp
+-
+
+../libraries/boost/serialization/array_optimization.hpp
+boost/config.hpp
+-
+boost/mpl/always.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/serialization/array_wrapper.hpp
+boost/config.hpp
+-
+boost/serialization/nvp.hpp
+-
+boost/serialization/split_member.hpp
+-
+boost/serialization/wrapper.hpp
+-
+boost/serialization/collection_size_type.hpp
+-
+boost/serialization/array_optimization.hpp
+-
+boost/mpl/always.hpp
+-
+boost/mpl/apply.hpp
+-
+boost/mpl/bool_fwd.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/serialization/base_object.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_polymorphic.hpp
+-
+boost/static_assert.hpp
+-
+boost/serialization/access.hpp
+-
+boost/serialization/force_include.hpp
+-
+boost/serialization/void_cast_fwd.hpp
+-
+
+../libraries/boost/serialization/collection_size_type.hpp
+cstddef
+-
+boost/serialization/strong_typedef.hpp
+-
+boost/serialization/level.hpp
+-
+boost/serialization/split_free.hpp
+-
+boost/serialization/is_bitwise_serializable.hpp
+-
+
+../libraries/boost/serialization/force_include.hpp
+boost/config.hpp
+-
+
+../libraries/boost/serialization/is_bitwise_serializable.hpp
+boost/mpl/bool_fwd.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+
+../libraries/boost/serialization/level.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_fundamental.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/integral_c.hpp
+-
+boost/mpl/integral_c_tag.hpp
+-
+boost/serialization/level_enum.hpp
+-
+
+../libraries/boost/serialization/level_enum.hpp
+
+../libraries/boost/serialization/nvp.hpp
+boost/core/nvp.hpp
+-
+boost/preprocessor/stringize.hpp
+-
+boost/serialization/level.hpp
+-
+boost/serialization/tracking.hpp
+-
+boost/serialization/split_free.hpp
+-
+boost/serialization/wrapper.hpp
+-
+boost/serialization/base_object.hpp
+-
+
+../libraries/boost/serialization/serialization.hpp
+boost/config.hpp
+-
+boost/serialization/strong_typedef.hpp
+-
+boost/serialization/access.hpp
+-
+
+../libraries/boost/serialization/split_free.hpp
+boost/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/serialization/serialization.hpp
+-
+
+../libraries/boost/serialization/split_member.hpp
+boost/config.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/serialization/access.hpp
+-
+
+../libraries/boost/serialization/strong_typedef.hpp
+boost/config.hpp
+-
+boost/operators.hpp
+-
+boost/type_traits/has_nothrow_assign.hpp
+-
+boost/type_traits/has_nothrow_constructor.hpp
+-
+boost/type_traits/has_nothrow_copy.hpp
+-
+
+../libraries/boost/serialization/tracking.hpp
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/equal_to.hpp
+-
+boost/mpl/greater.hpp
+-
+boost/mpl/integral_c_tag.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/serialization/level.hpp
+-
+boost/serialization/tracking_enum.hpp
+-
+boost/serialization/type_info_implementation.hpp
+-
+
+../libraries/boost/serialization/tracking_enum.hpp
+
+../libraries/boost/serialization/traits.hpp
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/mpl/int.hpp
+-
+boost/mpl/bool_fwd.hpp
+-
+boost/serialization/level_enum.hpp
+-
+boost/serialization/tracking_enum.hpp
+-
+
+../libraries/boost/serialization/type_info_implementation.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/static_assert.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/serialization/traits.hpp
+-
+
+../libraries/boost/serialization/void_cast_fwd.hpp
+cstddef
+-
+boost/serialization/force_include.hpp
+-
+
+../libraries/boost/serialization/wrapper.hpp
+boost/serialization/traits.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/bool_fwd.hpp
+-
+
+../libraries/boost/shared_array.hpp
+boost/smart_ptr/shared_array.hpp
+-
+
+../libraries/boost/smart_ptr/bad_weak_ptr.hpp
+boost/config.hpp
+-
+exception
+-
+
+../libraries/boost/smart_ptr/detail/lightweight_mutex.hpp
+boost/config.hpp
+-
+boost/smart_ptr/detail/lwm_std_mutex.hpp
+-
+boost/smart_ptr/detail/lwm_win32_cs.hpp
+-
+boost/smart_ptr/detail/lwm_pthreads.hpp
+-
+
+../libraries/boost/smart_ptr/detail/local_counted_base.hpp
+boost/smart_ptr/detail/shared_count.hpp
+-
+boost/config.hpp
+-
+utility
+-
+
+../libraries/boost/smart_ptr/detail/local_sp_deleter.hpp
+boost/smart_ptr/detail/local_counted_base.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/smart_ptr/detail/lwm_pthreads.hpp
+boost/assert.hpp
+-
+pthread.h
+-
+
+../libraries/boost/smart_ptr/detail/lwm_std_mutex.hpp
+boost/assert.hpp
+-
+mutex
+-
+
+../libraries/boost/smart_ptr/detail/lwm_win32_cs.hpp
+windows.h
+-
+
+../libraries/boost/smart_ptr/detail/operator_bool.hpp
+
+../libraries/boost/smart_ptr/detail/quick_allocator.hpp
+boost/config.hpp
+-
+boost/smart_ptr/detail/lightweight_mutex.hpp
+-
+boost/type_traits/type_with_alignment.hpp
+-
+boost/type_traits/alignment_of.hpp
+-
+new
+-
+cstddef
+-
+
+../libraries/boost/smart_ptr/detail/shared_count.hpp
+boost/smart_ptr/bad_weak_ptr.hpp
+-
+boost/smart_ptr/detail/sp_counted_base.hpp
+-
+boost/smart_ptr/detail/sp_counted_impl.hpp
+-
+boost/smart_ptr/detail/sp_disable_deprecated.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/checked_delete.hpp
+-
+boost/throw_exception.hpp
+-
+boost/core/addressof.hpp
+-
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/cstdint.hpp
+-
+memory
+-
+functional
+-
+cstddef
+-
+new
+-
+
+../libraries/boost/smart_ptr/detail/sp_convertible.hpp
+boost/config.hpp
+-
+cstddef
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base.hpp
+boost/smart_ptr/detail/sp_has_gcc_intrinsics.hpp
+-
+boost/smart_ptr/detail/sp_has_sync_intrinsics.hpp
+-
+boost/config.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_nt.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_spin.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_pt.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_nt.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_atomic.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_sync.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_sync.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_snc_ps3.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_acc_ia64.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_vacpp_ppc.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_cw_ppc.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_ppc.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_gcc_sparc.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_w32.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_aix.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_nt.hpp
+-
+boost/smart_ptr/detail/sp_counted_base_spin.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_acc_ia64.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+machine/sys/inline.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_aix.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/config.hpp
+-
+builtins.h
+-
+sys/atomic_op.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_cw_ppc.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_atomic.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/config.hpp
+-
+boost/cstdint.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_ppc.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_sparc.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+inttypes.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_nt.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/config.hpp
+-
+boost/cstdint.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_pt.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/assert.hpp
+-
+boost/config.hpp
+-
+boost/cstdint.hpp
+-
+pthread.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_snc_ps3.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+inttypes.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_spin.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/spinlock_pool.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/config.hpp
+-
+atomic
+-
+cstdint
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_sync.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/config.hpp
+-
+limits.h
+-
+ia64intrin.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_vacpp_ppc.hpp
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/smart_ptr/detail/sp_obsolete.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_base_w32.hpp
+boost/smart_ptr/detail/sp_interlocked.hpp
+-
+boost/smart_ptr/detail/sp_typeinfo_.hpp
+-
+boost/config/workaround.hpp
+-
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_counted_impl.hpp
+boost/smart_ptr/detail/sp_counted_base.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/checked_delete.hpp
+-
+boost/core/addressof.hpp
+-
+boost/config.hpp
+-
+boost/smart_ptr/detail/quick_allocator.hpp
+-
+memory
+-
+cstddef
+-
+
+../libraries/boost/smart_ptr/detail/sp_disable_deprecated.hpp
+boost/config.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_has_gcc_intrinsics.hpp
+
+../libraries/boost/smart_ptr/detail/sp_has_sync_intrinsics.hpp
+
+../libraries/boost/smart_ptr/detail/sp_interlocked.hpp
+boost/config.hpp
+-
+windows.h
+-
+intrin.h
+-
+
+../libraries/boost/smart_ptr/detail/sp_noexcept.hpp
+boost/config.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_nullptr_t.hpp
+boost/config.hpp
+-
+cstddef
+-
+
+../libraries/boost/smart_ptr/detail/sp_obsolete.hpp
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_thread_pause.hpp
+
+../libraries/boost/smart_ptr/detail/sp_thread_sleep.hpp
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+boost/smart_ptr/detail/sp_win32_sleep.hpp
+-
+time.h
+-
+boost/smart_ptr/detail/sp_thread_yield.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_thread_yield.hpp
+boost/config.hpp
+-
+boost/config/pragma_message.hpp
+-
+boost/smart_ptr/detail/sp_win32_sleep.hpp
+-
+sched.h
+-
+boost/smart_ptr/detail/sp_thread_pause.hpp
+-
+
+../libraries/boost/smart_ptr/detail/sp_typeinfo_.hpp
+boost/config.hpp
+-
+boost/core/typeinfo.hpp
+-
+typeinfo
+-
+
+../libraries/boost/smart_ptr/detail/sp_win32_sleep.hpp
+windows.h
+-
+
+../libraries/boost/smart_ptr/detail/spinlock.hpp
+boost/smart_ptr/detail/sp_has_gcc_intrinsics.hpp
+-
+boost/smart_ptr/detail/sp_has_sync_intrinsics.hpp
+-
+boost/config.hpp
+-
+boost/smart_ptr/detail/spinlock_std_atomic.hpp
+-
+boost/smart_ptr/detail/spinlock_pt.hpp
+-
+boost/smart_ptr/detail/spinlock_gcc_atomic.hpp
+-
+boost/smart_ptr/detail/spinlock_std_atomic.hpp
+-
+boost/smart_ptr/detail/spinlock_gcc_arm.hpp
+-
+boost/smart_ptr/detail/spinlock_sync.hpp
+-
+boost/smart_ptr/detail/spinlock_w32.hpp
+-
+boost/smart_ptr/detail/spinlock_pt.hpp
+-
+boost/smart_ptr/detail/spinlock_nt.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_gcc_arm.hpp
+boost/smart_ptr/detail/yield_k.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_gcc_atomic.hpp
+boost/smart_ptr/detail/yield_k.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_nt.hpp
+boost/assert.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_pool.hpp
+boost/config.hpp
+-
+boost/smart_ptr/detail/spinlock.hpp
+-
+cstddef
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_pt.hpp
+pthread.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_std_atomic.hpp
+boost/smart_ptr/detail/yield_k.hpp
+-
+boost/config.hpp
+-
+atomic
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_sync.hpp
+boost/smart_ptr/detail/yield_k.hpp
+-
+ia64intrin.h
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/spinlock_w32.hpp
+boost/smart_ptr/detail/sp_interlocked.hpp
+-
+boost/smart_ptr/detail/yield_k.hpp
+-
+boost/config/pragma_message.hpp
+-
+
+../libraries/boost/smart_ptr/detail/yield_k.hpp
+boost/smart_ptr/detail/sp_thread_pause.hpp
+-
+boost/smart_ptr/detail/sp_thread_sleep.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/smart_ptr/shared_array.hpp
+boost/config.hpp
+-
+memory
+-
+boost/assert.hpp
+-
+boost/checked_delete.hpp
+-
+boost/smart_ptr/shared_ptr.hpp
+-
+boost/smart_ptr/detail/shared_count.hpp
+-
+boost/smart_ptr/detail/sp_nullptr_t.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/config/workaround.hpp
+-
+cstddef
+-
+algorithm
+-
+functional
+-
+boost/smart_ptr/detail/operator_bool.hpp
+-
+
+../libraries/boost/smart_ptr/shared_ptr.hpp
+boost/smart_ptr/detail/shared_count.hpp
+-
+boost/smart_ptr/detail/sp_convertible.hpp
+-
+boost/smart_ptr/detail/sp_nullptr_t.hpp
+-
+boost/smart_ptr/detail/sp_disable_deprecated.hpp
+-
+boost/smart_ptr/detail/sp_noexcept.hpp
+-
+boost/checked_delete.hpp
+-
+boost/throw_exception.hpp
+-
+boost/assert.hpp
+-
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/smart_ptr/detail/spinlock_pool.hpp
+-
+algorithm
+-
+functional
+-
+typeinfo
+-
+cstddef
+-
+memory
+-
+iosfwd
+-
+ostream
+-
+boost/smart_ptr/detail/operator_bool.hpp
+-
+boost/smart_ptr/detail/local_sp_deleter.hpp
+-
+
+../libraries/boost/static_assert.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/swap.hpp
+boost/core/swap.hpp
+-
+
+../libraries/boost/throw_exception.hpp
+boost/exception/exception.hpp
+-
+boost/assert/source_location.hpp
+-
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+exception
+-
+
+../libraries/boost/type.hpp
+
+../libraries/boost/type_index.hpp
+boost/config.hpp
+-
+boost/type_index/stl_type_index.hpp
+-
+boost/type_index/detail/stl_register_class.hpp
+-
+boost/type_index/ctti_type_index.hpp
+-
+boost/type_index/detail/ctti_register_class.hpp
+-
+
+../libraries/boost/type_index/ctti_type_index.hpp
+boost/type_index/type_index_facade.hpp
+-
+boost/type_index/detail/compile_time_type_info.hpp
+-
+cstring
+-
+boost/container_hash/hash.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_index/detail/compile_time_type_info.hpp
+cstring
+-
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/preprocessor/facilities/expand.hpp
+-
+
+../libraries/boost/type_index/detail/ctti_register_class.hpp
+boost/type_index/ctti_type_index.hpp
+-
+
+../libraries/boost/type_index/detail/stl_register_class.hpp
+boost/type_index/stl_type_index.hpp
+-
+
+../libraries/boost/type_index/stl_type_index.hpp
+boost/type_index/type_index_facade.hpp
+-
+typeinfo
+-
+cstring
+-
+stdexcept
+-
+boost/static_assert.hpp
+-
+boost/throw_exception.hpp
+-
+boost/core/demangle.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/container_hash/hash.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/type_traits/make_signed.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+
+../libraries/boost/type_index/type_index_facade.hpp
+boost/config.hpp
+-
+boost/container_hash/hash_fwd.hpp
+-
+string
+-
+cstring
+-
+iosfwd
+-
+ostream
+-
+
+../libraries/boost/type_traits.hpp
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_cv.hpp
+-
+boost/type_traits/add_lvalue_reference.hpp
+-
+boost/type_traits/add_pointer.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/add_rvalue_reference.hpp
+-
+boost/type_traits/add_volatile.hpp
+-
+boost/type_traits/aligned_storage.hpp
+-
+boost/type_traits/alignment_of.hpp
+-
+boost/type_traits/common_type.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/conjunction.hpp
+-
+boost/type_traits/copy_cv.hpp
+-
+boost/type_traits/copy_cv_ref.hpp
+-
+boost/type_traits/copy_reference.hpp
+-
+boost/type_traits/decay.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/disjunction.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/extent.hpp
+-
+boost/type_traits/floating_point_promotion.hpp
+-
+boost/type_traits/function_traits.hpp
+-
+boost/type_traits/has_bit_and.hpp
+-
+boost/type_traits/has_bit_and_assign.hpp
+-
+boost/type_traits/has_bit_or.hpp
+-
+boost/type_traits/has_bit_or_assign.hpp
+-
+boost/type_traits/has_bit_xor.hpp
+-
+boost/type_traits/has_bit_xor_assign.hpp
+-
+boost/type_traits/has_complement.hpp
+-
+boost/type_traits/has_dereference.hpp
+-
+boost/type_traits/has_divides.hpp
+-
+boost/type_traits/has_divides_assign.hpp
+-
+boost/type_traits/has_equal_to.hpp
+-
+boost/type_traits/has_greater.hpp
+-
+boost/type_traits/has_greater_equal.hpp
+-
+boost/type_traits/has_left_shift.hpp
+-
+boost/type_traits/has_left_shift_assign.hpp
+-
+boost/type_traits/has_less.hpp
+-
+boost/type_traits/has_less_equal.hpp
+-
+boost/type_traits/has_logical_and.hpp
+-
+boost/type_traits/has_logical_not.hpp
+-
+boost/type_traits/has_logical_or.hpp
+-
+boost/type_traits/has_minus.hpp
+-
+boost/type_traits/has_minus_assign.hpp
+-
+boost/type_traits/has_modulus.hpp
+-
+boost/type_traits/has_modulus_assign.hpp
+-
+boost/type_traits/has_multiplies.hpp
+-
+boost/type_traits/has_multiplies_assign.hpp
+-
+boost/type_traits/has_negate.hpp
+-
+boost/type_traits/has_new_operator.hpp
+-
+boost/type_traits/has_not_equal_to.hpp
+-
+boost/type_traits/has_nothrow_assign.hpp
+-
+boost/type_traits/has_nothrow_constructor.hpp
+-
+boost/type_traits/has_nothrow_copy.hpp
+-
+boost/type_traits/has_nothrow_destructor.hpp
+-
+boost/type_traits/has_plus.hpp
+-
+boost/type_traits/has_plus_assign.hpp
+-
+boost/type_traits/has_post_decrement.hpp
+-
+boost/type_traits/has_post_increment.hpp
+-
+boost/type_traits/has_pre_decrement.hpp
+-
+boost/type_traits/has_pre_increment.hpp
+-
+boost/type_traits/has_right_shift.hpp
+-
+boost/type_traits/has_right_shift_assign.hpp
+-
+boost/type_traits/has_trivial_assign.hpp
+-
+boost/type_traits/has_trivial_constructor.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+boost/type_traits/has_trivial_destructor.hpp
+-
+boost/type_traits/has_trivial_move_assign.hpp
+-
+boost/type_traits/has_trivial_move_constructor.hpp
+-
+boost/type_traits/has_unary_minus.hpp
+-
+boost/type_traits/has_unary_plus.hpp
+-
+boost/type_traits/has_virtual_destructor.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_abstract.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_complex.hpp
+-
+boost/type_traits/is_compound.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_copy_assignable.hpp
+-
+boost/type_traits/is_copy_constructible.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+boost/type_traits/is_destructible.hpp
+-
+boost/type_traits/is_empty.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_final.hpp
+-
+boost/type_traits/is_float.hpp
+-
+boost/type_traits/is_floating_point.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/is_fundamental.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_list_constructible.hpp
+-
+boost/type_traits/is_lvalue_reference.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+boost/type_traits/is_member_object_pointer.hpp
+-
+boost/type_traits/is_member_pointer.hpp
+-
+boost/type_traits/is_nothrow_move_assignable.hpp
+-
+boost/type_traits/is_nothrow_move_constructible.hpp
+-
+boost/type_traits/is_nothrow_swappable.hpp
+-
+boost/type_traits/is_object.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_polymorphic.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_rvalue_reference.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_scalar.hpp
+-
+boost/type_traits/is_scoped_enum.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/type_traits/is_stateless.hpp
+-
+boost/type_traits/is_trivially_copyable.hpp
+-
+boost/type_traits/is_union.hpp
+-
+boost/type_traits/is_unscoped_enum.hpp
+-
+boost/type_traits/is_unsigned.hpp
+-
+boost/type_traits/is_virtual_base_of.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/make_signed.hpp
+-
+boost/type_traits/make_unsigned.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/negation.hpp
+-
+boost/type_traits/rank.hpp
+-
+boost/type_traits/remove_all_extents.hpp
+-
+boost/type_traits/remove_bounds.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_cv_ref.hpp
+-
+boost/type_traits/remove_extent.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_volatile.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/type_with_alignment.hpp
+-
+boost/type_traits/integral_promotion.hpp
+-
+boost/type_traits/promote.hpp
+-
+
+../libraries/boost/type_traits/add_const.hpp
+boost/type_traits/detail/config.hpp
+-
+
+../libraries/boost/type_traits/add_cv.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/add_lvalue_reference.hpp
+boost/type_traits/add_reference.hpp
+-
+
+../libraries/boost/type_traits/add_pointer.hpp
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/add_reference.hpp
+boost/detail/workaround.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/add_rvalue_reference.hpp
+boost/config.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+
+../libraries/boost/type_traits/add_volatile.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/aligned_storage.hpp
+cstddef
+-
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/alignment_of.hpp
+-
+boost/type_traits/type_with_alignment.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/type_traits/alignment_of.hpp
+boost/config.hpp
+-
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/common_type.hpp
+boost/config.hpp
+-
+boost/type_traits/decay.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/detail/common_type_impl.hpp
+-
+boost/type_traits/detail/mp_defer.hpp
+-
+
+../libraries/boost/type_traits/composite_traits.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_member_pointer.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_union.hpp
+-
+
+../libraries/boost/type_traits/conditional.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/conjunction.hpp
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/conversion_traits.hpp
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/type_traits/copy_cv.hpp
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_volatile.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/type_traits/copy_cv_ref.hpp
+boost/type_traits/copy_cv.hpp
+-
+boost/type_traits/copy_reference.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/copy_reference.hpp
+boost/type_traits/add_lvalue_reference.hpp
+-
+boost/type_traits/add_rvalue_reference.hpp
+-
+boost/type_traits/is_lvalue_reference.hpp
+-
+boost/type_traits/is_rvalue_reference.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/type_traits/decay.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/remove_bounds.hpp
+-
+boost/type_traits/add_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+
+../libraries/boost/type_traits/declval.hpp
+boost/config.hpp
+-
+boost/type_traits/add_rvalue_reference.hpp
+-
+
+../libraries/boost/type_traits/detail/common_arithmetic_type.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/detail/common_type_impl.hpp
+boost/type_traits/detail/common_arithmetic_type.hpp
+-
+boost/type_traits/detail/composite_pointer_type.hpp
+-
+boost/type_traits/detail/composite_member_pointer_type.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_union.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_member_pointer.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/type_traits/detail/composite_member_pointer_type.hpp
+boost/type_traits/detail/composite_pointer_type.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/config.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/detail/composite_pointer_type.hpp
+boost/type_traits/copy_cv.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/config.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/detail/config.hpp
+boost/config.hpp
+-
+boost/version.hpp
+-
+boost/config/workaround.hpp
+-
+
+../libraries/boost/type_traits/detail/has_binary_operator.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+utility
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_fundamental.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/detail/is_likely_lambda.hpp
+-
+
+../libraries/boost/type_traits/detail/has_postfix_operator.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+utility
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_fundamental.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/detail/has_prefix_operator.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+utility
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_fundamental.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/detail/is_function_cxx_03.hpp
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/detail/is_function_ptr_helper.hpp
+-
+boost/type_traits/detail/is_function_ptr_tester.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/detail/is_function_msvc10_fix.hpp
+-
+
+../libraries/boost/type_traits/detail/is_function_cxx_11.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/detail/is_function_msvc10_fix.hpp
+
+../libraries/boost/type_traits/detail/is_function_ptr_helper.hpp
+
+../libraries/boost/type_traits/detail/is_function_ptr_tester.hpp
+boost/type_traits/detail/yes_no_type.hpp
+-
+
+../libraries/boost/type_traits/detail/is_likely_lambda.hpp
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+
+../libraries/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/detail/is_mem_fun_pointer_tester.hpp
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+
+../libraries/boost/type_traits/detail/is_member_function_pointer_cxx_03.hpp
+boost/type_traits/detail/is_mem_fun_pointer_impl.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/detail/is_mem_fun_pointer_tester.hpp
+-
+
+../libraries/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/detail/is_rvalue_reference_msvc10_fix.hpp
+
+../libraries/boost/type_traits/detail/mp_defer.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/type_traits/detail/yes_no_type.hpp
+
+../libraries/boost/type_traits/disjunction.hpp
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/enable_if.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/extent.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/floating_point_promotion.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/function_traits.hpp
+boost/config.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/add_pointer.hpp
+-
+
+../libraries/boost/type_traits/has_bit_and.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_bit_and_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_bit_or.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_bit_or_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_bit_xor.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_bit_xor_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_complement.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_dereference.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_divides.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_divides_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_equal_to.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_greater.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_greater_equal.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_left_shift.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_left_shift_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_less.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_less_equal.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_logical_and.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_logical_not.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_logical_or.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_minus.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+utility
+-
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_minus_assign.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+utility
+-
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_modulus.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_modulus_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_multiplies.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_multiplies_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_negate.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_new_operator.hpp
+new
+-
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/has_not_equal_to.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_nothrow_assign.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/has_trivial_assign.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+
+../libraries/boost/type_traits/has_nothrow_constructor.hpp
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/has_trivial_constructor.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+boost/type_traits/remove_all_extents.hpp
+-
+boost/type_traits/has_trivial_constructor.hpp
+-
+
+../libraries/boost/type_traits/has_nothrow_copy.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_copy_constructible.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/add_lvalue_reference.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_copy_constructible.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+
+../libraries/boost/type_traits/has_nothrow_destructor.hpp
+boost/type_traits/has_trivial_destructor.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_destructible.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/type_traits/has_plus.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_plus_assign.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/make_void.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_pointer.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+utility
+-
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_post_decrement.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/has_postfix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_post_increment.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/has_postfix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_pre_decrement.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_pre_increment.hpp
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_right_shift.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_right_shift_assign.hpp
+boost/type_traits/detail/has_binary_operator.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_assign.hpp
+cstddef
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_constructor.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_copy.hpp
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_copy_constructible.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_lvalue_reference.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_destructor.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_destructible.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_move_assign.hpp
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_assignable.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+
+../libraries/boost/type_traits/has_trivial_move_constructor.hpp
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/remove_const.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+
+../libraries/boost/type_traits/has_unary_minus.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_unary_plus.hpp
+boost/type_traits/detail/has_prefix_operator.hpp
+-
+
+../libraries/boost/type_traits/has_virtual_destructor.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/integral_constant.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/integral_promotion.hpp
+boost/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+
+../libraries/boost/type_traits/intrinsics.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/is_same.hpp
+-
+algorithm
+-
+type_traits.h
+-
+msl_utility
+-
+cstddef
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/is_void.hpp
+-
+
+../libraries/boost/type_traits/is_abstract.hpp
+cstddef
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_polymorphic.hpp
+-
+
+../libraries/boost/type_traits/is_arithmetic.hpp
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_floating_point.hpp
+-
+
+../libraries/boost/type_traits/is_array.hpp
+boost/type_traits/integral_constant.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/is_assignable.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/has_trivial_assign.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/is_base_and_derived.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/type_traits/is_base_of.hpp
+boost/type_traits/is_base_and_derived.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/is_class.hpp
+-
+
+../libraries/boost/type_traits/is_class.hpp
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_union.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/is_scalar.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_function.hpp
+-
+
+../libraries/boost/type_traits/is_complete.hpp
+boost/type_traits/declval.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/config/workaround.hpp
+-
+
+../libraries/boost/type_traits/is_complex.hpp
+boost/config.hpp
+-
+complex
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_compound.hpp
+boost/type_traits/is_fundamental.hpp
+-
+
+../libraries/boost/type_traits/is_const.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_constructible.hpp
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_destructible.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_default_constructible.hpp
+-
+
+../libraries/boost/type_traits/is_convertible.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_abstract.hpp
+-
+boost/type_traits/add_lvalue_reference.hpp
+-
+boost/type_traits/add_rvalue_reference.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/type_traits/is_copy_assignable.hpp
+boost/config.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/is_noncopyable.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/is_copy_constructible.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_constructible.hpp
+-
+boost/type_traits/is_noncopyable.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/is_noncopyable.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/is_rvalue_reference.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/declval.hpp
+-
+
+../libraries/boost/type_traits/is_default_constructible.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/is_abstract.hpp
+-
+utility
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+
+../libraries/boost/type_traits/is_destructible.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/detail/yes_no_type.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/type_traits/is_class.hpp
+-
+
+../libraries/boost/type_traits/is_empty.hpp
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+
+../libraries/boost/type_traits/is_enum.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/add_reference.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_function.hpp
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_union.hpp
+-
+
+../libraries/boost/type_traits/is_final.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+
+../libraries/boost/type_traits/is_float.hpp
+boost/type_traits/is_floating_point.hpp
+-
+
+../libraries/boost/type_traits/is_floating_point.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_function.hpp
+boost/type_traits/detail/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/detail/is_function_cxx_11.hpp
+-
+boost/type_traits/detail/is_function_cxx_03.hpp
+-
+
+../libraries/boost/type_traits/is_fundamental.hpp
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_void.hpp
+-
+
+../libraries/boost/type_traits/is_integral.hpp
+boost/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_list_constructible.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/type_traits/is_lvalue_reference.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_member_function_pointer.hpp
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp
+-
+boost/type_traits/detail/is_member_function_pointer_cxx_03.hpp
+-
+
+../libraries/boost/type_traits/is_member_object_pointer.hpp
+boost/type_traits/is_member_pointer.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+
+../libraries/boost/type_traits/is_member_pointer.hpp
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+
+../libraries/boost/type_traits/is_noncopyable.hpp
+boost/type_traits/is_base_and_derived.hpp
+-
+
+../libraries/boost/type_traits/is_nothrow_move_assignable.hpp
+boost/config.hpp
+-
+boost/type_traits/has_trivial_move_assign.hpp
+-
+boost/type_traits/has_nothrow_assign.hpp
+-
+boost/type_traits/is_array.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/type_traits/is_nothrow_move_constructible.hpp
+cstddef
+-
+boost/config.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_complete.hpp
+-
+boost/static_assert.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/has_trivial_move_constructor.hpp
+-
+boost/type_traits/has_nothrow_copy.hpp
+-
+boost/type_traits/is_array.hpp
+-
+
+../libraries/boost/type_traits/is_nothrow_swappable.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/is_scalar.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+algorithm
+-
+
+../libraries/boost/type_traits/is_object.hpp
+boost/config.hpp
+-
+boost/type_traits/is_reference.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_function.hpp
+-
+
+../libraries/boost/type_traits/is_pod.hpp
+cstddef
+-
+boost/type_traits/detail/config.hpp
+-
+boost/type_traits/is_void.hpp
+-
+boost/type_traits/is_scalar.hpp
+-
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/is_function.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/is_pointer.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_polymorphic.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/is_reference.hpp
+boost/type_traits/is_lvalue_reference.hpp
+-
+boost/type_traits/is_rvalue_reference.hpp
+-
+
+../libraries/boost/type_traits/is_rvalue_reference.hpp
+boost/config.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/type_traits/detail/is_rvalue_reference_msvc10_fix.hpp
+-
+
+../libraries/boost/type_traits/is_same.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_scalar.hpp
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_member_pointer.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/is_scoped_enum.hpp
+boost/type_traits/conjunction.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/negation.hpp
+-
+
+../libraries/boost/type_traits/is_signed.hpp
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+climits
+-
+
+../libraries/boost/type_traits/is_stateless.hpp
+boost/type_traits/has_trivial_constructor.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+boost/type_traits/has_trivial_destructor.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_empty.hpp
+-
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/is_trivially_copyable.hpp
+boost/type_traits/has_trivial_assign.hpp
+-
+boost/type_traits/has_trivial_copy.hpp
+-
+boost/type_traits/has_trivial_destructor.hpp
+-
+boost/type_traits/has_trivial_move_assign.hpp
+-
+boost/type_traits/has_trivial_move_constructor.hpp
+-
+
+../libraries/boost/type_traits/is_union.hpp
+boost/type_traits/intrinsics.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_unscoped_enum.hpp
+boost/type_traits/conjunction.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+
+../libraries/boost/type_traits/is_unsigned.hpp
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+climits
+-
+
+../libraries/boost/type_traits/is_virtual_base_of.hpp
+boost/type_traits/is_base_of.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/make_void.hpp
+-
+utility
+-
+
+../libraries/boost/type_traits/is_void.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/is_volatile.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/make_signed.hpp
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/type_traits/is_unsigned.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_volatile.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/type_traits/make_unsigned.hpp
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_signed.hpp
+-
+boost/type_traits/is_unsigned.hpp
+-
+boost/type_traits/is_enum.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_const.hpp
+-
+boost/type_traits/is_volatile.hpp
+-
+boost/type_traits/add_const.hpp
+-
+boost/type_traits/add_volatile.hpp
+-
+boost/static_assert.hpp
+-
+
+../libraries/boost/type_traits/make_void.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/negation.hpp
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/promote.hpp
+boost/config.hpp
+-
+boost/type_traits/integral_promotion.hpp
+-
+boost/type_traits/floating_point_promotion.hpp
+-
+
+../libraries/boost/type_traits/rank.hpp
+cstddef
+-
+boost/type_traits/integral_constant.hpp
+-
+
+../libraries/boost/type_traits/remove_all_extents.hpp
+boost/config.hpp
+-
+cstddef
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/remove_bounds.hpp
+boost/type_traits/remove_extent.hpp
+-
+
+../libraries/boost/type_traits/remove_const.hpp
+boost/config.hpp
+-
+cstddef
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/remove_cv.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/remove_cv_ref.hpp
+boost/config.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/type_traits/remove_extent.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/remove_pointer.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+
+../libraries/boost/type_traits/remove_reference.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+
+../libraries/boost/type_traits/remove_volatile.hpp
+boost/config.hpp
+-
+boost/detail/workaround.hpp
+-
+cstddef
+-
+
+../libraries/boost/type_traits/same_traits.hpp
+boost/type_traits/is_same.hpp
+-
+
+../libraries/boost/type_traits/type_identity.hpp
+boost/config.hpp
+-
+
+../libraries/boost/type_traits/type_with_alignment.hpp
+boost/type_traits/alignment_of.hpp
+-
+boost/type_traits/is_pod.hpp
+-
+boost/static_assert.hpp
+-
+boost/config.hpp
+-
+cstddef
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/conditional.hpp
+-
+
+../libraries/boost/typeof/constant.hpp
+boost/config.hpp
+-
+
+../libraries/boost/typeof/decltype.hpp
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+
+../libraries/boost/typeof/dmc/typeof_impl.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/typeof/constant.hpp
+-
+
+../libraries/boost/typeof/encode_decode.hpp
+boost/typeof/message.hpp
+-
+
+../libraries/boost/typeof/encode_decode_params.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+
+../libraries/boost/typeof/int_encoding.hpp
+boost/config.hpp
+-
+boost/typeof/constant.hpp
+-
+cstddef
+-
+
+../libraries/boost/typeof/integral_template_param.hpp
+
+../libraries/boost/typeof/message.hpp
+
+../libraries/boost/typeof/modifiers.hpp
+boost/typeof/encode_decode.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+
+../libraries/boost/typeof/msvc/typeof_impl.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/typeof/constant.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/is_function.hpp
+-
+typeinfo
+-
+
+../libraries/boost/typeof/native.hpp
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/is_function.hpp
+-
+
+../libraries/boost/typeof/pointers_data_members.hpp
+boost/typeof/encode_decode_params.hpp
+-
+boost/typeof/encode_decode.hpp
+-
+
+../libraries/boost/typeof/register_functions.hpp
+boost/preprocessor/repetition/enum.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_trailing_params.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/if.hpp
+-
+boost/preprocessor/arithmetic/add.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+
+../libraries/boost/typeof/register_fundamental.hpp
+boost/typeof/typeof.hpp
+-
+
+../libraries/boost/typeof/template_encoding.hpp
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/repetition/enum_trailing.hpp
+-
+boost/preprocessor/control/iif.hpp
+-
+boost/preprocessor/detail/is_unary.hpp
+-
+boost/preprocessor/repetition/repeat.hpp
+-
+boost/preprocessor/tuple/eat.hpp
+-
+boost/preprocessor/seq/transform.hpp
+-
+boost/preprocessor/seq/for_each_i.hpp
+-
+boost/preprocessor/seq/cat.hpp
+-
+boost/typeof/encode_decode.hpp
+-
+boost/typeof/int_encoding.hpp
+-
+boost/typeof/type_template_param.hpp
+-
+boost/typeof/integral_template_param.hpp
+-
+boost/typeof/template_template_param.hpp
+-
+
+../libraries/boost/typeof/template_template_param.hpp
+boost/preprocessor/logical/or.hpp
+-
+boost/preprocessor/seq/fold_left.hpp
+-
+boost/preprocessor/seq/enum.hpp
+-
+
+../libraries/boost/typeof/type_encoding.hpp
+
+../libraries/boost/typeof/type_template_param.hpp
+
+../libraries/boost/typeof/typeof.hpp
+boost/config.hpp
+-
+boost/config/workaround.hpp
+-
+boost/typeof/dmc/typeof_impl.hpp
+-
+boost/typeof/msvc/typeof_impl.hpp
+-
+boost/typeof/unsupported.hpp
+-
+boost/typeof/message.hpp
+-
+boost/typeof/typeof_impl.hpp
+-
+boost/typeof/type_encoding.hpp
+-
+boost/typeof/template_encoding.hpp
+-
+boost/typeof/modifiers.hpp
+-
+boost/typeof/pointers_data_members.hpp
+-
+boost/typeof/register_functions.hpp
+-
+boost/typeof/register_fundamental.hpp
+-
+boost/typeof/message.hpp
+-
+boost/typeof/decltype.hpp
+-
+boost/typeof/native.hpp
+-
+
+../libraries/boost/typeof/typeof_impl.hpp
+boost/preprocessor/repetition/enum.hpp
+-
+boost/typeof/constant.hpp
+-
+boost/typeof/encode_decode.hpp
+-
+boost/typeof/vector.hpp
+-
+boost/type_traits/enable_if.hpp
+-
+boost/type_traits/is_function.hpp
+-
+cstddef
+-
+
+../libraries/boost/typeof/unsupported.hpp
+
+../libraries/boost/typeof/vector.hpp
+boost/typeof/constant.hpp
+-
+boost/preprocessor/iteration/self.hpp
+-
+boost/typeof/vector50.hpp
+-
+boost/typeof/vector100.hpp
+-
+boost/typeof/vector150.hpp
+-
+boost/typeof/vector200.hpp
+-
+boost/preprocessor/enum_params.hpp
+-
+boost/preprocessor/repeat.hpp
+-
+boost/preprocessor/repeat_from_to.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/inc.hpp
+-
+boost/preprocessor/dec.hpp
+-
+boost/preprocessor/comma_if.hpp
+-
+boost/preprocessor/iteration/local.hpp
+-
+boost/preprocessor/control/expr_iif.hpp
+-
+boost/preprocessor/logical/not.hpp
+-
+
+../libraries/boost/typeof/vector100.hpp
+
+../libraries/boost/typeof/vector150.hpp
+
+../libraries/boost/typeof/vector200.hpp
+
+../libraries/boost/typeof/vector50.hpp
+
+../libraries/boost/units/config.hpp
+boost/config.hpp
+-
+boost/version.hpp
+-
+boost/typeof/typeof.hpp
+-
+
+../libraries/boost/units/conversion.hpp
+boost/units/detail/conversion_impl.hpp
+-
+
+../libraries/boost/units/detail/conversion_impl.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/divides.hpp
+-
+boost/preprocessor/seq/enum.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/units/heterogeneous_system.hpp
+-
+boost/units/homogeneous_system.hpp
+-
+boost/units/reduce_unit.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/dimension_list.hpp
+-
+boost/units/detail/heterogeneous_conversion.hpp
+-
+boost/units/detail/one.hpp
+-
+boost/units/detail/static_rational_power.hpp
+-
+boost/units/detail/unscale.hpp
+-
+boost/units/units_fwd.hpp
+-
+
+../libraries/boost/units/detail/dim_impl.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/less.hpp
+-
+boost/units/units_fwd.hpp
+-
+
+../libraries/boost/units/detail/dimension_impl.hpp
+boost/mpl/begin_end.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/if.hpp
+-
+boost/mpl/list.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/size.hpp
+-
+boost/mpl/less.hpp
+-
+boost/units/config.hpp
+-
+boost/units/dimensionless_type.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/dimension_list.hpp
+-
+boost/units/detail/push_front_if.hpp
+-
+boost/units/detail/push_front_or_add.hpp
+-
+
+../libraries/boost/units/detail/dimension_list.hpp
+boost/mpl/next.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/push_front_fwd.hpp
+-
+boost/mpl/pop_front_fwd.hpp
+-
+boost/mpl/size_fwd.hpp
+-
+boost/mpl/begin_end_fwd.hpp
+-
+boost/mpl/front_fwd.hpp
+-
+boost/units/config.hpp
+-
+boost/units/dimensionless_type.hpp
+-
+
+../libraries/boost/units/detail/dimensionless_unit.hpp
+boost/mpl/bool.hpp
+-
+boost/units/units_fwd.hpp
+-
+
+../libraries/boost/units/detail/heterogeneous_conversion.hpp
+boost/mpl/minus.hpp
+-
+boost/mpl/times.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/homogeneous_system.hpp
+-
+boost/units/detail/linear_algebra.hpp
+-
+
+../libraries/boost/units/detail/linear_algebra.hpp
+boost/units/static_rational.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/units/dim.hpp
+-
+boost/units/dimensionless_type.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/detail/dimension_list.hpp
+-
+boost/units/detail/sort.hpp
+-
+
+../libraries/boost/units/detail/one.hpp
+boost/units/operators.hpp
+-
+
+../libraries/boost/units/detail/push_front_if.hpp
+
+../libraries/boost/units/detail/push_front_or_add.hpp
+boost/mpl/plus.hpp
+-
+boost/mpl/front.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/pop_front.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/push_front_if.hpp
+-
+
+../libraries/boost/units/detail/sort.hpp
+boost/mpl/size.hpp
+-
+boost/mpl/begin.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/less.hpp
+-
+boost/units/dimensionless_type.hpp
+-
+boost/units/detail/dimension_list.hpp
+-
+
+../libraries/boost/units/detail/static_rational_power.hpp
+boost/config/no_tr1/cmath.hpp
+-
+boost/units/detail/one.hpp
+-
+boost/units/operators.hpp
+-
+
+../libraries/boost/units/detail/unscale.hpp
+string
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/size.hpp
+-
+boost/mpl/begin.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/times.hpp
+-
+boost/mpl/negate.hpp
+-
+boost/mpl/less.hpp
+-
+boost/units/config.hpp
+-
+boost/units/dimension.hpp
+-
+boost/units/scale.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/one.hpp
+-
+
+../libraries/boost/units/dim.hpp
+boost/static_assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/units/config.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/detail/dim_impl.hpp
+-
+
+../libraries/boost/units/dimension.hpp
+boost/static_assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/detail/dimension_list.hpp
+-
+boost/units/detail/dimension_impl.hpp
+-
+
+../libraries/boost/units/dimensionless_type.hpp
+boost/mpl/long.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/units/config.hpp
+-
+
+../libraries/boost/units/get_dimension.hpp
+boost/units/units_fwd.hpp
+-
+
+../libraries/boost/units/get_system.hpp
+boost/units/units_fwd.hpp
+-
+
+../libraries/boost/units/heterogeneous_system.hpp
+boost/mpl/bool.hpp
+-
+boost/mpl/plus.hpp
+-
+boost/mpl/times.hpp
+-
+boost/mpl/divides.hpp
+-
+boost/mpl/negate.hpp
+-
+boost/mpl/less.hpp
+-
+boost/mpl/size.hpp
+-
+boost/mpl/begin.hpp
+-
+boost/mpl/next.hpp
+-
+boost/mpl/deref.hpp
+-
+boost/mpl/front.hpp
+-
+boost/mpl/push_front.hpp
+-
+boost/mpl/pop_front.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/units/config.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/dimension.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/push_front_if.hpp
+-
+boost/units/detail/push_front_or_add.hpp
+-
+boost/units/detail/linear_algebra.hpp
+-
+boost/units/detail/unscale.hpp
+-
+
+../libraries/boost/units/homogeneous_system.hpp
+boost/mpl/bool.hpp
+-
+boost/units/config.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/mpl/not.hpp
+-
+boost/units/detail/linear_algebra.hpp
+-
+
+../libraries/boost/units/operators.hpp
+boost/static_assert.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/units/config.hpp
+-
+
+../libraries/boost/units/quantity.hpp
+algorithm
+-
+boost/config.hpp
+-
+boost/static_assert.hpp
+-
+boost/mpl/bool.hpp
+-
+boost/mpl/and.hpp
+-
+boost/mpl/not.hpp
+-
+boost/mpl/or.hpp
+-
+boost/mpl/assert.hpp
+-
+boost/utility/enable_if.hpp
+-
+boost/type_traits/is_arithmetic.hpp
+-
+boost/type_traits/is_convertible.hpp
+-
+boost/type_traits/is_integral.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/units/conversion.hpp
+-
+boost/units/dimensionless_type.hpp
+-
+boost/units/homogeneous_system.hpp
+-
+boost/units/operators.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/dimensionless_unit.hpp
+-
+
+../libraries/boost/units/reduce_unit.hpp
+
+../libraries/boost/units/scale.hpp
+string
+-
+boost/units/config.hpp
+-
+boost/units/static_rational.hpp
+-
+boost/units/units_fwd.hpp
+-
+boost/units/detail/one.hpp
+-
+boost/units/detail/static_rational_power.hpp
+-
+
+../libraries/boost/units/static_rational.hpp
+boost/integer/common_factor_ct.hpp
+-
+boost/mpl/less.hpp
+-
+boost/mpl/arithmetic.hpp
+-
+boost/mpl/eval_if.hpp
+-
+boost/mpl/integral_c.hpp
+-
+boost/mpl/identity.hpp
+-
+boost/units/config.hpp
+-
+boost/units/operators.hpp
+-
+
+../libraries/boost/units/units_fwd.hpp
+string
+-
+
+../libraries/boost/utility.hpp
+boost/utility/base_from_member.hpp
+-
+boost/utility/binary.hpp
+-
+boost/utility/identity_type.hpp
+-
+boost/core/addressof.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/core/checked_delete.hpp
+-
+boost/core/noncopyable.hpp
+-
+
+../libraries/boost/utility/addressof.hpp
+boost/core/addressof.hpp
+-
+
+../libraries/boost/utility/base_from_member.hpp
+boost/config.hpp
+-
+boost/preprocessor/arithmetic/inc.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/repeat_from_to.hpp
+-
+boost/type_traits/is_same.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/utility/enable_if.hpp
+-
+
+../libraries/boost/utility/binary.hpp
+boost/preprocessor/control/deduce_d.hpp
+-
+boost/preprocessor/facilities/identity.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/seq/cat.hpp
+-
+boost/preprocessor/seq/transform.hpp
+-
+boost/preprocessor/arithmetic/mod.hpp
+-
+boost/preprocessor/seq/size.hpp
+-
+boost/preprocessor/facilities/empty.hpp
+-
+boost/preprocessor/control/while.hpp
+-
+
+../libraries/boost/utility/detail/result_of_iterate.hpp
+
+../libraries/boost/utility/enable_if.hpp
+boost/core/enable_if.hpp
+-
+
+../libraries/boost/utility/identity_type.hpp
+boost/type_traits/function_traits.hpp
+-
+
+../libraries/boost/utility/result_of.hpp
+boost/config.hpp
+-
+boost/preprocessor/cat.hpp
+-
+boost/preprocessor/iteration/iterate.hpp
+-
+boost/preprocessor/repetition/enum_params.hpp
+-
+boost/preprocessor/repetition/enum_trailing_params.hpp
+-
+boost/preprocessor/repetition/enum_binary_params.hpp
+-
+boost/preprocessor/repetition/enum_shifted_params.hpp
+-
+boost/preprocessor/facilities/intercept.hpp
+-
+boost/detail/workaround.hpp
+-
+boost/type_traits/is_class.hpp
+-
+boost/type_traits/is_pointer.hpp
+-
+boost/type_traits/is_member_function_pointer.hpp
+-
+boost/type_traits/remove_cv.hpp
+-
+boost/type_traits/remove_reference.hpp
+-
+boost/type_traits/declval.hpp
+-
+boost/type_traits/conditional.hpp
+-
+boost/type_traits/type_identity.hpp
+-
+boost/type_traits/integral_constant.hpp
+-
+boost/core/enable_if.hpp
+-
+boost/utility/detail/result_of_iterate.hpp
+-
+
+../libraries/boost/utility/value_init.hpp
+boost/config.hpp
+-
+boost/swap.hpp
+-
+cstring
+-
+cstddef
+-
+
+../libraries/boost/version.hpp
+
+../libraries/boost/visit_each.hpp
+
+../libraries/boost/winapi/basic_types.hpp
+boost/winapi/config.hpp
+-
+windows.h
+-
+kfuncs.h
+-
+boost/winapi/detail/header.hpp
+-
+boost/winapi/detail/footer.hpp
+-
+
+../libraries/boost/winapi/config.hpp
+boost/predef/version_number.h
+-
+boost/predef/platform.h
+-
+_cygwin.h
+-
+boost/config.hpp
+-
+
+../libraries/boost/winapi/detail/footer.hpp
+
+../libraries/boost/winapi/detail/header.hpp
+
+../libraries/boost/winapi/get_current_thread.hpp
+boost/winapi/basic_types.hpp
+-
+boost/winapi/detail/header.hpp
+-
+boost/winapi/detail/footer.hpp
+-
+
+../libraries/boost/winapi/get_current_thread_id.hpp
+boost/winapi/basic_types.hpp
+-
+boost/winapi/detail/header.hpp
+-
+boost/winapi/detail/footer.hpp
+-
+
+../libraries/boost/winapi/thread.hpp
+boost/winapi/basic_types.hpp
+-
+boost/winapi/get_current_thread.hpp
+-
+boost/winapi/get_current_thread_id.hpp
+-
+boost/winapi/detail/header.hpp
+-
+boost/winapi/detail/footer.hpp
+-
+
+../src/EC.h
+Tissue.h
+../src/Tissue.h
+
 ../src/Tissue.h
 vector
 -
@@ -14,6 +22330,18 @@
 protein.h
 ../src/protein.h
 
+../src/environment.h
+protein.h
+../src/protein.h
+objects.h
+../src/objects.h
+
+../src/memAgents.h
+objects.h
+../src/objects.h
+protein.h
+../src/protein.h
+
 ../src/objects.h
 pybind11/pybind11.h
 -
@@ -42,13 +22370,423 @@
 string
 -
 
-../src/space.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/EC.cpp
+iostream
+-
+vector
+-
+memAgents.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/memAgents.h
+EC.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/EC.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/EC.h
+Tissue.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/Tissue.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/Tissue.h
+vector
+-
+space.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/space.h
+protein.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/protein.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/memAgents.h
+objects.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/objects.h
+protein.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/protein.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/objects.h
+pybind11/pybind11.h
+-
+pybind11/numpy.h
+-
+pybind11/stl.h
+-
+vector
+-
+iostream
+-
+iomanip
+-
+fstream
+-
+array
+-
+random
+-
+algorithm
+-
+utils.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/utils.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/protein.h
+string
+-
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/space.h
 objects.h
-../src/objects.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/objects.h
 
-../src/utils.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/utils.h
 
-/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/generated/dsl_Tissue.cpp
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/world.h
+space.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/space.h
+protein.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/protein.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/helper_ODE.cpp
+boost/array.hpp
+-
+boost/numeric/odeint.hpp
+-
+../../src/objects.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/objects.h
+../../src/world.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/src/world.h
+helper_ODE.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/helper_ODE.h
+EC.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/EC.h
+memAgents.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/memAgents.h
 Tissue.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/Tissue.h
+environment.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/environment.h
+protein.h
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/protein.h
+
+/Users/meadt/MPSProjects/MSM_DSL/MSM_DSL/tests/automated/helper_ODE.h
+gtest/gtest.h
+-
+
+_deps/googletest-src/googletest/include/gtest/gtest-death-test.h
+gtest/internal/gtest-death-test-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-death-test-internal.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-matchers.h
+atomic
+-
+memory
+-
+ostream
+-
+string
+-
+type_traits
+-
+gtest/gtest-printers.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-printers.h
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-port.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-message.h
+limits
+-
+memory
+-
+sstream
+-
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-port.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-param-test.h
+iterator
+-
+utility
+-
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-param-util.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-param-util.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-port.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-printers.h
+functional
+-
+memory
+-
+ostream
+-
+sstream
+-
+string
+-
+tuple
+-
+type_traits
+-
+utility
+-
+vector
+-
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-port.h
+gtest/internal/custom/gtest-printers.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/custom/gtest-printers.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-test-part.h
+iosfwd
+-
+vector
+-
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-string.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-string.h
+
+_deps/googletest-src/googletest/include/gtest/gtest-typed-test.h
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-port.h
+gtest/internal/gtest-type-util.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-type-util.h
+
+_deps/googletest-src/googletest/include/gtest/gtest.h
+cstddef
+-
+limits
+-
+memory
+-
+ostream
+-
+type_traits
+-
+vector
+-
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-internal.h
+gtest/internal/gtest-string.h
+_deps/googletest-src/googletest/include/gtest/gtest/internal/gtest-string.h
+gtest/gtest-death-test.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-death-test.h
+gtest/gtest-matchers.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-matchers.h
+gtest/gtest-message.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-message.h
+gtest/gtest-param-test.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-param-test.h
+gtest/gtest-printers.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-printers.h
+gtest/gtest_prod.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest_prod.h
+gtest/gtest-test-part.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-test-part.h
+gtest/gtest-typed-test.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest-typed-test.h
+gtest/gtest_pred_impl.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest_pred_impl.h
+
+_deps/googletest-src/googletest/include/gtest/gtest_pred_impl.h
+gtest/gtest.h
+_deps/googletest-src/googletest/include/gtest/gtest/gtest.h
+
+_deps/googletest-src/googletest/include/gtest/gtest_prod.h
+
+_deps/googletest-src/googletest/include/gtest/internal/custom/gtest-port.h
+
+_deps/googletest-src/googletest/include/gtest/internal/custom/gtest-printers.h
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-death-test-internal.h
+gtest/gtest-matchers.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/gtest-matchers.h
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-internal.h
+stdio.h
+-
+memory
+-
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-filepath.h
+gtest/internal/gtest-string.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-string.h
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-internal.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-port.h
+stdlib.h
+-
+sys/types.h
+-
+sys/wait.h
+-
+unistd.h
+-
+stdexcept
+-
+ctype.h
+-
+float.h
+-
+string.h
+-
+cstdint
+-
+iomanip
+-
+limits
+-
+map
+-
+set
+-
+string
+-
+type_traits
+-
+vector
+-
+gtest/gtest-message.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/gtest-message.h
+gtest/internal/gtest-filepath.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-filepath.h
+gtest/internal/gtest-string.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-string.h
+gtest/internal/gtest-type-util.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-type-util.h
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-param-util.h
+ctype.h
+-
+cassert
+-
+iterator
+-
+memory
+-
+set
+-
+tuple
+-
+type_traits
+-
+utility
+-
+vector
+-
+gtest/internal/gtest-internal.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-internal.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-port.h
+gtest/gtest-printers.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/gtest-printers.h
+gtest/gtest-test-part.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/gtest-test-part.h
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-port-arch.h
+winapifamily.h
+-
+TargetConditionals.h
+-
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-port.h
+ctype.h
+-
+stddef.h
+-
+stdio.h
+-
+stdlib.h
+-
+string.h
+-
+cerrno
+-
+cstdint
+-
+limits
+-
+type_traits
+-
+sys/types.h
+-
+sys/stat.h
+-
+AvailabilityMacros.h
+-
+TargetConditionals.h
+-
+iostream
+-
+locale
+-
+memory
+-
+string
+-
+tuple
+-
+vector
+-
+gtest/internal/custom/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/custom/gtest-port.h
+gtest/internal/gtest-port-arch.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-port-arch.h
+direct.h
+-
+io.h
+-
+unistd.h
+-
+unistd.h
+-
+strings.h
+-
+android/api-level.h
+-
+regex.h
+-
+typeinfo
+-
+pthread.h
+-
+time.h
+-
+absl/types/any.h
+_deps/googletest-src/googletest/include/gtest/internal/absl/types/any.h
+any
+-
+absl/types/optional.h
+_deps/googletest-src/googletest/include/gtest/internal/absl/types/optional.h
+optional
+-
+absl/strings/string_view.h
+_deps/googletest-src/googletest/include/gtest/internal/absl/strings/string_view.h
+string_view
+-
+absl/types/variant.h
+_deps/googletest-src/googletest/include/gtest/internal/absl/types/variant.h
+variant
+-
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-string.h
+mem.h
+-
+string.h
+-
+cstdint
+-
+string
+-
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-port.h
+
+_deps/googletest-src/googletest/include/gtest/internal/gtest-type-util.h
+gtest/internal/gtest-port.h
+_deps/googletest-src/googletest/include/gtest/internal/gtest/internal/gtest-port.h
+cxxabi.h
+-
+acxx_demangle.h
 -
 
